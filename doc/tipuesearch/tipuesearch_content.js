var tipuesearch = {"pages":[{"title":" Smoke Ring ","text":"Smoke Ring 概要 3次元ナビエ・ストークス方程式を解いて渦輪の形成と伝播のシミュレーションを行う。 シミュレーション領域 直方体領域。3次元周期境界条件。カーテシアン座標。 計算手法 空間離散化は2次中心差分法。時間積分は4次ルンゲ・クッタ法。 実行方法 cd src make cd ../job qsub sample.js","tags":"home","loc":"index.html"},{"title":"vis2d_plane_xy_t – Smoke Ring ","text":"type, private :: vis2d_plane_xy_t Inherits type~~vis2d_plane_xy_t~~InheritsGraph type~vis2d_plane_xy_t vis2d_plane_xy_t vv_slice_scalar_t vv_slice_scalar_t type~vis2d_plane_xy_t->vv_slice_scalar_t pressure, flow_helicity, velocity_z, enstrophy vv_slice_vector_t vv_slice_vector_t type~vis2d_plane_xy_t->vv_slice_vector_t velocity, vorticity Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~vis2d_plane_xy_t~~InheritedByGraph type~vis2d_plane_xy_t vis2d_plane_xy_t type~vis2d_t vis2d_t type~vis2d_t->type~vis2d_plane_xy_t z_middle, z_upper, z_lower Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Variables enstrophy flow_helicity gk_cut pressure tag velocity velocity_z vorticity Type-Bound Procedures draw initialize set_data Source Code vis2d_plane_xy_t Components Type Visibility Attributes Name Initial type(vv_slice_scalar_t), public :: enstrophy type(vv_slice_scalar_t), public :: flow_helicity integer, public :: gk_cut type(vv_slice_scalar_t), public :: pressure character(len=TAG_NAME_MAX), public :: tag type(vv_slice_vector_t), public :: velocity type(vv_slice_scalar_t), public :: velocity_z type(vv_slice_vector_t), public :: vorticity Type-Bound Procedures procedure, public,  :: draw => vis2d_plane_xy__draw private  subroutine vis2d_plane_xy__draw (plane, t, step) < Arguments Type Intent Optional Attributes Name class( vis2d_plane_xy_t ), intent(inout) :: plane real, intent(in) :: t integer, intent(in) :: step procedure, public,  :: initialize => vis2d_plane_xy__initialize private  subroutine vis2d_plane_xy__initialize (plane, gk_cut, tag) Arguments Type Intent Optional Attributes Name class( vis2d_plane_xy_t ), intent(out) :: plane integer, intent(in) :: gk_cut character(len=*), intent(in) :: tag procedure, public,  :: set_data => vis2d_plane_xy__set_data private  subroutine vis2d_plane_xy__set_data (plane, fluid, vf) Arguments Type Intent Optional Attributes Name class( vis2d_plane_xy_t ), intent(inout) :: plane type( fluid_t ), intent(in) :: fluid type( vissubfield3d_t ), intent(in) :: vf Source Code type vis2d_plane_xy_t integer :: gk_cut character ( len = TAG_NAME_MAX ) :: tag type ( vv_slice_scalar_t ) :: pressure type ( vv_slice_scalar_t ) :: flow_helicity type ( vv_slice_scalar_t ) :: velocity_z type ( vv_slice_scalar_t ) :: enstrophy type ( vv_slice_vector_t ) :: velocity type ( vv_slice_vector_t ) :: vorticity contains procedure :: initialize => vis2d_plane_xy__initialize procedure :: set_data => vis2d_plane_xy__set_data procedure :: draw => vis2d_plane_xy__draw end type vis2d_plane_xy_t","tags":"","loc":"type/vis2d_plane_xy_t.html"},{"title":"vis2d_plane_xz_t – Smoke Ring ","text":"type, private :: vis2d_plane_xz_t Inherits type~~vis2d_plane_xz_t~~InheritsGraph type~vis2d_plane_xz_t vis2d_plane_xz_t vv_slice_scalar_t vv_slice_scalar_t type~vis2d_plane_xz_t->vv_slice_scalar_t pressure, flow_helicity, velocity_y, enstrophy vv_slice_vector_t vv_slice_vector_t type~vis2d_plane_xz_t->vv_slice_vector_t velocity, vorticity Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~vis2d_plane_xz_t~~InheritedByGraph type~vis2d_plane_xz_t vis2d_plane_xz_t type~vis2d_t vis2d_t type~vis2d_t->type~vis2d_plane_xz_t y_middle, y_upper, y_lower Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Variables enstrophy flow_helicity gj_cut pressure tag velocity velocity_y vorticity Type-Bound Procedures draw initialize set_data Source Code vis2d_plane_xz_t Components Type Visibility Attributes Name Initial type(vv_slice_scalar_t), public :: enstrophy type(vv_slice_scalar_t), public :: flow_helicity integer, public :: gj_cut type(vv_slice_scalar_t), public :: pressure character(len=TAG_NAME_MAX), public :: tag type(vv_slice_vector_t), public :: velocity type(vv_slice_scalar_t), public :: velocity_y type(vv_slice_vector_t), public :: vorticity Type-Bound Procedures procedure, public,  :: draw => vis2d_plane_xz__draw private  subroutine vis2d_plane_xz__draw (plane, t, step) < < Arguments Type Intent Optional Attributes Name class( vis2d_plane_xz_t ), intent(inout) :: plane real, intent(in) :: t integer, intent(in) :: step procedure, public,  :: initialize => vis2d_plane_xz__initialize private  subroutine vis2d_plane_xz__initialize (plane, gj_cut, tag) Arguments Type Intent Optional Attributes Name class( vis2d_plane_xz_t ), intent(out) :: plane integer, intent(in) :: gj_cut character(len=*), intent(in) :: tag procedure, public,  :: set_data => vis2d_plane_xz__set_data private  subroutine vis2d_plane_xz__set_data (plane, fluid, vf) Arguments Type Intent Optional Attributes Name class( vis2d_plane_xz_t ), intent(inout) :: plane type( fluid_t ), intent(in) :: fluid type( vissubfield3d_t ), intent(in) :: vf Source Code type vis2d_plane_xz_t integer :: gj_cut character ( len = TAG_NAME_MAX ) :: tag type ( vv_slice_scalar_t ) :: pressure type ( vv_slice_scalar_t ) :: flow_helicity type ( vv_slice_scalar_t ) :: velocity_y type ( vv_slice_scalar_t ) :: enstrophy type ( vv_slice_vector_t ) :: velocity type ( vv_slice_vector_t ) :: vorticity contains procedure :: initialize => vis2d_plane_xz__initialize procedure :: set_data => vis2d_plane_xz__set_data procedure :: draw => vis2d_plane_xz__draw end type vis2d_plane_xz_t","tags":"","loc":"type/vis2d_plane_xz_t.html"},{"title":"vis2d_t – Smoke Ring ","text":"type, public :: vis2d_t Inherits type~~vis2d_t~~InheritsGraph type~vis2d_t vis2d_t type~vis2d_plane_xy_t vis2d_plane_xy_t type~vis2d_t->type~vis2d_plane_xy_t z_middle, z_upper, z_lower type~vis2d_plane_xz_t vis2d_plane_xz_t type~vis2d_t->type~vis2d_plane_xz_t y_middle, y_upper, y_lower vv_slice_scalar_t vv_slice_scalar_t type~vis2d_plane_xy_t->vv_slice_scalar_t pressure, flow_helicity, velocity_z, enstrophy vv_slice_vector_t vv_slice_vector_t type~vis2d_plane_xy_t->vv_slice_vector_t velocity, vorticity type~vis2d_plane_xz_t->vv_slice_scalar_t pressure, flow_helicity, velocity_y, enstrophy type~vis2d_plane_xz_t->vv_slice_vector_t velocity, vorticity Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Variables y_lower y_middle y_upper z_lower z_middle z_upper Type-Bound Procedures draw initialize set_data Source Code vis2d_t Components Type Visibility Attributes Name Initial type( vis2d_plane_xz_t ), public :: y_lower type( vis2d_plane_xz_t ), public :: y_middle type( vis2d_plane_xz_t ), public :: y_upper type( vis2d_plane_xy_t ), public :: z_lower type( vis2d_plane_xy_t ), public :: z_middle type( vis2d_plane_xy_t ), public :: z_upper Type-Bound Procedures procedure, public,  :: draw => vis2d__draw public  subroutine vis2d__draw (vis2d, t_double, nloop, fluid) Arguments Type Intent Optional Attributes Name class( vis2d_t ), intent(inout) :: vis2d real(kind=DR), intent(in) :: t_double integer, intent(in) :: nloop type( fluid_t ), intent(in) :: fluid procedure, public,  :: initialize => vis2d__initialize public  subroutine vis2d__initialize (vis2d) Arguments Type Intent Optional Attributes Name class( vis2d_t ), intent(out) :: vis2d procedure, public,  :: set_data => vis2d__set_data private  subroutine vis2d__set_data (vis2d, fluid) Arguments Type Intent Optional Attributes Name class( vis2d_t ), intent(inout) :: vis2d type( fluid_t ), intent(in) :: fluid Source Code type , public :: vis2d_t type ( vis2d_plane_xy_t ) :: z_middle type ( vis2d_plane_xy_t ) :: z_upper type ( vis2d_plane_xy_t ) :: z_lower type ( vis2d_plane_xz_t ) :: y_middle type ( vis2d_plane_xz_t ) :: y_upper type ( vis2d_plane_xz_t ) :: y_lower contains procedure :: initialize => vis2d__initialize procedure :: set_data => vis2d__set_data procedure :: draw => vis2d__draw end type vis2d_t","tags":"","loc":"type/vis2d_t.html"},{"title":"vissubfield3d_t – Smoke Ring ","text":"type, private :: vissubfield3d_t Inherits type~~vissubfield3d_t~~InheritsGraph type~vissubfield3d_t vissubfield3d_t type~field__vector_t field__vector_t type~vissubfield3d_t->type~field__vector_t velocity, vorticity Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Variables enstrophy helicity velocity vorticity Type-Bound Procedures update Source Code vissubfield3d_t Components Type Visibility Attributes Name Initial real(kind=DR), public, dimension(0:NXPP1,0:NYPP1,0:NZPP1) :: enstrophy エンストロフィ（渦度の2乗） real(kind=DR), public, dimension(0:NXPP1,0:NYPP1,0:NZPP1) :: helicity ヘリシティ type( field__vector_t ), public :: velocity 流れ場 type( field__vector_t ), public :: vorticity 渦度（流れ場のcurl） Type-Bound Procedures procedure, public,  :: update => vissubfield3d__update private  subroutine vissubfield3d__update (vf, fluid) Arguments Type Intent Optional Attributes Name class( vissubfield3d_t ), intent(out) :: vf type( fluid_t ), intent(in) :: fluid Source Code type , private :: vissubfield3d_t real ( DR ), dimension ( 0 : NXPP1 , 0 : NYPP1 , 0 : NZPP1 ) :: enstrophy !! エンストロフィ（渦度の2乗） real ( DR ), dimension ( 0 : NXPP1 , 0 : NYPP1 , 0 : NZPP1 ) :: helicity !! ヘリシティ type ( field__vector_t ) :: velocity !! 流れ場 type ( field__vector_t ) :: vorticity !! 渦度（流れ場のcurl） contains procedure :: update => vissubfield3d__update end type vissubfield3d_t","tags":"","loc":"type/vissubfield3d_t.html"},{"title":"fluid_t – Smoke Ring ","text":"type, public :: fluid_t このシミュレーションコードで最も大事な\n変数（構造体）。流体の状態を保持する。 Inherits type~~fluid_t~~InheritsGraph type~fluid_t fluid_t type~field__vector_t field__vector_t type~fluid_t->type~field__vector_t flux Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Variables density flux pressure Type-Bound Procedures set_boundary_condition Source Code fluid_t Components Type Visibility Attributes Name Initial real(kind=DR), public, dimension(0:NXPP1,0:NYPP1,0:NZPP1) :: density 質量密度場 type( field__vector_t ), public :: flux 質量フラックス\n質量フラックス (flux) と速度場 (velocity_vector)\n   flux = density * velocity_vector\nという関係がある。速度場を基本変数にしても問題ない。\n単にこのシミュレーションで解く基本方程式\nナビエ・ストークス方程式）の基本変数をどちらで\n表現するか、の違いである。 real(kind=DR), public, dimension(0:NXPP1,0:NYPP1,0:NZPP1) :: pressure 圧力場 Type-Bound Procedures procedure, public,  :: set_boundary_condition => fluid__set_boundary_condition public  subroutine fluid__set_boundary_condition (fluid) プロセス間通信で領域境界データを交換 Arguments Type Intent Optional Attributes Name class( fluid_t ), intent(inout) :: fluid 流体構造体の周期境界条件設定 Source Code type , public :: fluid_t !! このシミュレーションコードで最も大事な !! 変数（構造体）。流体の状態を保持する。 real ( DR ), dimension ( 0 : NXPP1 , 0 : NYPP1 , 0 : NZPP1 ) :: pressure !! 圧力場 real ( DR ), dimension ( 0 : NXPP1 , 0 : NYPP1 , 0 : NZPP1 ) :: density !! 質量密度場 type ( field__vector_t ) :: flux !! 質量フラックス !! 質量フラックス (flux) と速度場 (velocity_vector) !!    flux = density * velocity_vector !! という関係がある。速度場を基本変数にしても問題ない。 !! 単にこのシミュレーションで解く基本方程式 !! ナビエ・ストークス方程式）の基本変数をどちらで !! 表現するか、の違いである。 contains procedure :: set_boundary_condition => fluid__set_boundary_condition end type fluid_t","tags":"","loc":"type/fluid_t.html"},{"title":"job_t – Smoke Ring ","text":"type, private :: job_t Contents Variables karte Type-Bound Procedures finalize initialize Source Code job_t Components Type Visibility Attributes Name Initial character(len=20), public :: karte = \"fine\" Type-Bound Procedures procedure, public, nopass :: finalize => job__finalize private  subroutine job__finalize (nloop) このどちらかであれば、 で第2引数の文字列を囲む。 MPI並列化終了処理 Arguments Type Intent Optional Attributes Name integer, intent(in) :: nloop ループカウンタ\nジョブ終了時の後始末。\n(1) 健康状態カルテに応じたメッセージを標準出力に書く\n(2) MPI並列化の終了処理 procedure, public, nopass :: initialize => job__initialize private  subroutine job__initialize () MPI並列化初期化処理。Parallel変数はparallel.efで定義\nされている。冒頭のPが大文字なのはこれがグローバル変数\nであることを示唆している。（コンパイラは大文字と小文字を\n区別しないが。） Arguments None Source Code type :: job_t character ( len = 20 ) :: karte = \"fine\" ! カルテ。初期は「健康」 contains procedure , nopass :: initialize => job__initialize procedure , nopass :: finalize => job__finalize end type job_t","tags":"","loc":"type/job_t.html"},{"title":"parallel_t – Smoke Ring ","text":"type, private :: parallel_t Inherits type~~parallel_t~~InheritsGraph type~parallel_t parallel_t mpiut__rank_next_t mpiut__rank_next_t type~parallel_t->mpiut__rank_next_t periodic_pair type~pos_t pos_t type~parallel_t->type~pos_t pos type~rank_t rank_t type~parallel_t->type~rank_t rank mpiut__rank_position_t mpiut__rank_position_t type~pos_t->mpiut__rank_position_t index type~rank_t->mpiut__rank_next_t next Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Variables comm i_have_xmax i_have_xmin i_have_ymax i_have_ymin i_have_zmax i_have_zmin nprocs periodic_pair pos rank Type-Bound Procedures finalize initialize io_clerk rank_to_pos_index Source Code parallel_t Components Type Visibility Attributes Name Initial integer, public :: comm logical, public :: i_have_xmax logical, public :: i_have_xmin logical, public :: i_have_ymax logical, public :: i_have_ymin logical, public :: i_have_zmax logical, public :: i_have_zmin integer, public :: nprocs type(mpiut__rank_next_t), public :: periodic_pair type( pos_t ), public :: pos type( rank_t ), public :: rank Type-Bound Procedures procedure, public, nopass :: finalize => parallel__finalize private  subroutine parallel__finalize () Arguments None procedure, public, nopass :: initialize => parallel__initialize private  subroutine parallel__initialize () < Arguments None procedure, public, nopass :: io_clerk => parallel__io_clerk private  function parallel__io_clerk (task) result(i_am) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: task Return Value logical < procedure, public, nopass :: rank_to_pos_index => parallel__rank_to_pos_index private  function parallel__rank_to_pos_index (rank) result(index) Arguments Type Intent Optional Attributes Name integer, intent(in) :: rank Return Value type(mpiut__rank_position_t) < Source Code type , private :: parallel_t integer :: nprocs integer :: comm type ( rank_t ) :: rank type ( pos_t ) :: pos type ( mpiut__rank_next_t ) :: periodic_pair logical :: i_have_xmax logical :: i_have_xmin logical :: i_have_ymax logical :: i_have_ymin logical :: i_have_zmax logical :: i_have_zmin contains procedure , nopass :: initialize => parallel__initialize procedure , nopass :: finalize => parallel__finalize procedure , nopass :: io_clerk => parallel__io_clerk procedure , nopass :: rank_to_pos_index & => parallel__rank_to_pos_index end type parallel_t","tags":"","loc":"type/parallel_t.html"},{"title":"pos_t – Smoke Ring ","text":"type, private :: pos_t Inherits type~~pos_t~~InheritsGraph type~pos_t pos_t mpiut__rank_position_t mpiut__rank_position_t type~pos_t->mpiut__rank_position_t index Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~pos_t~~InheritedByGraph type~pos_t pos_t type~parallel_t parallel_t type~parallel_t->type~pos_t pos Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Variables index string Source Code pos_t Components Type Visibility Attributes Name Initial type(mpiut__rank_position_t), public :: index character(len=12), public :: string Source Code type , private :: pos_t type ( mpiut__rank_position_t ) :: index character ( len = 12 ) :: string ! e.g., \"p012_035_064\" end type pos_t","tags":"","loc":"type/pos_t.html"},{"title":"rank_t – Smoke Ring ","text":"type, private :: rank_t Inherits type~~rank_t~~InheritsGraph type~rank_t rank_t mpiut__rank_next_t mpiut__rank_next_t type~rank_t->mpiut__rank_next_t next Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~rank_t~~InheritedByGraph type~rank_t rank_t type~parallel_t parallel_t type~parallel_t->type~rank_t rank Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Variables me next Source Code rank_t Components Type Visibility Attributes Name Initial integer, public :: me type(mpiut__rank_next_t), public :: next Source Code type , private :: rank_t integer :: me ! Rank number of myself. type ( mpiut__rank_next_t ) :: next ! Neighbor ranks. end type rank_t","tags":"","loc":"type/rank_t.html"},{"title":"params_t – Smoke Ring ","text":"type, private :: params_t Contents Type-Bound Procedures get_double get_integer get_logical get_string read Source Code params_t Type-Bound Procedures procedure, public, nopass :: get_double => params__get_double private  function params__get_double (variable) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: variable 問い合わせ変数の名前 Return Value real(kind=DR) その値\nこのモジュールの外からの問い合わせに応じてnamelistデータを返す。\nこの関数は問い合わせ変数が倍精度浮動小数点数の場合。\nこの関数の前にnamelist__readが呼ばれている必要がある。\nこの点はassertで確認している。 procedure, public, nopass :: get_integer => params__get_integer private  function params__get_integer (variable) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: variable 問い合わせ変数の名前 Return Value integer その値\nこのモジュールの外からの問い合わせに応じてnamelistデータを返す。\nこの関数は問い合わせ変数が整数の場合。\nこの関数の前にnamelist__readが呼ばれている必要がある。\nこの点はassertで確認している。 procedure, public, nopass :: get_logical => params__get_logical private  function params__get_logical (variable) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: variable 問い合わせ変数の名前 Return Value logical その値\nこのモジュールの外からの問い合わせに応じてnamelistデータを返す。\nこの関数は問い合わせ変数が論理値の場合。\nこの関数の前にnamelist__readが呼ばれている必要がある。\nこの点はassertで確認している。 procedure, public, nopass :: get_string => params__get_string private  function params__get_string (variable) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: variable 問い合わせ変数の名前 Return Value character(len=STRING_LENGTH_MAX) その値\nこのモジュールの外からの問い合わせに応じてnamelistデータを返す。\nこの関数は問い合わせ変数が文字列の場合。\nこの関数の前にnamelist__readが呼ばれている必要がある。\nこの点はassertで確認している。 procedure, public, nopass :: read => params__read private  subroutine params__read () namelistファイルをディスクから読み込む。\n ファイル名はコマンド第一引数。 namelistデータファイルの内容を変更する場合は\n 以下のread文も適宜変更する。 * * * &simulation      Total_nloop = 2000 /\n &visualization   Slicedata_nskip  = 100, Slicedata_tag = '_data_slice' /\n &fluid_property  Viscosity = 3.0e-2, Kappa = 3.e-2 / * * * Arguments None Source Code type :: params_t contains procedure , nopass :: read => params__read procedure , nopass :: get_double => params__get_double procedure , nopass :: get_integer => params__get_integer procedure , nopass :: get_logical => params__get_logical procedure , nopass :: get_string => params__get_string end type params_t","tags":"","loc":"type/params_t.html"},{"title":"solver_t – Smoke Ring ","text":"type, private :: solver_t Contents Type-Bound Procedures advance diagnosis get_subfield initialize set_time_step subfield_vel subfield_vel_tm subfield_vel_tm_divv Source Code solver_t Type-Bound Procedures procedure, public, nopass :: advance => solver__advance private  subroutine solver__advance (t, dt, fluid) 4段4次ルンゲ・クッタ積分法による時間積分の実行 Note ここでは教科書に書かれている古典的な4段4次の\n   ルンゲ・クッタ積分法をそのまま実装している。\n   作業用の構造体を5つ使用している（dfluid01からdfluid04とgluid）\n   これらの作業変数の数を減らし、メモリを節約にするためには\n   Runge-Kutta-Gill法などの方法がある。 Note 速度（vel）、温度（tm）, 速度の発散（divv）などの配列などは\n   このスキームでは基本変数から毎回計算すべき一種の作業配列である。\n   したがって、このモジュール内の他の場所（サブルーチン・関数）でも\n   これらの変数（3次元の大きな配列）を宣言・使用している。\n   使用メモリを節約するためにはこれらの作業配列は共通のものを\n   一つづつ用意するというのも可能である。しかし、そうするとコードが\n   読みにくくなるであろう。 基本変数から副次的変数である速度、温度、速度の発散を求める\n 渦輪を駆動する力は時刻（t）の関数として設定しているので、\n いま解いているナビエ・ストークス方程式は時間に陽に依存する。 ---ルンゲ・クッタの第2段---\n Fortranコンパイラが自己定義演算子をきちんと処理できる\n 場合は上の簡潔な記述の方が（読みやすいので）好ましい。 ---ルンゲ・クッタの第3段---\n Fortranコンパイラが自己定義演算子をきちんと処理できる\n 場合は上の簡潔な記述の方が（読みやすいので）好ましい。 繰り返すが、渦輪を駆動する力は時刻（t）の関数として設定しているので、\n いま解いているナビエ・ストークス方程式は時間に陽に依存する。 ---ルンゲ・クッタの第4段---\n Fortranコンパイラが自己定義演算子をきちんと処理できる\n 場合は上の簡潔な記述の方が（読みやすいので）好ましい。 --- 最終結果 --- Fortranコンパイラが自己定義演算子をきちんと処理できる\n 場合は一番上の簡潔な記述の方が（読みやすいので）好ましい。 Arguments Type Intent Optional Attributes Name real(kind=DR), intent(inout) :: t 時刻 real(kind=DR), intent(in) :: dt 時間刻み幅 type( fluid_t ), intent(inout) :: fluid 流体データ procedure, public, nopass :: diagnosis => solver__diagnosis private  subroutine solver__diagnosis (nloop, time, fluid) 流体の「健康状態」を診断する\nこのルーチンは結構計算負荷が高いので、\n毎ステップではなく、SKIPステップごとに診断を実行する Already in error state.\nジョブの健康状態がfine（つまり健康）以外の値に\n設定する可能性があるのはここ以外にもある（例えばmain.f90の\nメインループでシミュレーションのループカウンタが最大値が達するなど）\nそのような場合、どうせこの後、ジョブの停止処理に入るので、\nこれ以上計算を進めなくてもよい。 質量フラックスのx成分が異常に大きい。\nこれ以上計算しても無駄（すぐに終了処理に入るべし）\nこれ以上計算しても無駄（すぐに終了処理に入るべし）\n質量フラックスのz成分が異常に大きい。\nこれ以上計算しても無駄（すぐに終了処理に入るべし）\n質量が異常に大きい\nこれ以上計算しても無駄（すぐに終了処理に入るべし）\n圧力が異常に大きい\nこれ以上計算しても無駄（すぐに終了処理に入るべし）\n圧力が負になってしまっている\nこれ以上計算しても無駄（すぐに終了処理に入るべし）\n密度が負になってしまっている\nこれ以上計算しても無駄（すぐに終了処理に入るべし）\n基本流れデータから副次的な速度場データを求める 速度の最大値（ベクトルの長さ）を計算し標準出力に書き出す\nわずか1行で書いているが、実際にはここにかなりの計算が\n含まれている。vel.x**2という配列演算は実際には3重do loop\nであり、maxval関数はその引数の3次元配列をとっている。\nつまり全要素中の最大値をとっている。そして最後に\nsqrtをとって振幅（ベクトルの長さ）を計算している。 ここでもこの1行の実行にはかなりの演算（速度ベクトル場\nのx,y,z3成分の2乗和に質量密度を掛けたもの体積積分）が\nされていることに注意。 上と同様。こちらのほうは単なる密度場の体積積分なので\n演算量は少ないが、シミュレーション領域全体に渡る体積積分\nなので計算量は大きいことにかわりない。 Arguments Type Intent Optional Attributes Name integer, intent(in) :: nloop ループカウンタ real(kind=DR), intent(in) :: time シミュレーション時刻 type( fluid_t ), intent(in) :: fluid 流体データ generic, public,  :: get_subfield => subfield_vel , subfield_vel_tm , subfield_vel_tm_divv 流体の基本変数（質量フラックス、質量密度、圧力）\nから二次的な量（流れ場、温度場、速度の発散）\nを計算するためのルーチン群の多重定義 private  subroutine subfield_vel (fluid, vel) fluidの基本変数から二次的な場vel（流れの速度ベクトル場）\nをもとめる。\n割り算演算子はfield_mで定義している。 Arguments Type Intent Optional Attributes Name type( fluid_t ), intent(in) :: fluid 流体基本場 type( field__vector_t ), intent(out) :: vel 流れの速度ベクトル private  subroutine subfield_vel_tm (fluid, vel, tm) fluidの基本変数から二次的な場（速度ベクトル場velと温度場tm）\nをもとめる。\nfluid構造体の割り算演算子はfluid_mで定義している。 Arguments Type Intent Optional Attributes Name type( fluid_t ), intent(in) :: fluid 流体基本場 type( field__vector_t ), intent(out) :: vel 流れ場 real(kind=DR), intent(out), dimension(0:NXPP1,0:NYPP1,0:NZPP1) :: tm 温度場 private  subroutine subfield_vel_tm_divv (fluid, vel, tm, divv) fluidの基本変数から二次的な場（速度ベクトル場velと\n温度場tmと速度の発散divv）をもとめる。 Arguments Type Intent Optional Attributes Name type( fluid_t ), intent(in) :: fluid 流体基本場 type( field__vector_t ), intent(out) :: vel 流れ場 real(kind=DR), intent(out), dimension(0:NXPP1,0:NYPP1,0:NZPP1) :: tm 温度場 real(kind=DR), intent(out), dimension(0:NXPP1,0:NYPP1,0:NZPP1) :: divv 流れの発散 procedure, public, nopass :: initialize => solver__initialize private  subroutine solver__initialize (fluid) モジュールの初期化\n空気の粘性率\n空気の熱拡散率\nViscosityと違ってkappaの頭文字が大文字になっていない、つまり\nこのモジュールのグローバルスコープを持つ変数としていない\nのはナビエ・ストークス方程式には下で定義するGamma1_kappa\nという量のみを通じてkappaが出てくるからである。 gammaは比熱比、つまり定積比熱と定圧比熱の比である。\n統計力学で習うように、この値は流体（気体）を構成する\n分子の構造（自由度）で決まる。 流体の初期条件の設定\n1013 hPa (一気圧)\nkg/m&#94;3 (空気の密度)\nベクトル3成分。（静止状態） 渦輪を駆動するための力の場の設定\nモジュール初期化終了フラグ Arguments Type Intent Optional Attributes Name type( fluid_t ), intent(out) :: fluid 流体データ procedure, public, nopass :: set_time_step => solver__set_time_step private  function solver__set_time_step (nloop, fluid) CFL条件に基づいて時間刻み幅dtを設定する\n初期化忘れ確認 基本流体データから速度場と温度場を計算 速度の最大値（ベクトルの長さの最大値）をもとめる\nここでは配列演算を駆使して1行で書いているが\n実際にはかなりの演算をしていることに注意。\nこれはバグではないが、maxvalとsqrtは交換すべき\nだろう。このままだと3次元配列の全要素にsqrt\nを掛けてからそのmaxvalをとっているが、これを\n逆にした方が速いかもしれない。 初期条件では速度場がゼロなのでvmax=0となるが、あとで\nvmaxの割り算が出てくるので問題となる。それを回避するため\nALMOST_ZEROが十分小さければよい。 音速の最大値\nこれも上と同じ理屈で、maxvalとsqrtは交換すべき\nだろう。このままだと3次元配列の全要素にsqrt\nを掛けてからそのmaxvalをとっているが、これを\n逆にした方が速いかもしれない。 音速（の最大値）がほとんどゼロになるのは\n何かがおかしいのですぐに停止 以下では、流れの速さ、音波、粘性拡散、熱拡散の4種類の\nCFL条件で決まる時間刻み幅をそれぞれこの順番に求めている。\nCFL factor はここでは0.8と0.2にしているが、\nこれは精密な議論に基づいて決めたものではなく、\n半経験的に決めた値である。\n最後の2つ、粘性拡散と熱拡散によるCFL条件のための\nCFL factor の値 (0.2) というのは少々安全側に設定\nしすぎているかもしれない。つまりもう少し大きくしても\n問題ないかもしれない。 最終的な時間刻み幅は上記の4種類のdtの最小値できまる。 すべてのプロセスでの最小値をとる 出力が長くなるが、流体の状態を推測するのに便利なデータ。\nSKIPをさらに10倍しているのは、それほど頻繁に出力する\n必要は通常ないからである。\nSKIPに一度dtを計算し直すが、それ以外は下の行を見れば分かる通り\n前回のdtの値を流用する。その際、一度もdtを計算したことがなかったら\nまずいのでその検出をANOMALOUS_VALUEを使って検出している。 dt of the prev calc is saved.\n新たに更新（または前回計算した）dtを返す。 Arguments Type Intent Optional Attributes Name integer, intent(in) :: nloop ループカウンタ type( fluid_t ), intent(in) :: fluid 流体データ Return Value real(kind=DR) 時間刻み幅 dt procedure, private, nopass :: subfield_vel private  subroutine subfield_vel (fluid, vel) fluidの基本変数から二次的な場vel（流れの速度ベクトル場）\nをもとめる。\n割り算演算子はfield_mで定義している。 Arguments Type Intent Optional Attributes Name type( fluid_t ), intent(in) :: fluid 流体基本場 type( field__vector_t ), intent(out) :: vel 流れの速度ベクトル procedure, private, nopass :: subfield_vel_tm private  subroutine subfield_vel_tm (fluid, vel, tm) fluidの基本変数から二次的な場（速度ベクトル場velと温度場tm）\nをもとめる。\nfluid構造体の割り算演算子はfluid_mで定義している。 Arguments Type Intent Optional Attributes Name type( fluid_t ), intent(in) :: fluid 流体基本場 type( field__vector_t ), intent(out) :: vel 流れ場 real(kind=DR), intent(out), dimension(0:NXPP1,0:NYPP1,0:NZPP1) :: tm 温度場 procedure, private, nopass :: subfield_vel_tm_divv private  subroutine subfield_vel_tm_divv (fluid, vel, tm, divv) fluidの基本変数から二次的な場（速度ベクトル場velと\n温度場tmと速度の発散divv）をもとめる。 Arguments Type Intent Optional Attributes Name type( fluid_t ), intent(in) :: fluid 流体基本場 type( field__vector_t ), intent(out) :: vel 流れ場 real(kind=DR), intent(out), dimension(0:NXPP1,0:NYPP1,0:NZPP1) :: tm 温度場 real(kind=DR), intent(out), dimension(0:NXPP1,0:NYPP1,0:NZPP1) :: divv 流れの発散 Source Code type , private :: solver_t contains procedure , nopass :: advance => solver__advance procedure , nopass :: diagnosis => solver__diagnosis procedure , nopass :: initialize => solver__initialize procedure , nopass :: set_time_step => solver__set_time_step procedure , nopass , private :: subfield_vel procedure , nopass , private :: subfield_vel_tm procedure , nopass , private :: subfield_vel_tm_divv generic :: get_subfield => subfield_vel , & subfield_vel_tm , & subfield_vel_tm_divv !! 流体の基本変数（質量フラックス、質量密度、圧力） !! から二次的な量（流れ場、温度場、速度の発散） !! を計算するためのルーチン群の多重定義 end type solver_t","tags":"","loc":"type/solver_t.html"},{"title":"field__vector_t – Smoke Ring ","text":"type, public :: field__vector_t 3次元ベクトル場構造体\nここではコンパイル時に配列のサイズが\n既に決まっているとしているが、そうでない\n場合、つまり実行時に配列サイズを確定\nしたい場合にはallocatableな配列を使えば良い。 コード全体にサイズ（行数）がそれほど\n多くない今のような場合は、配列サイズ\n（=シミュレーションの格子点数）を\n変更する度にコンパイルしてもたいした\n時間はかからないのでこのように\n決め打ちにしても問題ない。 Inherited by type~~field__vector_t~~InheritedByGraph type~field__vector_t field__vector_t type~fluid_t fluid_t type~fluid_t->type~field__vector_t flux type~vissubfield3d_t vissubfield3d_t type~vissubfield3d_t->type~field__vector_t velocity, vorticity Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Variables x y z Source Code field__vector_t Components Type Visibility Attributes Name Initial real(kind=DR), public, dimension(0:NXPP1,0:NYPP1,0:NZPP1) :: x x成分 real(kind=DR), public, dimension(0:NXPP1,0:NYPP1,0:NZPP1) :: y y成分 real(kind=DR), public, dimension(0:NXPP1,0:NYPP1,0:NZPP1) :: z z成分 Source Code type , public :: field__vector_t !! 3次元ベクトル場構造体 !! ここではコンパイル時に配列のサイズが !! 既に決まっているとしているが、そうでない !! 場合、つまり実行時に配列サイズを確定 !! したい場合にはallocatableな配列を使えば良い。 !! !! コード全体にサイズ（行数）がそれほど !! 多くない今のような場合は、配列サイズ !! （=シミュレーションの格子点数）を !! 変更する度にコンパイルしてもたいした !! 時間はかからないのでこのように !! 決め打ちにしても問題ない。 real ( DR ), dimension ( 0 : NXPP1 , 0 : NYPP1 , 0 : NZPP1 ) :: x !! x成分 ! 倍精度浮動小数点数（double real, DR）の ! 3次元配列、という意味。念の為。 real ( DR ), dimension ( 0 : NXPP1 , 0 : NYPP1 , 0 : NZPP1 ) :: y !! y成分 real ( DR ), dimension ( 0 : NXPP1 , 0 : NYPP1 , 0 : NZPP1 ) :: z !! z成分 end type field__vector_t","tags":"","loc":"type/field__vector_t.html"},{"title":"grid__delta_t – Smoke Ring ","text":"type, private :: grid__delta_t 格子間隔構造体 Inherited by type~~grid__delta_t~~InheritedByGraph type~grid__delta_t grid__delta_t type~grid_t grid_t type~grid_t->type~grid__delta_t delta Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Variables x y z Source Code grid__delta_t Components Type Visibility Attributes Name Initial real(kind=DR), public :: x x方向の格子間隔 real(kind=DR), public :: y y方向の格子間隔 real(kind=DR), public :: z z方向の格子間隔 Source Code type grid__delta_t !! 格子間隔構造体 real ( DR ) :: x !! x方向の格子間隔 real ( DR ) :: y !! y方向の格子間隔 real ( DR ) :: z !! z方向の格子間隔 end type grid__delta_t","tags":"","loc":"type/grid__delta_t.html"},{"title":"grid__derivative_operator_1st_t – Smoke Ring ","text":"type, private :: grid__derivative_operator_1st_t 1階微分（差分）をとる時の演算子（定数）\n演算回数の節約のため Inherited by type~~grid__derivative_operator_1st_t~~InheritedByGraph type~grid__derivative_operator_1st_t grid__derivative_operator_1st_t type~grid_t grid_t type~grid_t->type~grid__derivative_operator_1st_t d1 Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Variables x y z Source Code grid__derivative_operator_1st_t Components Type Visibility Attributes Name Initial real(kind=DR), public :: x x偏微分 real(kind=DR), public :: y y偏微分 real(kind=DR), public :: z z偏微分 Source Code type grid__derivative_operator_1st_t !! 1階微分（差分）をとる時の演算子（定数） !! 演算回数の節約のため real ( DR ) :: x !! x偏微分 real ( DR ) :: y !! y偏微分 real ( DR ) :: z !! z偏微分 end type grid__derivative_operator_1st_t","tags":"","loc":"type/grid__derivative_operator_1st_t.html"},{"title":"grid__derivative_operator_2nd_t – Smoke Ring ","text":"type, private :: grid__derivative_operator_2nd_t 2階微分（差分）をとる時の演算子（定数）\n演算回数の節約のため Inherited by type~~grid__derivative_operator_2nd_t~~InheritedByGraph type~grid__derivative_operator_2nd_t grid__derivative_operator_2nd_t type~grid_t grid_t type~grid_t->type~grid__derivative_operator_2nd_t d2 Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Variables x y z Source Code grid__derivative_operator_2nd_t Components Type Visibility Attributes Name Initial real(kind=DR), public :: x x偏微分 real(kind=DR), public :: y y偏微分 real(kind=DR), public :: z z偏微分 Source Code type grid__derivative_operator_2nd_t !! 2階微分（差分）をとる時の演算子（定数） !! 演算回数の節約のため real ( DR ) :: x !! x偏微分 real ( DR ) :: y !! y偏微分 real ( DR ) :: z !! z偏微分 end type grid__derivative_operator_2nd_t","tags":"","loc":"type/grid__derivative_operator_2nd_t.html"},{"title":"grid__pos_t – Smoke Ring ","text":"type, private :: grid__pos_t 格子点位置を収める構造体\nposはpositionの意味 Inherited by type~~grid__pos_t~~InheritedByGraph type~grid__pos_t grid__pos_t type~grid_t grid_t type~grid_t->type~grid__pos_t pos Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Variables x y z Source Code grid__pos_t Components Type Visibility Attributes Name Initial real(kind=DR), public, dimension(0:NXPP1) :: x x座標（MPI領域分割した real(kind=DR), public, dimension(0:NYPP1) :: y y座標  各プロセスでの real(kind=DR), public, dimension(0:NZPP1) :: z z座標  局所的な番号） Source Code type grid__pos_t !! 格子点位置を収める構造体 !! posはpositionの意味 real ( DR ), dimension ( 0 : NXPP1 ) :: x !! x座標（MPI領域分割した real ( DR ), dimension ( 0 : NYPP1 ) :: y !! y座標  各プロセスでの real ( DR ), dimension ( 0 : NZPP1 ) :: z !! z座標  局所的な番号） end type grid__pos_t","tags":"","loc":"type/grid__pos_t.html"},{"title":"grid_global_ijk_t – Smoke Ring ","text":"type, private :: grid_global_ijk_t global (gi,gj,gk) from local (li,lj,lk) Inherited by type~~grid_global_ijk_t~~InheritedByGraph type~grid_global_ijk_t grid_global_ijk_t type~grid_t grid_t type~grid_t->type~grid_global_ijk_t global_ijk Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Variables gi gj gk Source Code grid_global_ijk_t Components Type Visibility Attributes Name Initial integer, public, dimension(0:NXPP1) :: gi MPIで領域分割した各プロセス integer, public, dimension(0:NYPP1) :: gj の局所的な格子点位置から integer, public, dimension(0:NZPP1) :: gk シミュ領域全体の格子点位置をとる Source Code type grid_global_ijk_t !! global (gi,gj,gk) from local (li,lj,lk) integer , dimension ( 0 : NXPP1 ) :: gi !! MPIで領域分割した各プロセス integer , dimension ( 0 : NYPP1 ) :: gj !! の局所的な格子点位置から integer , dimension ( 0 : NZPP1 ) :: gk !! シミュ領域全体の格子点位置をとる end type grid_global_ijk_t","tags":"","loc":"type/grid_global_ijk_t.html"},{"title":"grid_local_ijk_from_global_ijk_t – Smoke Ring ","text":"type, private :: grid_local_ijk_from_global_ijk_t The opposite of above. Inherited by type~~grid_local_ijk_from_global_ijk_t~~InheritedByGraph type~grid_local_ijk_from_global_ijk_t grid_local_ijk_from_global_ijk_t type~grid_t grid_t type~grid_t->type~grid_local_ijk_from_global_ijk_t local_ijk_from_global_ijk Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Variables li lj lk Source Code grid_local_ijk_from_global_ijk_t Components Type Visibility Attributes Name Initial integer, public, dimension(NX_GLOBAL) :: li グローバルな格子点位置 integer, public, dimension(NY_GLOBAL) :: lj から局所的な格子点位置を integer, public, dimension(NZ_GLOBAL) :: lk 求める Source Code type grid_local_ijk_from_global_ijk_t !! The opposite of above. integer , dimension ( NX_GLOBAL ) :: li !! グローバルな格子点位置 integer , dimension ( NY_GLOBAL ) :: lj !! から局所的な格子点位置を integer , dimension ( NZ_GLOBAL ) :: lk !! 求める end type grid_local_ijk_from_global_ijk_t","tags":"","loc":"type/grid_local_ijk_from_global_ijk_t.html"},{"title":"grid_pos_by_global_ijk_t – Smoke Ring ","text":"type, private :: grid_pos_by_global_ijk_t Inherited by type~~grid_pos_by_global_ijk_t~~InheritedByGraph type~grid_pos_by_global_ijk_t grid_pos_by_global_ijk_t type~grid_t grid_t type~grid_t->type~grid_pos_by_global_ijk_t pos_by_global_ijk Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Variables x y z Source Code grid_pos_by_global_ijk_t Components Type Visibility Attributes Name Initial real(kind=DR), public, dimension(NX_GLOBAL) :: x シミュ領域全体にわたる real(kind=DR), public, dimension(NY_GLOBAL) :: y 格子点番号 global な real(kind=DR), public, dimension(NZ_GLOBAL) :: z 番号という意味でgi等とよぶ Source Code type grid_pos_by_global_ijk_t real ( DR ), dimension ( NX_GLOBAL ) :: x !! シミュ領域全体にわたる real ( DR ), dimension ( NY_GLOBAL ) :: y !! 格子点番号 global な real ( DR ), dimension ( NZ_GLOBAL ) :: z !! 番号という意味でgi等とよぶ end type grid_pos_by_global_ijk_t","tags":"","loc":"type/grid_pos_by_global_ijk_t.html"},{"title":"grid_t – Smoke Ring ","text":"type, private :: grid_t 格子点関係のデータを全て収める構造体\nこのモジュールの中心変数。これを介して外部と\nやり取りする。このグリッド変数の定義 (下記のgrid_t）\nと実体（このgrid）が同じ場所（このgrid_mモジュール内）\nにあるのは少々変則的かもしれないが、このように規模の\n小さいシミュレーションプログラムではこの方が\nむしろわかりやすいかもしれない。 Inherits type~~grid_t~~InheritsGraph type~grid_t grid_t type~grid__delta_t grid__delta_t type~grid_t->type~grid__delta_t delta type~grid__derivative_operator_1st_t grid__derivative_operator_1st_t type~grid_t->type~grid__derivative_operator_1st_t d1 type~grid__derivative_operator_2nd_t grid__derivative_operator_2nd_t type~grid_t->type~grid__derivative_operator_2nd_t d2 type~grid__pos_t grid__pos_t type~grid_t->type~grid__pos_t pos type~grid_global_ijk_t grid_global_ijk_t type~grid_t->type~grid_global_ijk_t global_ijk type~grid_local_ijk_from_global_ijk_t grid_local_ijk_from_global_ijk_t type~grid_t->type~grid_local_ijk_from_global_ijk_t local_ijk_from_global_ijk type~grid_pos_by_global_ijk_t grid_pos_by_global_ijk_t type~grid_t->type~grid_pos_by_global_ijk_t pos_by_global_ijk Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Variables d1 d2 delta delta_min global_ijk local_ijk_from_global_ijk pos pos_by_global_ijk Type-Bound Procedures i_have_gi i_have_gijk i_have_gj i_have_gk initialize Source Code grid_t Components Type Visibility Attributes Name Initial type( grid__derivative_operator_1st_t ), public :: d1 1階微分演算子定数 type( grid__derivative_operator_2nd_t ), public :: d2 2階微分演算子定数 type( grid__delta_t ), public :: delta 格子間隔 real(kind=DR), public :: delta_min 最小の格子間隔 type( grid_global_ijk_t ), public :: global_ijk type( grid_local_ijk_from_global_ijk_t ), public :: local_ijk_from_global_ijk type( grid__pos_t ), public :: pos 格子点位置 type( grid_pos_by_global_ijk_t ), public :: pos_by_global_ijk Type-Bound Procedures procedure, public,  :: i_have_gi => grid__i_have_gi global格子点giの位置をそのプロセスが含むかどうか。 private  function grid__i_have_gi (grid, gi) result(ans) Arguments Type Intent Optional Attributes Name class( grid_t ), intent(in) :: grid integer, intent(in) :: gi Return Value logical procedure, public,  :: i_have_gijk => grid__i_have_gijk global格子点(gi,gj,gk)をそのプロセスが持っている\nかどうか。 private  function grid__i_have_gijk (grid, gi, gj, gk) result(ans) Arguments Type Intent Optional Attributes Name class( grid_t ), intent(in) :: grid integer, intent(in) :: gi integer, intent(in) :: gj integer, intent(in) :: gk Return Value logical procedure, public,  :: i_have_gj => grid__i_have_gj global格子点gjの位置を private  function grid__i_have_gj (grid, gj) result(ans) Arguments Type Intent Optional Attributes Name class( grid_t ), intent(in) :: grid integer, intent(in) :: gj Return Value logical procedure, public,  :: i_have_gk => grid__i_have_gk global格子点gkの位置を private  function grid__i_have_gk (grid, gk) result(ans) Arguments Type Intent Optional Attributes Name class( grid_t ), intent(in) :: grid integer, intent(in) :: gk Return Value logical procedure, public,  :: initialize => grid__initialize 初期化関数\n初期化のためのメンバー関数\nこうするとgrid%initializeという形でcallできる private  subroutine grid__initialize (grid) gridの初期化 ここでは周期境界条件を仮定している。 構造体のメンバー関数としてcallするときその\n構造体変数そのものがgridとして自動的に引数にはいる。\nたとえば、\n    call sampl_grid%initialize\nは\n    call grid__initialize(sample_grid)\nと解釈される。gridという名前でなくても構わない。 Arguments Type Intent Optional Attributes Name class( grid_t ), intent(out) :: grid 格子構造体 Source Code type :: grid_t !! 格子点関係のデータを全て収める構造体 !! このモジュールの中心変数。これを介して外部と !! やり取りする。このグリッド変数の定義 (下記のgrid_t） !! と実体（このgrid）が同じ場所（このgrid_mモジュール内） !! にあるのは少々変則的かもしれないが、このように規模の !! 小さいシミュレーションプログラムではこの方が !! むしろわかりやすいかもしれない。 type ( grid__pos_t ) :: pos !! 格子点位置 type ( grid_pos_by_global_ijk_t ) :: pos_by_global_ijk type ( grid_global_ijk_t ) :: global_ijk type ( grid_local_ijk_from_global_ijk_t ) :: local_ijk_from_global_ijk type ( grid__delta_t ) :: delta !! 格子間隔 real ( DR ) :: delta_min !! 最小の格子間隔 type ( grid__derivative_operator_1st_t ) :: d1 !! 1階微分演算子定数 type ( grid__derivative_operator_2nd_t ) :: d2 !! 2階微分演算子定数 contains procedure :: initialize => grid__initialize !! 初期化関数 !! 初期化のためのメンバー関数 !! こうするとgrid%initializeという形でcallできる procedure :: i_have_gi => grid__i_have_gi !! global格子点giの位置をそのプロセスが含むかどうか。 procedure :: i_have_gj => grid__i_have_gj !! global格子点gjの位置を procedure :: i_have_gk => grid__i_have_gk !! global格子点gkの位置を procedure :: i_have_gijk => grid__i_have_gijk !! global格子点(gi,gj,gk)をそのプロセスが持っている !! かどうか。 end type grid_t","tags":"","loc":"type/grid_t.html"},{"title":"min_max_string – Smoke Ring","text":"private  function min_max_string(vmin, vmax) result(string) Arguments Type Intent Optional Attributes Name real, intent(in) :: vmin real, intent(in) :: vmax Return Value character(len=TAG_NAME_MAX) Calls proc~~min_max_string~~CallsGraph proc~min_max_string vis2d_m::min_max_string ut__real_to_str10 ut__real_to_str10 proc~min_max_string->ut__real_to_str10 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~min_max_string~~CalledByGraph proc~min_max_string vis2d_m::min_max_string proc~draw_contour vis2d_m::draw_contour proc~draw_contour->proc~min_max_string proc~draw_contour_and_arrows vis2d_m::draw_contour_and_arrows proc~draw_contour_and_arrows->proc~min_max_string proc~vis2d_plane_xy__draw vis2d_m::vis2d_plane_xy_t%vis2d_plane_xy__draw proc~vis2d_plane_xy__draw->proc~draw_contour_and_arrows proc~vis2d_plane_xz__draw vis2d_m::vis2d_plane_xz_t%vis2d_plane_xz__draw proc~vis2d_plane_xz__draw->proc~draw_contour proc~vis2d_plane_xz__draw->proc~draw_contour_and_arrows Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Source Code min_max_string Source Code function min_max_string ( vmin , vmax ) result ( string ) real , intent ( in ) :: vmin , vmax character ( len = TAG_NAME_MAX ) :: string character ( len = 10 ) :: str10_vmax , str10_vmin str10_vmin = ut__real_to_str10 ( vmin ) str10_vmax = ut__real_to_str10 ( vmax ) string = 'vmin = ' // str10_vmin // ' vmax = ' // str10_vmax end function min_max_string","tags":"","loc":"proc/min_max_string.html"},{"title":"vec_amp_max_string – Smoke Ring","text":"private  function vec_amp_max_string(vmax) result(string) Arguments Type Intent Optional Attributes Name real, intent(in) :: vmax Return Value character(len=TAG_NAME_MAX) Calls proc~~vec_amp_max_string~~CallsGraph proc~vec_amp_max_string vis2d_m::vec_amp_max_string ut__real_to_str10 ut__real_to_str10 proc~vec_amp_max_string->ut__real_to_str10 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~vec_amp_max_string~~CalledByGraph proc~vec_amp_max_string vis2d_m::vec_amp_max_string proc~draw_arrows vis2d_m::draw_arrows proc~draw_arrows->proc~vec_amp_max_string proc~draw_contour_and_arrows vis2d_m::draw_contour_and_arrows proc~draw_contour_and_arrows->proc~vec_amp_max_string proc~vis2d_plane_xy__draw vis2d_m::vis2d_plane_xy_t%vis2d_plane_xy__draw proc~vis2d_plane_xy__draw->proc~draw_contour_and_arrows proc~vis2d_plane_xz__draw vis2d_m::vis2d_plane_xz_t%vis2d_plane_xz__draw proc~vis2d_plane_xz__draw->proc~draw_contour_and_arrows Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Source Code vec_amp_max_string Source Code function vec_amp_max_string ( vmax ) result ( string ) real , intent ( in ) :: vmax character ( len = TAG_NAME_MAX ) :: string character ( len = 10 ) :: str10_vmax str10_vmax = ut__real_to_str10 ( vmax ) string = 'vmax = ' // str10_vmax end function vec_amp_max_string","tags":"","loc":"proc/vec_amp_max_string.html"},{"title":"draw_arrows – Smoke Ring","text":"private  subroutine draw_arrows(ll, ur, filename, vector) Arguments Type Intent Optional Attributes Name type(vv_sketch__sim_pos_t), intent(in) :: ll type(vv_sketch__sim_pos_t), intent(in) :: ur character(len=*), intent(in) :: filename type(vv_slice_vector_t), intent(inout) :: vector Calls proc~~draw_arrows~~CallsGraph proc~draw_arrows vis2d_m::draw_arrows comp_u comp_u proc~draw_arrows->comp_u comp_v comp_v proc~draw_arrows->comp_v finalize finalize proc~draw_arrows->finalize group_pop group_pop proc~draw_arrows->group_pop group_push group_push proc~draw_arrows->group_push initialize initialize proc~draw_arrows->initialize proc~vec_amp_max_string vis2d_m::vec_amp_max_string proc~draw_arrows->proc~vec_amp_max_string vis_arrows vis_arrows proc~draw_arrows->vis_arrows ut__real_to_str10 ut__real_to_str10 proc~vec_amp_max_string->ut__real_to_str10 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Source Code draw_arrows Source Code subroutine draw_arrows ( ll , ur , filename , vector ) type ( vv_sketch__sim_pos_t ), intent ( in ) :: ll , & ! lower left ur ! upper right character ( len =* ), intent ( in ) :: filename type ( vv_slice_vector_t ), intent ( inout ) :: vector real :: vec_amp_max type ( vv_sketch_t ) :: vv_sketch type ( vv_color_t ) :: color_black type ( vv_color_t ) :: color_limegreen , color_darkgreen character ( len = TAG_NAME_MAX ) :: message real , parameter :: ALMOST_ZERO = 1.e-20_SR color_black = VV_COLOR__CONST % black color_limegreen = VV_COLOR__CONST % limegreen color_darkgreen = VV_COLOR__CONST % darkgreen call vv_sketch % initialize ( ll , ur , & screen_width_in_pixel = 100 0.0 , & title = vector % tag , & filename = trim ( filename ), & unit_arrow_in_pixel = 2 0.0 , & write_arrow_template = . true . ) ! --<boundary curve>-- call vector % mesh % draw ( vv_sketch , & line_color = VV_COLOR__CONST % black , & width_in_pixels = 1.0 ) vec_amp_max = sqrt ( maxval ( vector % comp_u (:,:) ** 2 & + vector % comp_v (:,:) ** 2 )) message = vec_amp_max_string ( vec_amp_max ) call iText_in_header_and_footer ( message ) if ( vec_amp_max <= ALMOST_ZERO ) then call vv_sketch % finalize return end if call vv_sketch % group_push ( line_color = color_limegreen , & fill_color = color_darkgreen , & line_width_in_pixel = 1.0 ) vector % comp_u (:,:) = vector % comp_u (:,:) / vec_amp_max vector % comp_v (:,:) = vector % comp_v (:,:) / vec_amp_max call vector % vis_arrows ( vv_sketch , arrow_template = \"#arrow02\" ) call vv_sketch % group_pop call vv_sketch % finalize contains subroutine iText_in_header_and_footer ( message ) character ( len = TAG_NAME_MAX ), intent ( in ) :: message real :: text_v_pos_in_physical_unit real :: tsep ! text v position separation betwen lines call vv_sketch % group_push ( line_color = color_black , & line_width_in_pixel = 1.0 ) tsep = ( ur % v - ll % v ) * 0.1 ! --<figure title in the header>-- text_v_pos_in_physical_unit = ur % v + tsep call vv_sketch % text ( ( ll % u + ur % u ) / 2 , & text_v_pos_in_physical_unit , & vv_sketch % title , & font_size_in_pixel = 3 0.0 , & text_anchor = 'middle' ) ! --<simple text in the footer>-- text_v_pos_in_physical_unit = ll % v - tsep call vv_sketch % text ( ll % u , & text_v_pos_in_physical_unit , & trim ( filename ), & font_size_in_pixel = 1 5.0 , & text_anchor = 'start' ) text_v_pos_in_physical_unit = text_v_pos_in_physical_unit - tsep call vv_sketch % text ( ll % u , & text_v_pos_in_physical_unit , & message , & font_size_in_pixel = 1 5.0 , & text_anchor = 'start' ) call vv_sketch % group_pop end subroutine iText_in_header_and_footer end subroutine draw_arrows","tags":"","loc":"proc/draw_arrows.html"},{"title":"draw_contour – Smoke Ring","text":"private  subroutine draw_contour(ll, ur, filename, scalar) default Arguments Type Intent Optional Attributes Name type(vv_sketch__sim_pos_t), intent(in) :: ll type(vv_sketch__sim_pos_t), intent(in) :: ur character(len=*), intent(in) :: filename type(vv_slice_scalar_t), intent(inout) :: scalar Calls proc~~draw_contour~~CallsGraph proc~draw_contour vis2d_m::draw_contour finalize finalize proc~draw_contour->finalize group_pop group_pop proc~draw_contour->group_pop group_push group_push proc~draw_contour->group_push initialize initialize proc~draw_contour->initialize proc~min_max_string vis2d_m::min_max_string proc~draw_contour->proc~min_max_string vis_contour vis_contour proc~draw_contour->vis_contour vv_color__normalized_real_to_color vv_color__normalized_real_to_color proc~draw_contour->vv_color__normalized_real_to_color ut__real_to_str10 ut__real_to_str10 proc~min_max_string->ut__real_to_str10 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~draw_contour~~CalledByGraph proc~draw_contour vis2d_m::draw_contour proc~vis2d_plane_xz__draw vis2d_m::vis2d_plane_xz_t%vis2d_plane_xz__draw proc~vis2d_plane_xz__draw->proc~draw_contour Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Source Code draw_contour Source Code subroutine draw_contour ( ll , ur , filename , scalar ) type ( vv_sketch__sim_pos_t ), intent ( in ) :: ll , & ! lower left ur ! upper right character ( len =* ), intent ( in ) :: filename type ( vv_slice_scalar_t ), intent ( inout ) :: scalar type ( vv_sketch_t ) :: vv_sketch real :: level_min , level_max , dlevel , level , level_nrm real :: level_range type ( vv_color_t ) :: color , color_black integer :: l character ( len = TAG_NAME_MAX ) :: message real , parameter :: ALMOST_ZERO = 1.e-20_SR real , parameter :: TOO_SMALL_DIFF_FOR_CONTOUR = 1.e-3_SR real :: max_min_diff_normalized real :: level_amplitude logical :: flag_skip_contour color_black = VV_COLOR__CONST % black flag_skip_contour = . false . !! default call vv_sketch % initialize ( ll , ur , & screen_width_in_pixel = 100 0.0 , & title = scalar % tag , & filename = trim ( filename ) ) ! --<boundary curve>-- call scalar % mesh % draw ( vv_sketch , & line_color = VV_COLOR__CONST % black , & width_in_pixels = 1.0 ) level_min = minval ( scalar % val_vert ) level_max = maxval ( scalar % val_vert ) message = min_max_string ( level_min , level_max ) call iText_in_header_and_footer ( message ) level_amplitude = max ( abs ( level_max ), abs ( level_min )) if ( level_amplitude <= ALMOST_ZERO ) then call vv_sketch % finalize return end if level_range = level_max - level_min max_min_diff_normalized = level_range / level_amplitude if ( max_min_diff_normalized <= TOO_SMALL_DIFF_FOR_CONTOUR ) then call vv_sketch % finalize return end if call vv_sketch % group_push ( line_color = VV_COLOR__CONST % magenta , & line_width_in_pixel = 1.0 ) dlevel = level_range / 10 do l = 1 , 10 level = level_min + dlevel * ( real ( l ) - 0.5 ) level_nrm = ( level - level_min ) / level_range color = vv_color__normalized_real_to_color ( level_nrm ) call scalar % vis_contour ( vv_sketch , & level , & line_color = color_black , & fill_color = color ) ! debug_print=.true. ) ! for debug. end do call vv_sketch % group_pop call vv_sketch % finalize contains subroutine iText_in_header_and_footer ( message ) character ( len = TAG_NAME_MAX ), intent ( in ) :: message real :: text_v_pos_in_physical_unit real :: tsep ! text v position separation betwen lines call vv_sketch % group_push ( line_color = color_black , & line_width_in_pixel = 1.0 ) tsep = ( ur % v - ll % v ) * 0.1 ! --<figure title in the header>-- text_v_pos_in_physical_unit = ur % v + tsep call vv_sketch % text ( ( ll % u + ur % u ) / 2 , & text_v_pos_in_physical_unit , & vv_sketch % title , & font_size_in_pixel = 3 0.0 , & text_anchor = 'middle' ) ! --<simple text in the footer>-- text_v_pos_in_physical_unit = ll % v - tsep call vv_sketch % text ( ll % u , & text_v_pos_in_physical_unit , & trim ( filename ), & font_size_in_pixel = 1 5.0 , & text_anchor = 'start' ) text_v_pos_in_physical_unit = text_v_pos_in_physical_unit - tsep call vv_sketch % text ( ll % u , & text_v_pos_in_physical_unit , & message , & font_size_in_pixel = 1 5.0 , & text_anchor = 'start' ) call vv_sketch % group_pop end subroutine iText_in_header_and_footer end subroutine draw_contour","tags":"","loc":"proc/draw_contour.html"},{"title":"draw_contour_and_arrows – Smoke Ring","text":"private  subroutine draw_contour_and_arrows(ll, ur, filename, scalar, vector) < < Arguments Type Intent Optional Attributes Name type(vv_sketch__sim_pos_t), intent(in) :: ll type(vv_sketch__sim_pos_t), intent(in) :: ur character(len=*), intent(in) :: filename type(vv_slice_scalar_t), intent(inout) :: scalar type(vv_slice_vector_t), intent(inout) :: vector Calls proc~~draw_contour_and_arrows~~CallsGraph proc~draw_contour_and_arrows vis2d_m::draw_contour_and_arrows comp_u comp_u proc~draw_contour_and_arrows->comp_u comp_v comp_v proc~draw_contour_and_arrows->comp_v finalize finalize proc~draw_contour_and_arrows->finalize group_pop group_pop proc~draw_contour_and_arrows->group_pop group_push group_push proc~draw_contour_and_arrows->group_push initialize initialize proc~draw_contour_and_arrows->initialize proc~min_max_string vis2d_m::min_max_string proc~draw_contour_and_arrows->proc~min_max_string proc~vec_amp_max_string vis2d_m::vec_amp_max_string proc~draw_contour_and_arrows->proc~vec_amp_max_string vis_arrows vis_arrows proc~draw_contour_and_arrows->vis_arrows vis_contour vis_contour proc~draw_contour_and_arrows->vis_contour vv_color__normalized_real_to_color vv_color__normalized_real_to_color proc~draw_contour_and_arrows->vv_color__normalized_real_to_color ut__real_to_str10 ut__real_to_str10 proc~min_max_string->ut__real_to_str10 proc~vec_amp_max_string->ut__real_to_str10 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~draw_contour_and_arrows~~CalledByGraph proc~draw_contour_and_arrows vis2d_m::draw_contour_and_arrows proc~vis2d_plane_xy__draw vis2d_m::vis2d_plane_xy_t%vis2d_plane_xy__draw proc~vis2d_plane_xy__draw->proc~draw_contour_and_arrows proc~vis2d_plane_xz__draw vis2d_m::vis2d_plane_xz_t%vis2d_plane_xz__draw proc~vis2d_plane_xz__draw->proc~draw_contour_and_arrows Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Source Code draw_contour_and_arrows Source Code subroutine draw_contour_and_arrows ( ll , ur , filename , scalar , vector ) type ( vv_sketch__sim_pos_t ), intent ( in ) :: ll , & ! lower left ur ! upper right character ( len =* ), intent ( in ) :: filename type ( vv_slice_scalar_t ), intent ( inout ) :: scalar type ( vv_slice_vector_t ), intent ( inout ) :: vector real :: vec_amp_max type ( vv_sketch_t ) :: vv_sketch real :: level_min , level_max , dlevel , level , level_nrm real :: max_min_diff_normalized real :: level_range real :: level_amplitude type ( vv_color_t ) :: color , color_black type ( vv_color_t ) :: color_brown , color_sandybrown integer :: l character ( len = TAG_NAME_MAX ) :: message1 , message2 character ( len = TAG_NAME_MAX * 2 ) :: figure_title real , parameter :: ALMOST_ZERO = 1.e-20_SR real , parameter :: TOO_SMALL_DIFF_FOR_CONTOUR = 1.e-3_SR color_black = VV_COLOR__CONST % black color_brown = VV_COLOR__CONST % brown color_sandybrown = VV_COLOR__CONST % sandybrown figure_title = trim ( scalar % tag ) // ' (contour) and ' // & trim ( vector % tag ) // ' (arrows)' call vv_sketch % initialize ( ll , ur , & screen_width_in_pixel = 100 0.0 , & title = figure_title , & filename = trim ( filename ), & unit_arrow_in_pixel = 2 0.0 , & write_arrow_template = . true . ) ! --<boundary curve>-- call scalar % mesh % draw ( vv_sketch , & line_color = VV_COLOR__CONST % black , & width_in_pixels = 1.0 ) level_min = minval ( scalar % val_vert ) level_max = maxval ( scalar % val_vert ) message1 = min_max_string ( level_min , level_max ) vec_amp_max = sqrt ( maxval ( vector % comp_u (:,:) ** 2 & + vector % comp_v (:,:) ** 2 )) message2 = vec_amp_max_string ( vec_amp_max ) call iText_in_header_and_footer ( message1 , message2 ) !!> !        Contours !!< level_amplitude = max ( abs ( level_max ), abs ( level_min )) if ( level_amplitude > ALMOST_ZERO ) then call vv_sketch % group_push ( line_color = color_black , & line_width_in_pixel = 1.0 ) level_range = level_max - level_min max_min_diff_normalized = level_range / level_amplitude if ( max_min_diff_normalized >= TOO_SMALL_DIFF_FOR_CONTOUR ) then dlevel = level_range / 10 do l = 1 , 10 level = level_min + dlevel * ( real ( l ) - 0.5 ) level_nrm = ( level - level_min ) / level_range color = vv_color__normalized_real_to_color ( level_nrm ) call scalar % vis_contour ( vv_sketch , & level , & line_color = color_black , & fill_color = color ) end do end if call vv_sketch % group_pop end if !!> !        Arrows !!< if ( vec_amp_max > ALMOST_ZERO ) then call vv_sketch % group_push ( line_color = color_brown , & fill_color = color_sandybrown , & line_width_in_pixel = 1.0 ) vector % comp_u (:,:) = vector % comp_u (:,:) / vec_amp_max vector % comp_v (:,:) = vector % comp_v (:,:) / vec_amp_max call vector % vis_arrows ( vv_sketch , arrow_template = \"#arrow02\" ) call vv_sketch % group_pop end if call vv_sketch % finalize contains subroutine iText_in_header_and_footer ( message1 , message2 ) character ( len = TAG_NAME_MAX ), intent ( in ) :: message1 , message2 real :: text_v_pos_in_physical_unit real :: tsep ! text v position separation betwen lines call vv_sketch % group_push ( line_color = color_black , & line_width_in_pixel = 1.0 ) tsep = ( ur % v - ll % v ) * 0.1 ! --<figure title in the header>-- text_v_pos_in_physical_unit = ur % v + tsep call vv_sketch % text ( ( ll % u + ur % u ) / 2 , & text_v_pos_in_physical_unit , & vv_sketch % title , & font_size_in_pixel = 3 0.0 , & text_anchor = 'middle' ) ! --<simple text in the footer>-- text_v_pos_in_physical_unit = ll % v - tsep call vv_sketch % text ( ll % u , & text_v_pos_in_physical_unit , & trim ( filename ), & font_size_in_pixel = 1 5.0 , & text_anchor = 'start' ) text_v_pos_in_physical_unit = text_v_pos_in_physical_unit - tsep call vv_sketch % text ( ll % u , & text_v_pos_in_physical_unit , & 'Contour: ' // trim ( message1 ), & font_size_in_pixel = 1 5.0 , & text_anchor = 'start' ) text_v_pos_in_physical_unit = text_v_pos_in_physical_unit - tsep call vv_sketch % text ( ll % u , & text_v_pos_in_physical_unit , & 'Arrow: ' // trim ( message2 ), & font_size_in_pixel = 1 5.0 , & text_anchor = 'start' ) call vv_sketch % group_pop end subroutine iText_in_header_and_footer end subroutine draw_contour_and_arrows","tags":"","loc":"proc/draw_contour_and_arrows.html"},{"title":"make_filename – Smoke Ring","text":"private  subroutine make_filename(time_and_step_string, tag1, tag2, filename) Arguments Type Intent Optional Attributes Name character(len=TAG_NAME_MAX), intent(in) :: time_and_step_string character(len=*), intent(in) :: tag1 character(len=*), intent(in) :: tag2 character(len=FILE_NAME_MAX), intent(out) :: filename Called by proc~~make_filename~~CalledByGraph proc~make_filename vis2d_m::make_filename proc~vis2d_plane_xy__draw vis2d_m::vis2d_plane_xy_t%vis2d_plane_xy__draw proc~vis2d_plane_xy__draw->proc~make_filename proc~vis2d_plane_xz__draw vis2d_m::vis2d_plane_xz_t%vis2d_plane_xz__draw proc~vis2d_plane_xz__draw->proc~make_filename Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Source Code make_filename Source Code subroutine make_filename ( time_and_step_string , tag1 , tag2 , filename ) character ( len = TAG_NAME_MAX ), intent ( in ) :: time_and_step_string character ( len =* ), intent ( in ) :: tag1 , tag2 character ( len = FILE_NAME_MAX ), intent ( out ) :: filename character ( len = 1 ), parameter :: CHAR_USCORE = \"_\" character ( len = 1 ), parameter :: CHAR_SLASH = \"/\" character ( len =* ), parameter :: DIR = '../data/vis2d' filename = DIR // CHAR_SLASH // & trim ( tag1 ) // CHAR_USCORE // & trim ( tag2 ) // CHAR_USCORE // & trim ( time_and_step_string ) // '.svg' end subroutine make_filename","tags":"","loc":"proc/make_filename.html"},{"title":"make_time_and_step_string – Smoke Ring","text":"private  subroutine make_time_and_step_string(t, step, string) Arguments Type Intent Optional Attributes Name real, intent(in) :: t integer, intent(in) :: step character(len=TAG_NAME_MAX), intent(out) :: string Calls proc~~make_time_and_step_string~~CallsGraph proc~make_time_and_step_string vis2d_m::make_time_and_step_string ut__assert ut__assert proc~make_time_and_step_string->ut__assert ut__int_to_str8 ut__int_to_str8 proc~make_time_and_step_string->ut__int_to_str8 ut__real_to_str10 ut__real_to_str10 proc~make_time_and_step_string->ut__real_to_str10 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~make_time_and_step_string~~CalledByGraph proc~make_time_and_step_string vis2d_m::make_time_and_step_string proc~vis2d_plane_xy__draw vis2d_m::vis2d_plane_xy_t%vis2d_plane_xy__draw proc~vis2d_plane_xy__draw->proc~make_time_and_step_string proc~vis2d_plane_xz__draw vis2d_m::vis2d_plane_xz_t%vis2d_plane_xz__draw proc~vis2d_plane_xz__draw->proc~make_time_and_step_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Source Code make_time_and_step_string Source Code subroutine make_time_and_step_string ( t , step , string ) real , intent ( in ) :: t integer , intent ( in ) :: step character ( len = TAG_NAME_MAX ), intent ( out ) :: string character ( len = 1 ), parameter :: CHAR_USCORE = \"_\" character ( len = 10 ) :: str_time_with_sign character ( len = 8 ) :: str_step_with_sign character ( len = 9 ) :: str_time_without_sign character ( len = 7 ) :: str_step_without_sign str_time_with_sign = ut__real_to_str10 ( t ) str_step_with_sign = ut__int_to_str8 ( step ) call ut__assert ( str_time_with_sign ( 1 : 1 ) == \"+\" , & \"vis2d_m/make_time_and_step_string(203): \" // & \"str_time_with_sign is strange.\" ) call ut__assert ( str_step_with_sign ( 1 : 1 ) == \"+\" , & \"vis2d_m/make_time_and_step_string(206): \" // & \"str_step_with_sign is strange.\" ) str_time_without_sign = str_time_with_sign ( 2 : 10 ) str_step_without_sign = str_step_with_sign ( 2 : 8 ) string = \"s=\" // str_step_without_sign & // CHAR_USCORE // & \"t=\" // str_time_without_sign end subroutine make_time_and_step_string","tags":"","loc":"proc/make_time_and_step_string.html"},{"title":"vis2d__draw – Smoke Ring","text":"public  subroutine vis2d__draw(vis2d, t_double, nloop, fluid) Type Bound vis2d_t Arguments Type Intent Optional Attributes Name class( vis2d_t ), intent(inout) :: vis2d real(kind=DR), intent(in) :: t_double integer, intent(in) :: nloop type( fluid_t ), intent(in) :: fluid Calls proc~~vis2d__draw~~CallsGraph proc~vis2d__draw vis2d_m::vis2d_t%vis2d__draw kutimer__end kutimer__end proc~vis2d__draw->kutimer__end kutimer__start kutimer__start proc~vis2d__draw->kutimer__start mpiut__barrier mpiut__barrier proc~vis2d__draw->mpiut__barrier set_data set_data proc~vis2d__draw->set_data Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Source Code vis2d__draw Source Code subroutine vis2d__draw ( vis2d , t_double , nloop , fluid ) class ( vis2d_t ), intent ( inout ) :: vis2d real ( DR ) , intent ( in ) :: t_double integer , intent ( in ) :: nloop type ( fluid_t ) , intent ( in ) :: fluid real :: t integer :: ctr = 0 t = real ( t_double , SR ) call kutimer__start ( 'vis2  ' ) if ( mod ( ctr , 100 ) == 0 ) then call vis2d % set_data ( fluid ) !{vis2  }{set d} if ( Parallel % rank % me == 0 ) then call vis2d % z_upper % draw ( t , nloop ) call vis2d % z_middle % draw ( t , nloop ) !{vis2  }{   xy} !       call vis2d.z_lower.draw ( t, nloop ) !       call vis2d.y_upper.draw ( t, nloop ) !       call vis2d.y_middle.draw( t, nloop ) !       call vis2d.y_lower.draw ( t, nloop )    !{vis2  }{   xz} end if call mpiut__barrier ( Parallel % comm ) end if ; ctr = ctr + 1 call kutimer__end ( 'vis2  ' ) end subroutine vis2d__draw","tags":"","loc":"proc/vis2d__draw.html"},{"title":"vis2d__initialize – Smoke Ring","text":"public  subroutine vis2d__initialize(vis2d) Type Bound vis2d_t Arguments Type Intent Optional Attributes Name class( vis2d_t ), intent(out) :: vis2d Contents Source Code vis2d__initialize Source Code subroutine vis2d__initialize ( vis2d ) class ( vis2d_t ), intent ( out ) :: vis2d integer :: gk_cut , gj_cut gk_cut = int ( NZ_GLOBAL * 0.5 ) call vis2d % z_middle % initialize ( gk_cut , 'z_middle' ) gk_cut = int ( NZ_GLOBAL * 0.75 ) call vis2d % z_upper % initialize ( gk_cut , 'z_upper' ) gk_cut = int ( NZ_GLOBAL * 0.25 ) call vis2d % z_lower % initialize ( gk_cut , 'z_lower' ) gj_cut = int ( NY_GLOBAL * 0.5 ) call vis2d % y_middle % initialize ( gj_cut , 'y_middle' ) gj_cut = int ( NY_GLOBAL * 0.75 ) call vis2d % y_upper % initialize ( gj_cut , 'y_upper' ) gj_cut = int ( NY_GLOBAL * 0.25 ) call vis2d % y_lower % initialize ( gj_cut , 'y_lower' ) end subroutine vis2d__initialize","tags":"","loc":"proc/vis2d__initialize.html"},{"title":"vis2d__set_data – Smoke Ring","text":"private  subroutine vis2d__set_data(vis2d, fluid) Type Bound vis2d_t Arguments Type Intent Optional Attributes Name class( vis2d_t ), intent(inout) :: vis2d type( fluid_t ), intent(in) :: fluid Calls proc~~vis2d__set_data~~CallsGraph proc~vis2d__set_data vis2d_m::vis2d_t%vis2d__set_data update update proc~vis2d__set_data->update Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Source Code vis2d__set_data Source Code subroutine vis2d__set_data ( vis2d , fluid ) class ( vis2d_t ) , intent ( inout ) :: vis2d type ( fluid_t ) , intent ( in ) :: fluid type ( vissubfield3d_t ) :: vissubfield3d call vissubfield3d % update ( fluid ) call vis2d % z_middle % set_data ( fluid , vissubfield3d ) call vis2d % z_upper % set_data ( fluid , vissubfield3d ) call vis2d % z_lower % set_data ( fluid , vissubfield3d ) call vis2d % y_middle % set_data ( fluid , vissubfield3d ) call vis2d % y_upper % set_data ( fluid , vissubfield3d ) call vis2d % y_lower % set_data ( fluid , vissubfield3d ) end subroutine vis2d__set_data","tags":"","loc":"proc/vis2d__set_data.html"},{"title":"vis2d_plane_xy__draw – Smoke Ring","text":"private  subroutine vis2d_plane_xy__draw(plane, t, step) < Type Bound vis2d_plane_xy_t Arguments Type Intent Optional Attributes Name class( vis2d_plane_xy_t ), intent(inout) :: plane real, intent(in) :: t integer, intent(in) :: step Calls proc~~vis2d_plane_xy__draw~~CallsGraph proc~vis2d_plane_xy__draw vis2d_m::vis2d_plane_xy_t%vis2d_plane_xy__draw kutimer__ kutimer__ proc~vis2d_plane_xy__draw->kutimer__ kutimer__end kutimer__end proc~vis2d_plane_xy__draw->kutimer__end kutimer__start kutimer__start proc~vis2d_plane_xy__draw->kutimer__start proc~draw_contour_and_arrows vis2d_m::draw_contour_and_arrows proc~vis2d_plane_xy__draw->proc~draw_contour_and_arrows proc~make_filename vis2d_m::make_filename proc~vis2d_plane_xy__draw->proc~make_filename proc~make_time_and_step_string vis2d_m::make_time_and_step_string proc~vis2d_plane_xy__draw->proc~make_time_and_step_string comp_u comp_u proc~draw_contour_and_arrows->comp_u comp_v comp_v proc~draw_contour_and_arrows->comp_v finalize finalize proc~draw_contour_and_arrows->finalize group_pop group_pop proc~draw_contour_and_arrows->group_pop group_push group_push proc~draw_contour_and_arrows->group_push initialize initialize proc~draw_contour_and_arrows->initialize proc~min_max_string vis2d_m::min_max_string proc~draw_contour_and_arrows->proc~min_max_string proc~vec_amp_max_string vis2d_m::vec_amp_max_string proc~draw_contour_and_arrows->proc~vec_amp_max_string vis_arrows vis_arrows proc~draw_contour_and_arrows->vis_arrows vis_contour vis_contour proc~draw_contour_and_arrows->vis_contour vv_color__normalized_real_to_color vv_color__normalized_real_to_color proc~draw_contour_and_arrows->vv_color__normalized_real_to_color ut__assert ut__assert proc~make_time_and_step_string->ut__assert ut__int_to_str8 ut__int_to_str8 proc~make_time_and_step_string->ut__int_to_str8 ut__real_to_str10 ut__real_to_str10 proc~make_time_and_step_string->ut__real_to_str10 proc~min_max_string->ut__real_to_str10 proc~vec_amp_max_string->ut__real_to_str10 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Source Code vis2d_plane_xy__draw Source Code subroutine vis2d_plane_xy__draw ( plane , t , step ) class ( vis2d_plane_xy_t ), intent ( inout ) :: plane real , intent ( in ) :: t integer , intent ( in ) :: step character ( len = TAG_NAME_MAX ) :: tas character ( len = FILE_NAME_MAX ) :: filename type ( vv_sketch__sim_pos_t ) :: ll , & ! lower left ur ! upper right ll % u = XMIN ll % v = YMIN ur % u = XMAX ur % v = YMAX call kutimer__start ( 'vis2xy' ) call make_time_and_step_string ( t , step , tas ) !!> !    call make_filename( tas, plane.tag, plane.pressure.tag, filename ) !    call draw_contour( ll, ur, filename, plane.pressure ) !                                               call kutimer__('vis2xy','  pres') !    call make_filename( tas, plane.tag, plane.flow_helicity.tag, filename ) !    call draw_contour( ll, ur, filename, plane.flow_helicity ) !                                               call kutimer__('vis2xy','f heli') !    call make_filename( tas, plane.tag, plane.velocity_z.tag, filename ) !    call draw_contour( ll, ur, filename, plane.velocity_z ) !                                               call kutimer__('vis2xy',' vel z') !    call make_filename( tas, plane.tag, plane.enstrophy.tag, filename ) !    call draw_contour( ll, ur, filename, plane.enstrophy ) !                                               call kutimer__('vis2xy','   ens') !    call make_filename( tas, plane.tag, plane.velocity.tag, filename ) !    call draw_arrows( ll, ur, filename, plane.velocity ) !                                               call kutimer__('vis2xy','   vel') !    call make_filename( tas, plane.tag, plane.vorticity.tag, filename ) !    call draw_arrows( ll, ur, filename, plane.vorticity ) !                                               call kutimer__('vis2xy','   vor') !!< call make_filename ( tas , plane % tag , 'enstrophy_and_flow' , filename ) call draw_contour_and_arrows ( ll , ur , filename , plane % enstrophy , & plane % velocity ) call kutimer__ ( 'vis2xy' , 'ensvel' ) call kutimer__end ( 'vis2xy' ) end subroutine vis2d_plane_xy__draw","tags":"","loc":"proc/vis2d_plane_xy__draw.html"},{"title":"vis2d_plane_xy__initialize – Smoke Ring","text":"private  subroutine vis2d_plane_xy__initialize(plane, gk_cut, tag) Type Bound vis2d_plane_xy_t Arguments Type Intent Optional Attributes Name class( vis2d_plane_xy_t ), intent(out) :: plane integer, intent(in) :: gk_cut character(len=*), intent(in) :: tag Contents Source Code vis2d_plane_xy__initialize Source Code subroutine vis2d_plane_xy__initialize ( plane , & gk_cut , & tag ) class ( vis2d_plane_xy_t ), intent ( out ) :: plane integer , intent ( in ) :: gk_cut character ( len =* ), intent ( in ) :: tag real ( SR ), dimension (:), allocatable :: grid_u real ( SR ), dimension (:), allocatable :: grid_v integer :: nu , nv nu = NX_GLOBAL nv = NY_GLOBAL allocate ( grid_u ( nu ), grid_v ( nv )) grid_u (:) = real ( Grid % pos_by_global_ijk % x (:), SR ) grid_v (:) = real ( Grid % pos_by_global_ijk % y (:), SR ) plane % gk_cut = gk_cut plane % tag = tag call plane % pressure % initialize ( 'pressure' , & nu , & nv , & grid_u , & grid_v ) call plane % flow_helicity % initialize ( 'flow_helicity' , & nu , & nv , & grid_u , & grid_v ) call plane % velocity_z % initialize ( 'velocity_z' , & nu , & nv , & grid_u , & grid_v ) call plane % enstrophy % initialize ( 'enstrophy' , & nu , & nv , & grid_u , & grid_v ) call plane % velocity % initialize ( 'velocity' , & nu , & nv , & grid_u , & grid_v ) call plane % vorticity % initialize ( 'vorticity' , & nu , & nv , & grid_u , & grid_v ) end subroutine vis2d_plane_xy__initialize","tags":"","loc":"proc/vis2d_plane_xy__initialize.html"},{"title":"vis2d_plane_xy__set_data – Smoke Ring","text":"private  subroutine vis2d_plane_xy__set_data(plane, fluid, vf) Type Bound vis2d_plane_xy_t Arguments Type Intent Optional Attributes Name class( vis2d_plane_xy_t ), intent(inout) :: plane type( fluid_t ), intent(in) :: fluid type( vissubfield3d_t ), intent(in) :: vf Contents Source Code vis2d_plane_xy__set_data Source Code subroutine vis2d_plane_xy__set_data ( plane , fluid , vf ) class ( vis2d_plane_xy_t ) , intent ( inout ) :: plane type ( fluid_t ) , intent ( in ) :: fluid type ( vissubfield3d_t ) , intent ( in ) :: vf integer :: nu , nv , gk_cut nu = plane % pressure % mesh % vert % nu nv = plane % pressure % mesh % vert % nv gk_cut = plane % gk_cut plane % pressure % val_vert = iCut ( nu , nv , gk_cut , & fluid % pressure ) plane % flow_helicity % val_vert = iCut ( nu , nv , gk_cut , & vf % helicity ) plane % velocity_z % val_vert = iCut ( nu , nv , gk_cut , & vf % velocity % z ) plane % enstrophy % val_vert = iCut ( nu , nv , gk_cut , & vf % enstrophy ) plane % velocity % comp_u = iCut ( nu , nv , gk_cut , & vf % velocity % x ) plane % velocity % comp_v = iCut ( nu , nv , gk_cut , & vf % velocity % y ) plane % vorticity % comp_u = iCut ( nu , nv , gk_cut , & vf % vorticity % x ) plane % vorticity % comp_v = iCut ( nu , nv , gk_cut , & vf % vorticity % y ) contains function iCut ( nu , nv , gk_cut , field3d1 , field3d0 ) result ( field2d ) integer , intent ( in ) :: nu , nv , gk_cut real ( DR ), dimension ( 0 : NXPP1 , 0 : NYPP1 , 0 : NZPP1 ), intent ( in ) :: field3d1 real ( DR ), dimension ( 0 : NXPP1 , 0 : NYPP1 , 0 : NZPP1 ), intent ( in ), optional :: field3d0 real , dimension ( nu , nv ) :: field2d !!> !          When NXPP=3, NPROC_X=2, NX_GLOBAL=8 ! !         [rank 0] !                        li=0   1    2    3    4 !             field3d1&0...o----o----o----o----o !                          |    |    |    | !             field2d......o----o----o----o----x----x----x----x !                        gi=1   2    3    4    5    6    7    8 ! !         [rank 1] !                                       li=0   1    2    3    4 !             field3d1&0..................o----o----o----o----o !                                              |    |    |    | !             field2d......x----x----x----x----o----o----o----o !                        gi=1   2    3    4    5    6    7    8 ! ! !         <<all_reduce_sum>> !                        gi=1   2    3    4    5    6    7    8 !                 [rank 0] o----o----o----o----x----x----x----x !                 [rank 1] x----x----x----x----o----o----o----o !                          |    |    |    |    |    |    |    | !             field2d......o----o----o----o----o----o----o----o ! !!< integer :: li , lj , lk_cut , gi , gj integer :: li_from , li_to , lj_from , lj_to field2d (:,:) = 0.0 if ( Grid % i_have_gk ( gk_cut ) ) then lk_cut = Grid % local_ijk_from_global_ijk % lk ( gk_cut ) li_from = 1 ! default li_to = NXPP ! default lj_from = 1 ! default lj_to = NYPP ! default if ( Parallel % i_have_xmin ) li_from = 0 if ( Parallel % i_have_xmax ) li_to = NXPP1 if ( Parallel % i_have_ymin ) lj_from = 0 if ( Parallel % i_have_ymax ) lj_to = NYPP1 if ( present ( field3d0 ) ) then do lj = lj_from , lj_to do li = li_from , li_to gj = Grid % global_ijk % gj ( lj ) gi = Grid % global_ijk % gi ( li ) field2d ( gi , gj ) = real ( field3d1 ( li , lj , lk_cut ) & - field3d0 ( li , lj , lk_cut ), SR ) end do end do else do lj = lj_from , lj_to do li = li_from , li_to gj = Grid % global_ijk % gj ( lj ) gi = Grid % global_ijk % gi ( li ) field2d ( gi , gj ) = real ( field3d1 ( li , lj , lk_cut ), SR ) end do end do end if end if call mpiut__allreduce_sum ( Parallel % comm , field2d ) end function iCut end subroutine vis2d_plane_xy__set_data","tags":"","loc":"proc/vis2d_plane_xy__set_data.html"},{"title":"vis2d_plane_xz__draw – Smoke Ring","text":"private  subroutine vis2d_plane_xz__draw(plane, t, step) < < Type Bound vis2d_plane_xz_t Arguments Type Intent Optional Attributes Name class( vis2d_plane_xz_t ), intent(inout) :: plane real, intent(in) :: t integer, intent(in) :: step Calls proc~~vis2d_plane_xz__draw~~CallsGraph proc~vis2d_plane_xz__draw vis2d_m::vis2d_plane_xz_t%vis2d_plane_xz__draw kutimer__ kutimer__ proc~vis2d_plane_xz__draw->kutimer__ kutimer__end kutimer__end proc~vis2d_plane_xz__draw->kutimer__end kutimer__start kutimer__start proc~vis2d_plane_xz__draw->kutimer__start proc~draw_contour vis2d_m::draw_contour proc~vis2d_plane_xz__draw->proc~draw_contour proc~draw_contour_and_arrows vis2d_m::draw_contour_and_arrows proc~vis2d_plane_xz__draw->proc~draw_contour_and_arrows proc~make_filename vis2d_m::make_filename proc~vis2d_plane_xz__draw->proc~make_filename proc~make_time_and_step_string vis2d_m::make_time_and_step_string proc~vis2d_plane_xz__draw->proc~make_time_and_step_string finalize finalize proc~draw_contour->finalize group_pop group_pop proc~draw_contour->group_pop group_push group_push proc~draw_contour->group_push initialize initialize proc~draw_contour->initialize proc~min_max_string vis2d_m::min_max_string proc~draw_contour->proc~min_max_string vis_contour vis_contour proc~draw_contour->vis_contour vv_color__normalized_real_to_color vv_color__normalized_real_to_color proc~draw_contour->vv_color__normalized_real_to_color comp_u comp_u proc~draw_contour_and_arrows->comp_u comp_v comp_v proc~draw_contour_and_arrows->comp_v proc~draw_contour_and_arrows->finalize proc~draw_contour_and_arrows->group_pop proc~draw_contour_and_arrows->group_push proc~draw_contour_and_arrows->initialize proc~draw_contour_and_arrows->proc~min_max_string proc~vec_amp_max_string vis2d_m::vec_amp_max_string proc~draw_contour_and_arrows->proc~vec_amp_max_string vis_arrows vis_arrows proc~draw_contour_and_arrows->vis_arrows proc~draw_contour_and_arrows->vis_contour proc~draw_contour_and_arrows->vv_color__normalized_real_to_color ut__assert ut__assert proc~make_time_and_step_string->ut__assert ut__int_to_str8 ut__int_to_str8 proc~make_time_and_step_string->ut__int_to_str8 ut__real_to_str10 ut__real_to_str10 proc~make_time_and_step_string->ut__real_to_str10 proc~min_max_string->ut__real_to_str10 proc~vec_amp_max_string->ut__real_to_str10 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Source Code vis2d_plane_xz__draw Source Code subroutine vis2d_plane_xz__draw ( plane , t , step ) class ( vis2d_plane_xz_t ), intent ( inout ) :: plane real , intent ( in ) :: t integer , intent ( in ) :: step character ( len = TAG_NAME_MAX ) :: tas ! time and step string character ( len = FILE_NAME_MAX ) :: filename type ( vv_sketch__sim_pos_t ) :: ll , & ! lower left ur ! upper right ll % u = XMIN ll % v = ZMIN ur % u = XMAX ur % v = ZMAX call kutimer__start ( 'vis2xz' ) call make_time_and_step_string ( t , step , tas ) !!> !    call make_filename( tas, plane.tag, plane.pressure.tag, filename ) !    call draw_contour( ll, ur, filename, plane.pressure ) !                                               call kutimer__('vis2xz','  pres') !    call make_filename( tas, plane.tag, plane.flow_helicity.tag, filename ) !    call draw_contour( ll, ur, filename, plane.flow_helicity ) !                                               call kutimer__('vis2xz','f heli') !    call make_filename( tas, plane.tag, plane.velocity_y.tag, filename ) !    call draw_contour( ll, ur, filename, plane.velocity_y ) !                                               call kutimer__('vis2xz',' vel z') !!< call make_filename ( tas , plane % tag , plane % enstrophy % tag , filename ) call draw_contour ( ll , ur , filename , plane % enstrophy ) call kutimer__ ( 'vis2xz' , '   ens' ) !!> !    call make_filename( tas, plane.tag, plane.velocity.tag, filename ) !    call draw_arrows( ll, ur, filename, plane.velocity ) !                                               call kutimer__('vis2xz','   vel') !    call make_filename( tas, plane.tag, plane.vorticity.tag, filename ) !    call draw_arrows( ll, ur, filename, plane.vorticity ) !                                               call kutimer__('vis2xz','   vor') !!< call make_filename ( tas , plane % tag , 'combined_ens_vel' , filename ) call draw_contour_and_arrows ( ll , ur , filename , plane % enstrophy , & plane % velocity ) call kutimer__ ( 'vis2xz' , 'ensvel' ) call kutimer__end ( 'vis2xz' ) end subroutine vis2d_plane_xz__draw","tags":"","loc":"proc/vis2d_plane_xz__draw.html"},{"title":"vis2d_plane_xz__initialize – Smoke Ring","text":"private  subroutine vis2d_plane_xz__initialize(plane, gj_cut, tag) Type Bound vis2d_plane_xz_t Arguments Type Intent Optional Attributes Name class( vis2d_plane_xz_t ), intent(out) :: plane integer, intent(in) :: gj_cut character(len=*), intent(in) :: tag Contents Source Code vis2d_plane_xz__initialize Source Code subroutine vis2d_plane_xz__initialize ( plane , & gj_cut , & tag ) class ( vis2d_plane_xz_t ), intent ( out ) :: plane integer , intent ( in ) :: gj_cut character ( len =* ), intent ( in ) :: tag real ( SR ), dimension (:), allocatable :: grid_u real ( SR ), dimension (:), allocatable :: grid_v integer :: nu , nv nu = NX_GLOBAL nv = NZ_GLOBAL allocate ( grid_u ( nu ), grid_v ( nv )) grid_u (:) = real ( Grid % pos_by_global_ijk % x (:), SR ) grid_v (:) = real ( Grid % pos_by_global_ijk % z (:), SR ) plane % gj_cut = gj_cut plane % tag = tag call plane % pressure % initialize ( 'pressure' , & nu , & nv , & grid_u , & grid_v ) call plane % flow_helicity % initialize ( 'flow_helicity' , & nu , & nv , & grid_u , & grid_v ) call plane % velocity_y % initialize ( 'velocity_y' , & nu , & nv , & grid_u , & grid_v ) call plane % enstrophy % initialize ( 'enstrophy' , & nu , & nv , & grid_u , & grid_v ) call plane % velocity % initialize ( 'velocity' , & nu , & nv , & grid_u , & grid_v ) call plane % vorticity % initialize ( 'vorticity' , & nu , & nv , & grid_u , & grid_v ) end subroutine vis2d_plane_xz__initialize","tags":"","loc":"proc/vis2d_plane_xz__initialize.html"},{"title":"vis2d_plane_xz__set_data – Smoke Ring","text":"private  subroutine vis2d_plane_xz__set_data(plane, fluid, vf) Type Bound vis2d_plane_xz_t Arguments Type Intent Optional Attributes Name class( vis2d_plane_xz_t ), intent(inout) :: plane type( fluid_t ), intent(in) :: fluid type( vissubfield3d_t ), intent(in) :: vf Contents Source Code vis2d_plane_xz__set_data Source Code subroutine vis2d_plane_xz__set_data ( plane , fluid , vf ) class ( vis2d_plane_xz_t ) , intent ( inout ) :: plane type ( fluid_t ) , intent ( in ) :: fluid type ( vissubfield3d_t ) , intent ( in ) :: vf integer :: nu , nv , gj_cut nu = plane % pressure % mesh % vert % nu nv = plane % pressure % mesh % vert % nv gj_cut = plane % gj_cut plane % pressure % val_vert = iCut ( nu , nv , gj_cut , & fluid % pressure ) plane % flow_helicity % val_vert = iCut ( nu , nv , gj_cut , & vf % helicity ) plane % velocity_y % val_vert = iCut ( nu , nv , gj_cut , & vf % velocity % y ) plane % enstrophy % val_vert = iCut ( nu , nv , gj_cut , & vf % enstrophy ) plane % velocity % comp_u = iCut ( nu , nv , gj_cut , & vf % velocity % x ) plane % velocity % comp_v = iCut ( nu , nv , gj_cut , & vf % velocity % z ) plane % vorticity % comp_u = iCut ( nu , nv , gj_cut , & vf % vorticity % x ) plane % vorticity % comp_v = iCut ( nu , nv , gj_cut , & vf % vorticity % z ) contains function iCut ( nu , nv , gj_cut , field3d1 , field3d0 ) result ( field2d ) integer , intent ( in ) :: nu , nv , gj_cut real ( DR ), dimension ( 0 : NXPP1 , 0 : NYPP1 , 0 : NZPP1 ), intent ( in ) :: field3d1 real ( DR ), dimension ( 0 : NXPP1 , 0 : NYPP1 , 0 : NZPP1 ), intent ( in ), optional :: field3d0 real , dimension ( nu , nv ) :: field2d integer :: li , lk , lj_cut , gi , gk integer :: li_from , li_to , lk_from , lk_to field2d (:,:) = 0.0 if ( Grid % i_have_gj ( gj_cut ) ) then lj_cut = Grid % local_ijk_from_global_ijk % lj ( gj_cut ) li_from = 1 ! default li_to = NXPP ! default lk_from = 1 ! default lk_to = NZPP ! default if ( Parallel % i_have_xmin ) li_from = 0 if ( Parallel % i_have_xmax ) li_to = NXPP1 if ( Parallel % i_have_zmin ) lk_from = 0 if ( Parallel % i_have_zmax ) lk_to = NZPP1 if ( present ( field3d0 ) ) then do lk = lk_from , lk_to do li = li_from , li_to gk = Grid % global_ijk % gk ( lk ) gi = Grid % global_ijk % gi ( li ) field2d ( gi , gk ) = real ( field3d1 ( li , lj_cut , lk ) & - field3d0 ( li , lj_cut , lk ), SR ) end do end do else do lk = lk_from , lk_to do li = li_from , li_to gk = Grid % global_ijk % gk ( lk ) gi = Grid % global_ijk % gi ( li ) field2d ( gi , gk ) = real ( field3d1 ( li , lj_cut , lk ), SR ) end do end do end if end if call mpiut__allreduce_sum ( Parallel % comm , field2d ) end function iCut end subroutine vis2d_plane_xz__set_data","tags":"","loc":"proc/vis2d_plane_xz__set_data.html"},{"title":"vissubfield3d__update – Smoke Ring","text":"private  subroutine vissubfield3d__update(vf, fluid) Type Bound vissubfield3d_t Arguments Type Intent Optional Attributes Name class( vissubfield3d_t ), intent(out) :: vf type( fluid_t ), intent(in) :: fluid Calls proc~~vissubfield3d__update~~CallsGraph proc~vissubfield3d__update vis2d_m::vissubfield3d_t%vissubfield3d__update get_subfield get_subfield proc~vissubfield3d__update->get_subfield Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Source Code vissubfield3d__update Source Code subroutine vissubfield3d__update ( vf , fluid ) class ( vissubfield3d_t ), intent ( out ) :: vf type ( fluid_t ) , intent ( in ) :: fluid call solver % get_subfield ( fluid , vf % velocity ) vf % vorticity = . curl . vf % velocity ! curl演算子はfield_mで定義 vf % helicity = vf % velocity . dot . vf % vorticity ! ヘリシティ = 流れと渦度の内積 vf % enstrophy = vf % vorticity . dot . vf % vorticity ! 内積演算子はfield_mで定義 end subroutine vissubfield3d__update","tags":"","loc":"proc/vissubfield3d__update.html"},{"title":"operator_energyintegral – Smoke Ring","text":"public  function operator_energyintegral(a) result(ans) 流体の運動エネルギーの体積積分\n現在のシュミレーションでは格子間隔はx, y, z それぞれに\n一様であることを仮定している。つまりdx, dy, dzは空間位置に\n依存せず一定である。 質量フラックスの2乗を一時的な配列にセットする Arguments Type Intent Optional Attributes Name type( fluid_t ), intent(in) :: a 流体場 Return Value real(kind=DR) 全エネルギー\n以下のエネルギー密度の式を全空間で体積積分する\nflow_energy = (1/2) * rho * vel&#94;2 = (1/2) * (massflux)&#94;2 / rho Calls proc~~operator_energyintegral~~CallsGraph proc~operator_energyintegral fluid_m::operator_energyintegral density density proc~operator_energyintegral->density Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~operator_energyintegral~~CalledByGraph proc~operator_energyintegral fluid_m::operator_energyintegral interface~operator( .energyintegral. ) fluid_m::operator( .energyintegral. ) interface~operator( .energyintegral. )->proc~operator_energyintegral Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Source Code operator_energyintegral Source Code function operator_energyintegral ( a ) result ( ans ) !! 流体の運動エネルギーの体積積分 type ( fluid_t ), intent ( in ) :: a !! 流体場 real ( DR ) :: ans !! 全エネルギー !! 以下のエネルギー密度の式を全空間で体積積分する !! flow_energy = (1/2) * rho * vel&#94;2 = (1/2) * (massflux)&#94;2 / rho real ( DR ) :: dvol real ( DR ), dimension ( 0 : NXPP1 , 0 : NYPP1 , 0 : NZPP1 ) :: flux_sq ! sq は2乗(squared)を意味する dvol = ( grid % delta % x ) * ( grid % delta % y ) * ( grid % delta % z ) !! 現在のシュミレーションでは格子間隔はx, y, z それぞれに !! 一様であることを仮定している。つまりdx, dy, dzは空間位置に !! 依存せず一定である。 flux_sq = ( a % flux ) . dot . ( a % flux ) !! 質量フラックスの2乗を一時的な配列にセットする ans = 0.5_DR * sum ( flux_sq ( 1 : NXPP , 1 : NYPP , 1 : NZPP ) & / a % density ( 1 : NXPP , 1 : NYPP , 1 : NZPP ) & ) * dvol ! ここで配列演算の添字が1からNXではなく2からNX-1などに ! 限定されていることに注意。これは体積積分の範囲を計算領域の ! 内部に限定していること、つまり境界上の格子点を除いて ! 積分していることを意味する。境界上の格子点まで ! 入れると重複してカウントしてしまうからである end function operator_energyintegral","tags":"","loc":"proc/operator_energyintegral.html"},{"title":"operator_fluid_add – Smoke Ring","text":"public  function operator_fluid_add(a, b) result(ans) 流体構造体の足し算演算子 Arguments Type Intent Optional Attributes Name type( fluid_t ), intent(in) :: a 足し算する2つの流体場 type( fluid_t ), intent(in) :: b 足し算する2つの流体場 Return Value type( fluid_t ) 計算結果 Called by proc~~operator_fluid_add~~CalledByGraph proc~operator_fluid_add fluid_m::operator_fluid_add interface~operator( + ) fluid_m::operator( + ) interface~operator( + )->proc~operator_fluid_add Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Source Code operator_fluid_add Source Code function operator_fluid_add ( a , b ) result ( ans ) !! 流体構造体の足し算演算子 type ( fluid_t ), intent ( in ) :: a , b !! 足し算する2つの流体場 type ( fluid_t ) :: ans !! 計算結果 ans % flux % x = a % flux % x + b % flux % x ans % flux % y = a % flux % y + b % flux % y ans % flux % z = a % flux % z + b % flux % z ans % density = a % density + b % density ans % pressure = a % pressure + b % pressure end function operator_fluid_add","tags":"","loc":"proc/operator_fluid_add.html"},{"title":"operator_fluid_times_integer – Smoke Ring","text":"public  function operator_fluid_times_integer(fluid, integer) result(ans) 流体構造体を整数倍するための演算子 Arguments Type Intent Optional Attributes Name type( fluid_t ), intent(in) :: fluid 流体場 integer, intent(in) :: integer かける整数 Return Value type( fluid_t ) Called by proc~~operator_fluid_times_integer~~CalledByGraph proc~operator_fluid_times_integer fluid_m::operator_fluid_times_integer interface~operator( ASTERISK ) fluid_m::operator( * ) interface~operator( ASTERISK )->proc~operator_fluid_times_integer Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Source Code operator_fluid_times_integer Source Code function operator_fluid_times_integer ( fluid , integer ) result ( ans ) !! 流体構造体を整数倍するための演算子 type ( fluid_t ), intent ( in ) :: fluid !! 流体場 integer , intent ( in ) :: integer !! かける整数 type ( fluid_t ) :: ans ans % pressure = integer * ( fluid % pressure ) ans % density = integer * ( fluid % density ) ans % flux % x = integer * ( fluid % flux % x ) ans % flux % y = integer * ( fluid % flux % y ) ans % flux % z = integer * ( fluid % flux % z ) end function operator_fluid_times_integer","tags":"","loc":"proc/operator_fluid_times_integer.html"},{"title":"operator_fluid_times_real – Smoke Ring","text":"public  function operator_fluid_times_real(fluid, real) result(ans) 流体構造体を実数倍するための演算子 Arguments Type Intent Optional Attributes Name type( fluid_t ), intent(in) :: fluid 流体場 real(kind=DR), intent(in) :: real かける実数 Return Value type( fluid_t ) 計算結果 Called by proc~~operator_fluid_times_real~~CalledByGraph proc~operator_fluid_times_real fluid_m::operator_fluid_times_real interface~operator( ASTERISK ) fluid_m::operator( * ) interface~operator( ASTERISK )->proc~operator_fluid_times_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Source Code operator_fluid_times_real Source Code function operator_fluid_times_real ( fluid , real ) result ( ans ) !! 流体構造体を実数倍するための演算子 type ( fluid_t ), intent ( in ) :: fluid !! 流体場 real ( DR ), intent ( in ) :: real !! かける実数 type ( fluid_t ) :: ans !! 計算結果 ans % pressure = real * ( fluid % pressure ) ans % density = real * ( fluid % density ) ans % flux % x = real * ( fluid % flux % x ) ans % flux % y = real * ( fluid % flux % y ) ans % flux % z = real * ( fluid % flux % z ) end function operator_fluid_times_real","tags":"","loc":"proc/operator_fluid_times_real.html"},{"title":"operator_integer_times_fluid – Smoke Ring","text":"public  function operator_integer_times_fluid(integer, fluid) result(ans) 整数に流体構造体を掛け算するための演算子 Arguments Type Intent Optional Attributes Name integer, intent(in) :: integer かける整数 type( fluid_t ), intent(in) :: fluid 流体場 Return Value type( fluid_t ) 計算結果 Called by proc~~operator_integer_times_fluid~~CalledByGraph proc~operator_integer_times_fluid fluid_m::operator_integer_times_fluid interface~operator( ASTERISK ) fluid_m::operator( * ) interface~operator( ASTERISK )->proc~operator_integer_times_fluid Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Source Code operator_integer_times_fluid Source Code function operator_integer_times_fluid ( integer , fluid ) result ( ans ) !! 整数に流体構造体を掛け算するための演算子 integer , intent ( in ) :: integer !! かける整数 type ( fluid_t ), intent ( in ) :: fluid !! 流体場 type ( fluid_t ) :: ans !! 計算結果 ans % pressure = integer * ( fluid % pressure ) ans % density = integer * ( fluid % density ) ans % flux % x = integer * ( fluid % flux % x ) ans % flux % y = integer * ( fluid % flux % y ) ans % flux % z = integer * ( fluid % flux % z ) end function operator_integer_times_fluid","tags":"","loc":"proc/operator_integer_times_fluid.html"},{"title":"operator_real_times_fluid – Smoke Ring","text":"public  function operator_real_times_fluid(real, fluid) result(ans) 実数に流体場を掛ける演算子 Arguments Type Intent Optional Attributes Name real(kind=DR), intent(in) :: real 掛ける実数 type( fluid_t ), intent(in) :: fluid 流体場 Return Value type( fluid_t ) 計算結果 Called by proc~~operator_real_times_fluid~~CalledByGraph proc~operator_real_times_fluid fluid_m::operator_real_times_fluid interface~operator( ASTERISK ) fluid_m::operator( * ) interface~operator( ASTERISK )->proc~operator_real_times_fluid Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Source Code operator_real_times_fluid Source Code function operator_real_times_fluid ( real , fluid ) result ( ans ) !! 実数に流体場を掛ける演算子 real ( DR ), intent ( in ) :: real !! 掛ける実数 type ( fluid_t ), intent ( in ) :: fluid !! 流体場 type ( fluid_t ) :: ans !! 計算結果 ans % pressure = real * ( fluid % pressure ) ans % density = real * ( fluid % density ) ans % flux % x = real * ( fluid % flux % x ) ans % flux % y = real * ( fluid % flux % y ) ans % flux % z = real * ( fluid % flux % z ) end function operator_real_times_fluid","tags":"","loc":"proc/operator_real_times_fluid.html"},{"title":"assignment_real_to_fluid – Smoke Ring","text":"public  subroutine assignment_real_to_fluid(fluid, real) 流体構造体に実数を代入。\n初期条件ですべての要素を0にセットするときに使う。 Arguments Type Intent Optional Attributes Name type( fluid_t ), intent(out) :: fluid 流体場 real(kind=DR), intent(in) :: real 代入する実数 Called by proc~~assignment_real_to_fluid~~CalledByGraph proc~assignment_real_to_fluid fluid_m::assignment_real_to_fluid interface~assignment( = ) fluid_m::assignment( = ) interface~assignment( = )->proc~assignment_real_to_fluid Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Source Code assignment_real_to_fluid Source Code subroutine assignment_real_to_fluid ( fluid , real ) !! 流体構造体に実数を代入。 !! 初期条件ですべての要素を0にセットするときに使う。 type ( fluid_t ), intent ( out ) :: fluid !! 流体場 real ( DR ), intent ( in ) :: real !! 代入する実数 fluid % pressure (:,:,:) = real fluid % density (:,:,:) = real fluid % flux % x (:,:,:) = real fluid % flux % y (:,:,:) = real fluid % flux % z (:,:,:) = real end subroutine assignment_real_to_fluid","tags":"","loc":"proc/assignment_real_to_fluid.html"},{"title":"fluid__set_boundary_condition – Smoke Ring","text":"public  subroutine fluid__set_boundary_condition(fluid) プロセス間通信で領域境界データを交換 Type Bound fluid_t Arguments Type Intent Optional Attributes Name class( fluid_t ), intent(inout) :: fluid 流体構造体の周期境界条件設定 Calls proc~~fluid__set_boundary_condition~~CallsGraph proc~fluid__set_boundary_condition fluid_m::fluid_t%fluid__set_boundary_condition mpiut__barrier mpiut__barrier proc~fluid__set_boundary_condition->mpiut__barrier mpiut__exchange mpiut__exchange proc~fluid__set_boundary_condition->mpiut__exchange Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Source Code fluid__set_boundary_condition Source Code subroutine fluid__set_boundary_condition ( fluid ) class ( fluid_t ), intent ( inout ) :: fluid !! 流体構造体の周期境界条件設定 call mpiut__exchange ( Parallel % comm , & Parallel % periodic_pair , & fluid % pressure , & fluid % density , & fluid % flux % x , & fluid % flux % y , & fluid % flux % z ) call mpiut__barrier ( Parallel % comm ) !! プロセス間通信で領域境界データを交換 call mpiut__exchange ( Parallel % comm , & Parallel % rank % next , & fluid % pressure , & fluid % density , & fluid % flux % x , & fluid % flux % y , & fluid % flux % z ) call mpiut__barrier ( Parallel % comm ) end subroutine fluid__set_boundary_condition","tags":"","loc":"proc/fluid__set_boundary_condition.html"},{"title":"assignment( = ) – Smoke Ring","text":"public interface assignment( = ) 流体構造体に代入記号が使えるように定義 Calls interface~~assignment( = )~~CallsGraph interface~assignment( = ) fluid_m::assignment( = ) proc~assignment_real_to_fluid fluid_m::assignment_real_to_fluid interface~assignment( = )->proc~assignment_real_to_fluid Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Module Procedures assignment_real_to_fluid Module Procedures public  subroutine assignment_real_to_fluid (fluid, real) 流体構造体に実数を代入。\n初期条件ですべての要素を0にセットするときに使う。 Arguments Type Intent Optional Attributes Name type( fluid_t ), intent(out) :: fluid 流体場 real(kind=DR), intent(in) :: real 代入する実数","tags":"","loc":"interface/assignment( = ).html"},{"title":"operator( * ) – Smoke Ring","text":"public interface operator( * ) 流体構造体の全要素の整数・実数倍 Calls interface~~operator( ASTERISK )~~CallsGraph interface~operator( ASTERISK ) fluid_m::operator( * ) proc~operator_fluid_times_integer fluid_m::operator_fluid_times_integer interface~operator( ASTERISK )->proc~operator_fluid_times_integer proc~operator_fluid_times_real fluid_m::operator_fluid_times_real interface~operator( ASTERISK )->proc~operator_fluid_times_real proc~operator_integer_times_fluid fluid_m::operator_integer_times_fluid interface~operator( ASTERISK )->proc~operator_integer_times_fluid proc~operator_real_times_fluid fluid_m::operator_real_times_fluid interface~operator( ASTERISK )->proc~operator_real_times_fluid Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Module Procedures operator_fluid_times_integer operator_integer_times_fluid operator_fluid_times_real operator_real_times_fluid Module Procedures public  function operator_fluid_times_integer (fluid, integer) result(ans) 流体構造体を整数倍するための演算子 Arguments Type Intent Optional Attributes Name type( fluid_t ), intent(in) :: fluid 流体場 integer, intent(in) :: integer かける整数 Return Value type( fluid_t ) public  function operator_integer_times_fluid (integer, fluid) result(ans) 整数に流体構造体を掛け算するための演算子 Arguments Type Intent Optional Attributes Name integer, intent(in) :: integer かける整数 type( fluid_t ), intent(in) :: fluid 流体場 Return Value type( fluid_t ) 計算結果 public  function operator_fluid_times_real (fluid, real) result(ans) 流体構造体を実数倍するための演算子 Arguments Type Intent Optional Attributes Name type( fluid_t ), intent(in) :: fluid 流体場 real(kind=DR), intent(in) :: real かける実数 Return Value type( fluid_t ) 計算結果 public  function operator_real_times_fluid (real, fluid) result(ans) 実数に流体場を掛ける演算子 Arguments Type Intent Optional Attributes Name real(kind=DR), intent(in) :: real 掛ける実数 type( fluid_t ), intent(in) :: fluid 流体場 Return Value type( fluid_t ) 計算結果","tags":"","loc":"interface/operator( ASTERISK ).html"},{"title":"operator( + ) – Smoke Ring","text":"public interface operator( + ) 流体構造体の全要素の足し算を+記号で書けるように定義 Calls interface~~operator( + )~~CallsGraph interface~operator( + ) fluid_m::operator( + ) proc~operator_fluid_add fluid_m::operator_fluid_add interface~operator( + )->proc~operator_fluid_add Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Module Procedures operator_fluid_add Module Procedures public  function operator_fluid_add (a, b) result(ans) 流体構造体の足し算演算子 Arguments Type Intent Optional Attributes Name type( fluid_t ), intent(in) :: a 足し算する2つの流体場 type( fluid_t ), intent(in) :: b 足し算する2つの流体場 Return Value type( fluid_t ) 計算結果","tags":"","loc":"interface/operator( + ).html"},{"title":"operator( .energyintegral. ) – Smoke Ring","text":"public interface operator( .energyintegral. ) 全エネルギーを計算（体積積分）する演算子 Calls interface~~operator( .energyintegral. )~~CallsGraph interface~operator( .energyintegral. ) fluid_m::operator( .energyintegral. ) proc~operator_energyintegral fluid_m::operator_energyintegral interface~operator( .energyintegral. )->proc~operator_energyintegral density density proc~operator_energyintegral->density Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Module Procedures operator_energyintegral Module Procedures public  function operator_energyintegral (a) result(ans) 流体の運動エネルギーの体積積分\n現在のシュミレーションでは格子間隔はx, y, z それぞれに\n一様であることを仮定している。つまりdx, dy, dzは空間位置に\n依存せず一定である。 Read more… Arguments Type Intent Optional Attributes Name type( fluid_t ), intent(in) :: a 流体場 Return Value real(kind=DR) 全エネルギー\n以下のエネルギー密度の式を全空間で体積積分する\nflow_energy = (1/2) * rho * vel&#94;2 = (1/2) * (massflux)&#94;2 / rho","tags":"","loc":"interface/operator( .energyintegral. ).html"},{"title":"job__finalize – Smoke Ring","text":"private  subroutine job__finalize(nloop) このどちらかであれば、 で第2引数の文字列を囲む。 MPI並列化終了処理 Type Bound job_t Arguments Type Intent Optional Attributes Name integer, intent(in) :: nloop ループカウンタ\nジョブ終了時の後始末。\n(1) 健康状態カルテに応じたメッセージを標準出力に書く\n(2) MPI並列化の終了処理 Calls proc~~job__finalize~~CallsGraph proc~job__finalize job_m::job_t%job__finalize finalize finalize proc~job__finalize->finalize ut__deco_message ut__deco_message proc~job__finalize->ut__deco_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Source Code job__finalize Source Code subroutine job__finalize ( nloop ) integer , intent ( in ) :: nloop !! ループカウンタ !! ジョブ終了時の後始末。 !! (1) 健康状態カルテに応じたメッセージを標準出力に書く !! (2) MPI並列化の終了処理 select case ( trim ( job % karte )) case ( \"fine\" , \"loop_max\" ) !! このどちらかであれば、 call ut__deco_message ( \"#\" , \"Successfully finished.\" ) !! # で第2引数の文字列を囲む。 case ( \"time out\" ) call ut__deco_message ( \"-\" , \"Time out at nloop = \" , nloop ) case ( \"overflow\" ) call ut__deco_message ( \"%\" , \"Overflow at nloop = \" , nloop ) case ( \"negative anormaly\" ) call ut__deco_message ( \"%\" , \"Underflow at nloop = \" , nloop ) case default call ut__deco_message ( \"?\" , \"Stopped at nloop = \" , nloop ) end select call Parallel % finalize !! MPI並列化終了処理 end subroutine job__finalize","tags":"","loc":"proc/job__finalize.html"},{"title":"job__initialize – Smoke Ring","text":"private  subroutine job__initialize() MPI並列化初期化処理。Parallel変数はparallel.efで定義\nされている。冒頭のPが大文字なのはこれがグローバル変数\nであることを示唆している。（コンパイラは大文字と小文字を\n区別しないが。） Type Bound job_t Arguments None Calls proc~~job__initialize~~CallsGraph proc~job__initialize job_m::job_t%job__initialize initialize initialize proc~job__initialize->initialize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Source Code job__initialize Source Code subroutine job__initialize call Parallel % initialize !! MPI並列化初期化処理。Parallel変数はparallel.efで定義 !! されている。冒頭のPが大文字なのはこれがグローバル変数 !! であることを示唆している。（コンパイラは大文字と小文字を !! 区別しないが。） end subroutine job__initialize","tags":"","loc":"proc/job__initialize.html"},{"title":"calc_rank_next – Smoke Ring","text":"private  function calc_rank_next(me) result(next) Arguments Type Intent Optional Attributes Name type(mpiut__rank_position_t), intent(in) :: me Return Value type(mpiut__rank_next_t) Calls proc~~calc_rank_next~~CallsGraph proc~calc_rank_next parallel_m::calc_rank_next proc~pos_ijk_to_rank parallel_m::pos_ijk_to_rank proc~calc_rank_next->proc~pos_ijk_to_rank Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~calc_rank_next~~CalledByGraph proc~calc_rank_next parallel_m::calc_rank_next proc~parallel__initialize parallel_m::parallel_t%parallel__initialize proc~parallel__initialize->proc~calc_rank_next Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Source Code calc_rank_next Source Code function calc_rank_next ( me ) result ( next ) type ( mpiut__rank_position_t ), intent ( in ) :: me type ( mpiut__rank_next_t ) :: next integer :: i , j , k i = me % i j = me % j k = me % k next % ip1 = pos_ijk_to_rank ( i + 1 , j , k ) next % im1 = pos_ijk_to_rank ( i - 1 , j , k ) next % jp1 = pos_ijk_to_rank ( i , j + 1 , k ) next % jm1 = pos_ijk_to_rank ( i , j - 1 , k ) next % kp1 = pos_ijk_to_rank ( i , j , k + 1 ) next % km1 = pos_ijk_to_rank ( i , j , k - 1 ) end function calc_rank_next","tags":"","loc":"proc/calc_rank_next.html"},{"title":"parallel__io_clerk – Smoke Ring","text":"private  function parallel__io_clerk(task) result(i_am) Type Bound parallel_t Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: task Return Value logical < Contents Source Code parallel__io_clerk Source Code function parallel__io_clerk ( task ) result ( i_am ) character ( len =* ), intent ( in ), optional :: task logical :: i_am !!> !        Returns the rank number who is in charge of data io. !        We assign different processes for different data, to !        avoid the IO conflicts. You will not need this function !        in future when the parallel IO of MPI2 is implemented !        in this code. This is just for a temporary use till then. !!< integer :: target_rank integer :: nprocs nprocs = Parallel % nprocs if ( . not . present ( task ) ) then target_rank = 0 else select case ( task ) case ( '2d_slice_xy' ) target_rank = mod ( 0 , nprocs ) case ( '2d_slice_yz' ) target_rank = mod ( 1 , nprocs ) case ( '2d_slice_zx' ) target_rank = mod ( 2 , nprocs ) case ( '2d_slice_xy2' ) target_rank = mod ( 3 , nprocs ) case ( '2d_slice_xy3' ) target_rank = mod ( 4 , nprocs ) case ( 'heavy data' ) target_rank = Parallel % nprocs - 1 case default target_rank = 0 end select end if i_am = ( target_rank == Parallel % rank % me ) end function parallel__io_clerk","tags":"","loc":"proc/parallel__io_clerk.html"},{"title":"parallel__rank_to_pos_index – Smoke Ring","text":"private  function parallel__rank_to_pos_index(rank) result(index) Type Bound parallel_t Arguments Type Intent Optional Attributes Name integer, intent(in) :: rank Return Value type(mpiut__rank_position_t) < Calls proc~~parallel__rank_to_pos_index~~CallsGraph proc~parallel__rank_to_pos_index parallel_m::parallel_t%parallel__rank_to_pos_index mpiut__assert mpiut__assert proc~parallel__rank_to_pos_index->mpiut__assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Source Code parallel__rank_to_pos_index Source Code function parallel__rank_to_pos_index ( rank ) result ( index ) integer , intent ( in ) :: rank type ( mpiut__rank_position_t ) :: index !!> !        Returns the process position (i,j,k) for the rank. !!< call mpiut__assert ( rank >= 0 , & 'parallel_m/parallel__rank_to_pos_index: negative rank.' ) call mpiut__assert ( rank < NPROC_X * NPROC_Y * NPROC_Z , & 'parallel_m/parallel__rank_to_pos_index: rank out of range.' ) index % k = rank / ( NPROC_X * NPROC_Y ) index % j = mod ( rank , NPROC_X * NPROC_Y ) / NPROC_X index % i = mod ( rank , NPROC_X ) end function parallel__rank_to_pos_index","tags":"","loc":"proc/parallel__rank_to_pos_index.html"},{"title":"pos_ijk_to_rank – Smoke Ring","text":"private  function pos_ijk_to_rank(i, j, k) Arguments Type Intent Optional Attributes Name integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: k Return Value integer < Called by proc~~pos_ijk_to_rank~~CalledByGraph proc~pos_ijk_to_rank parallel_m::pos_ijk_to_rank proc~calc_rank_next parallel_m::calc_rank_next proc~calc_rank_next->proc~pos_ijk_to_rank proc~parallel__initialize parallel_m::parallel_t%parallel__initialize proc~parallel__initialize->proc~calc_rank_next Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Source Code pos_ijk_to_rank Source Code function pos_ijk_to_rank ( i , j , k ) integer , intent ( in ) :: i , j , k integer :: pos_ijk_to_rank !!> !       Purpose: Returns rank number for the divided region at i,j,k. !        Author: Akira Kageyama !          Date: 2013.06.13 (revised) !!< if ( i < 0 . or . i >= NPROC_X & . or . & j < 0 . or . j >= NPROC_Y & . or . & k < 0 . or . k >= NPROC_Z ) then pos_ijk_to_rank = MPI_PROC_NULL else pos_ijk_to_rank = i + j * NPROC_X + k * NPROC_X * NPROC_Y end if end function pos_ijk_to_rank","tags":"","loc":"proc/pos_ijk_to_rank.html"},{"title":"parallel__finalize – Smoke Ring","text":"private  subroutine parallel__finalize() Type Bound parallel_t Arguments None Calls proc~~parallel__finalize~~CallsGraph proc~parallel__finalize parallel_m::parallel_t%parallel__finalize mpiut__finalize mpiut__finalize proc~parallel__finalize->mpiut__finalize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Source Code parallel__finalize Source Code subroutine parallel__finalize call mpiut__finalize end subroutine parallel__finalize","tags":"","loc":"proc/parallel__finalize.html"},{"title":"parallel__initialize – Smoke Ring","text":"private  subroutine parallel__initialize() < Type Bound parallel_t Arguments None Calls proc~~parallel__initialize~~CallsGraph proc~parallel__initialize parallel_m::parallel_t%parallel__initialize mpiut__assert mpiut__assert proc~parallel__initialize->mpiut__assert mpiut__barrier mpiut__barrier proc~parallel__initialize->mpiut__barrier mpiut__comm_rank mpiut__comm_rank proc~parallel__initialize->mpiut__comm_rank mpiut__comm_size mpiut__comm_size proc~parallel__initialize->mpiut__comm_size mpiut__init mpiut__init proc~parallel__initialize->mpiut__init proc~calc_rank_next parallel_m::calc_rank_next proc~parallel__initialize->proc~calc_rank_next rank_to_pos_index rank_to_pos_index proc~parallel__initialize->rank_to_pos_index ut__i2c3 ut__i2c3 proc~parallel__initialize->ut__i2c3 proc~pos_ijk_to_rank parallel_m::pos_ijk_to_rank proc~calc_rank_next->proc~pos_ijk_to_rank Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Source Code parallel__initialize Source Code subroutine parallel__initialize !!> !    The following is the process allocation map. We do !    not use the automatic allocation by MPI_Carte_create. ! !               /     /     /     /     /| !              /  12 / 13  / 14  / 15  / | !             /-----/-----/-----/-----/  |           k !            /     /     /     /     /|  /          / !           /     /     /     /     / | /|         / !          +-----+-----+-----+-----+  |/ |        +------ i !    N     |     |     |     |     |  /  |        | !    P     |  0  |  1  |  2  |  3  | /|  /        | !    R     |     |     |     |     |/ | /|        | !    O = 3 +-----+-----+-----+-----+  |/ |        | !    C     |     |     |     |     |  /  |         j !          |  4  |  5  |  6  |  7  | /|  / !    Y     |     |     |     |     |/ | / !          +-----+-----+-----+-----+  |/ !          |     |     |     |     |  / !          |  8  |  9  | 10  | 11  | / !          |     |     |     |     |/pos.index.k = rank / (mx*my) !          +-----+-----+-----+-----+ pos.index.j = mod(rank,mx*my)/mx !                                    pos.index.i = mod(rank,mx) !                  NPROC_X = 4 !!< integer :: me , nprocs , comm call mpiut__init ! No OpenMP ! call mpiut__init( MPI_THREAD_MULTIPLE ) comm = MPI_COMM_WORLD me = mpiut__comm_rank ( comm ) nprocs = mpiut__comm_size ( comm ) call mpiut__assert ( nprocs == NPROC_X * NPROC_Y * NPROC_Z , & 'parallel_m/parallel__initialize: nprocs inconsistent.' ) Parallel % comm = comm Parallel % nprocs = nprocs Parallel % rank % me = me Parallel % pos % index = Parallel % rank_to_pos_index ( me ) Parallel % rank % next = calc_rank_next ( Parallel % pos % index ) ! Sample: \"p012_035_064\" Parallel % pos % string = \"p\" & ! 1 letter // ut__i2c3 ( Parallel % pos % index % i ) & ! 3 letters // '_' & ! 1 letter // ut__i2c3 ( Parallel % pos % index % j ) & ! 3 letters // '_' & ! 1 letter // ut__i2c3 ( Parallel % pos % index % k ) ! 3 letters associate ( periodic_pair => Parallel % periodic_pair , & pos_index => Parallel % pos % index , & have_xmax => Parallel % i_have_xmax , & have_xmin => Parallel % i_have_xmin , & have_ymax => Parallel % i_have_ymax , & have_ymin => Parallel % i_have_ymin , & have_zmax => Parallel % i_have_zmax , & have_zmin => Parallel % i_have_zmin ) periodic_pair % ip1 = MPI_PROC_NULL ! Default values. periodic_pair % im1 = MPI_PROC_NULL ! These will be periodic_pair % jp1 = MPI_PROC_NULL ! overwritten. periodic_pair % jm1 = MPI_PROC_NULL periodic_pair % kp1 = MPI_PROC_NULL periodic_pair % km1 = MPI_PROC_NULL have_xmax = . false . ! Default values. have_xmin = . false . ! These will be have_ymax = . false . ! overwritten. have_ymin = . false . have_zmax = . false . have_zmin = . false . if ( pos_index % i == NPROC_X - 1 ) have_xmax = . true . if ( pos_index % i == 0 ) have_xmin = . true . if ( pos_index % j == NPROC_Y - 1 ) have_ymax = . true . if ( pos_index % j == 0 ) have_ymin = . true . if ( pos_index % k == NPROC_Z - 1 ) have_zmax = . true . if ( pos_index % k == 0 ) have_zmin = . true . if ( have_xmax ) periodic_pair % ip1 = me - NPROC_X + 1 if ( have_xmin ) periodic_pair % im1 = me + NPROC_X - 1 if ( have_ymax ) periodic_pair % jp1 = me - NPROC_X * ( NPROC_Y - 1 ) if ( have_ymin ) periodic_pair % jm1 = me + NPROC_X * ( NPROC_Y - 1 ) if ( have_zmax ) periodic_pair % kp1 = me - NPROC_X * NPROC_Y * ( NPROC_Z - 1 ) if ( have_zmin ) periodic_pair % km1 = me + NPROC_X * NPROC_Y * ( NPROC_Z - 1 ) end associate call iPrint call mpiut__barrier ( comm ) contains subroutine iPrint call mpiut__message_leader ( comm , & 'parallel_m: comm' , & Parallel % comm ) call mpiut__message_leader ( comm , & 'parallel_m: nprocs' , & Parallel % nprocs ) call mpiut__message_leader ( comm , & 'parallel_m: rank.me' , & Parallel % rank % me ) call mpiut__message_leader ( comm , & 'parallel_m: pos.index.i' , & Parallel % pos % index % i ) call mpiut__message_leader ( comm , & 'parallel_m: pos.index.j' , & Parallel % pos % index % j ) call mpiut__message_leader ( comm , & 'parallel_m: pos.index.k' , & Parallel % pos % index % k ) call mpiut__message_leader ( comm , & 'parallel_m: pos.string' , & Parallel % pos % string ) call mpiut__message_leader ( comm , & 'parallel_m: rank.next.ip1' , & Parallel % rank % next % ip1 ) call mpiut__message_leader ( comm , & 'parallel_m: rank.next.im1' , & Parallel % rank % next % im1 ) call mpiut__message_leader ( comm , & 'parallel_m: rank.next.jp1' , & Parallel % rank % next % jp1 ) call mpiut__message_leader ( comm , & 'parallel_m: rank.next.jm1' , & Parallel % rank % next % jm1 ) call mpiut__message_leader ( comm , & 'parallel_m: rank.next.kp1' , & Parallel % rank % next % kp1 ) call mpiut__message_leader ( comm , & 'parallel_m: rank.next.km1' , & Parallel % rank % next % km1 ) call mpiut__message_leader ( comm , & 'parallel_m: have_xmax' , & Parallel % i_have_xmax ) call mpiut__message_leader ( comm , & 'parallel_m: have_xmin' , & Parallel % i_have_xmin ) call mpiut__message_leader ( comm , & 'parallel_m: have_ymax' , & Parallel % i_have_ymax ) call mpiut__message_leader ( comm , & 'parallel_m: have_ymin' , & Parallel % i_have_ymin ) call mpiut__message_leader ( comm , & 'parallel_m: have_zmax' , & Parallel % i_have_zmax ) call mpiut__message_leader ( comm , & 'parallel_m: have_zmin' , & Parallel % i_have_zmin ) call mpiut__message_leader ( comm , & 'parallel_m: periodic_pair.ip1' , & Parallel % periodic_pair % ip1 ) call mpiut__message_leader ( comm , & 'parallel_m: periodic_pair.im1' , & Parallel % periodic_pair % im1 ) call mpiut__message_leader ( comm , & 'parallel_m: periodic_pair.jp1' , & Parallel % periodic_pair % jp1 ) call mpiut__message_leader ( comm , & 'parallel_m: periodic_pair.jm1' , & Parallel % periodic_pair % jm1 ) call mpiut__message_leader ( comm , & 'parallel_m: periodic_pair.kp1' , & Parallel % periodic_pair % kp1 ) call mpiut__message_leader ( comm , & 'parallel_m: periodic_pair.km1' , & Parallel % periodic_pair % km1 ) end subroutine iPrint end subroutine parallel__initialize","tags":"","loc":"proc/parallel__initialize.html"},{"title":"params__get_double – Smoke Ring","text":"private  function params__get_double(variable) Type Bound params_t Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: variable 問い合わせ変数の名前 Return Value real(kind=DR) その値\nこのモジュールの外からの問い合わせに応じてnamelistデータを返す。\nこの関数は問い合わせ変数が倍精度浮動小数点数の場合。\nこの関数の前にnamelist__readが呼ばれている必要がある。\nこの点はassertで確認している。 Calls proc~~params__get_double~~CallsGraph proc~params__get_double params_m::params_t%params__get_double ut__assert ut__assert proc~params__get_double->ut__assert ut__fatal ut__fatal proc~params__get_double->ut__fatal ut__message ut__message proc~params__get_double->ut__message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Source Code params__get_double Source Code function params__get_double ( variable ) character ( len =* ), intent ( in ) :: variable !! 問い合わせ変数の名前 real ( DR ) :: params__get_double !! その値 !! このモジュールの外からの問い合わせに応じてnamelistデータを返す。 !! この関数は問い合わせ変数が倍精度浮動小数点数の場合。 !! この関数の前にnamelist__readが呼ばれている必要がある。 !! この点はassertで確認している。 call ut__assert ( Read_done , & 'params_m(__LINE):  Read params file first.' ) select case ( variable ) case ( 'Kappa' ) ! 熱拡散率 params__get_double = Kappa case ( 'Viscosity' ) ! 粘性率 params__get_double = Viscosity case default ! そんなnamelist変数は想定外 call ut__message ( '? arg = ' , variable ) call ut__fatal ( 'params_m(90): case error.' ) end select end function params__get_double","tags":"","loc":"proc/params__get_double.html"},{"title":"params__get_integer – Smoke Ring","text":"private  function params__get_integer(variable) Type Bound params_t Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: variable 問い合わせ変数の名前 Return Value integer その値\nこのモジュールの外からの問い合わせに応じてnamelistデータを返す。\nこの関数は問い合わせ変数が整数の場合。\nこの関数の前にnamelist__readが呼ばれている必要がある。\nこの点はassertで確認している。 Calls proc~~params__get_integer~~CallsGraph proc~params__get_integer params_m::params_t%params__get_integer ut__assert ut__assert proc~params__get_integer->ut__assert ut__fatal ut__fatal proc~params__get_integer->ut__fatal ut__message ut__message proc~params__get_integer->ut__message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Source Code params__get_integer Source Code function params__get_integer ( variable ) character ( len =* ), intent ( in ) :: variable !! 問い合わせ変数の名前 integer :: params__get_integer !! その値 !! このモジュールの外からの問い合わせに応じてnamelistデータを返す。 !! この関数は問い合わせ変数が整数の場合。 !! この関数の前にnamelist__readが呼ばれている必要がある。 !! この点はassertで確認している。 call ut__assert ( Read_done , & 'params_m(104): Read params file first.' ) select case ( variable ) case ( 'Slicedata_nskip' ) ! 何ステップごとに params__get_integer = Slicedata_nskip ! 断面をディスクに書き出すか case ( 'Total_nloop' ) ! シミュレーションジョブ params__get_integer = Total_nloop ! の実行最大ループ数 case default ! 想定外 call ut__message ( '? arg = ' , variable ) call ut__fatal ( 'params_m(113): case error.' ) end select end function params__get_integer","tags":"","loc":"proc/params__get_integer.html"},{"title":"params__get_logical – Smoke Ring","text":"private  function params__get_logical(variable) Type Bound params_t Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: variable 問い合わせ変数の名前 Return Value logical その値\nこのモジュールの外からの問い合わせに応じてnamelistデータを返す。\nこの関数は問い合わせ変数が論理値の場合。\nこの関数の前にnamelist__readが呼ばれている必要がある。\nこの点はassertで確認している。 Calls proc~~params__get_logical~~CallsGraph proc~params__get_logical params_m::params_t%params__get_logical ut__assert ut__assert proc~params__get_logical->ut__assert ut__fatal ut__fatal proc~params__get_logical->ut__fatal ut__message ut__message proc~params__get_logical->ut__message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Source Code params__get_logical Source Code function params__get_logical ( variable ) character ( len =* ), intent ( in ) :: variable !! 問い合わせ変数の名前 logical :: params__get_logical !! その値 !! このモジュールの外からの問い合わせに応じてnamelistデータを返す。 !! この関数は問い合わせ変数が論理値の場合。 !! この関数の前にnamelist__readが呼ばれている必要がある。 !! この点はassertで確認している。 call ut__assert ( Read_done , & 'params_m(127): Read params file first.' ) select case ( variable ) case default ! 想定外 call ut__message ( '? arg = ' , variable ) call ut__fatal ( 'params_m(132): case error.' ) end select end function params__get_logical","tags":"","loc":"proc/params__get_logical.html"},{"title":"params__get_string – Smoke Ring","text":"private  function params__get_string(variable) Type Bound params_t Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: variable 問い合わせ変数の名前 Return Value character(len=STRING_LENGTH_MAX) その値\nこのモジュールの外からの問い合わせに応じてnamelistデータを返す。\nこの関数は問い合わせ変数が文字列の場合。\nこの関数の前にnamelist__readが呼ばれている必要がある。\nこの点はassertで確認している。 Calls proc~~params__get_string~~CallsGraph proc~params__get_string params_m::params_t%params__get_string ut__assert ut__assert proc~params__get_string->ut__assert ut__fatal ut__fatal proc~params__get_string->ut__fatal ut__message ut__message proc~params__get_string->ut__message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Source Code params__get_string Source Code function params__get_string ( variable ) character ( len =* ), intent ( in ) :: variable !! 問い合わせ変数の名前 character ( len = STRING_LENGTH_MAX ) :: params__get_string !! その値 !! このモジュールの外からの問い合わせに応じてnamelistデータを返す。 !! この関数は問い合わせ変数が文字列の場合。 !! この関数の前にnamelist__readが呼ばれている必要がある。 !! この点はassertで確認している。 call ut__assert ( Read_done , & 'params_m(180): Read params file first.' ) select case ( variable ) case ( 'Slicedata_tag' ) ! 断面ファイル名に使う params__get_string = Slicedata_tag case default call ut__message ( '? arg = ' , variable ) ! 想定外 call ut__fatal ( 'params_m(187): case error.' ) end select end function params__get_string","tags":"","loc":"proc/params__get_string.html"},{"title":"params__read – Smoke Ring","text":"private  subroutine params__read() namelistファイルをディスクから読み込む。\n ファイル名はコマンド第一引数。 namelistデータファイルの内容を変更する場合は\n 以下のread文も適宜変更する。 * * * &simulation      Total_nloop = 2000 /\n &visualization   Slicedata_nskip  = 100, Slicedata_tag = '_data_slice' /\n &fluid_property  Viscosity = 3.0e-2, Kappa = 3.e-2 / * * * Type Bound params_t Arguments None Calls proc~~params__read~~CallsGraph proc~params__read params_m::params_t%params__read ut__assert ut__assert proc~params__read->ut__assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Source Code params__read Source Code subroutine params__read !! namelistファイルをディスクから読み込む。 !! ファイル名はコマンド第一引数。 !! !! namelistデータファイルの内容を変更する場合は !! 以下のread文も適宜変更する。 !! character ( len = STRING_LENGTH_MAX ) :: params_file integer :: file_unit call ut__assert ( command_argument_count () == 1 , & \"params_m(148): Usage: smoke_ring param_file\" ) call get_command_argument ( 1 , params_file ) !*******<params_file のサンプル>********* ! &simulation      Total_nloop = 2000 / ! &visualization   Slicedata_nskip  = 100, Slicedata_tag = '_data_slice' / ! &fluid_property  Viscosity = 3.0e-2, Kappa = 3.e-2 / !*******</params_file のサンプル>********* open ( newunit = file_unit , file = trim ( params_file )) read ( file_unit , nml = simulation ) read ( file_unit , nml = visualization ) read ( file_unit , nml = fluid_property ) close ( file_unit ) write ( output_unit , nml = simulation ) write ( output_unit , nml = visualization ) write ( output_unit , nml = fluid_property ) Read_done = . true . end subroutine params__read","tags":"","loc":"proc/params__read.html"},{"title":"drive_force_factor – Smoke Ring","text":"private  function drive_force_factor(time) 渦輪を駆動する力の時間変化の調整のための係数設定 Note この係数は0以上1以下。これはassertで確認している。 この関係は以下の前提なのでアサートで確認しておく 上のコメント図の時間依存係数 Arguments Type Intent Optional Attributes Name real(kind=DR), intent(in) :: time シミュレーション時刻 Return Value real(kind=DR) 力の強さ係数 0から1 < Calls proc~~drive_force_factor~~CallsGraph proc~drive_force_factor solver_m::drive_force_factor ut__assert ut__assert proc~drive_force_factor->ut__assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~drive_force_factor~~CalledByGraph proc~drive_force_factor solver_m::drive_force_factor proc~the_equation solver_m::the_equation proc~the_equation->proc~drive_force_factor proc~solver__advance solver_m::solver_t%solver__advance proc~solver__advance->proc~the_equation Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Source Code drive_force_factor Source Code function drive_force_factor ( time ) !! 渦輪を駆動する力の時間変化の調整のための係数設定 !! !! @note この係数は0以上1以下。これはassertで確認している。 !! real ( DR ), intent ( in ) :: time !! シミュレーション時刻 real ( DR ) :: drive_force_factor !! 力の強さ係数 0から1 !!> !                                           factor !                   ___________               | !                  /|         |\\              | !           ______/ |         | \\______       +--------> time !                 | |         |  | !                 | |         |  | !                 | t0        t1 | !               t_start         t_end !!< real ( DR ), parameter :: T_START = 0.0_DR !! 力をかけ始める時刻 real ( DR ), parameter :: T_END = 0.01_DR !! 力をかけ終わる時刻 !! 試行錯誤で調整せよ real ( DR ), parameter :: T0 = T_START + ( T_END - T_START ) / 4 real ( DR ), parameter :: T1 = T_END - ( T_END - T_START ) / 4 !! 上のコメント図をみよ !! これも試行錯誤で調整せよ real ( DR ), parameter :: ONE = 1.0_DR !! コードの読みやすさのため定義 real ( DR ), parameter :: ZERO = 0.0_DR !! コードの読みやすさのため定義 call ut__assert ( T_START < T0 . and . T0 < T1 . and . T1 < T_END , & \"solver_m(121): Time inconsistent.\" ) !! この関係は以下の前提なのでアサートで確認しておく !! 上のコメント図の時間依存係数 if ( time <= T_START ) then drive_force_factor = ZERO else if ( time <= T0 ) then drive_force_factor = ( time - T_START ) / ( T0 - T_START ) else if ( time <= T1 ) then drive_force_factor = ONE else if ( time <= T_END ) then drive_force_factor = ONE - ( time - T1 ) / ( T_END - T1 ) else drive_force_factor = ZERO end if call ut__assert ( drive_force_factor >= 0.0_DR . and . & drive_force_factor <= 1.0_DR , & \"solver_m(139): strange value.\" ) end function drive_force_factor","tags":"","loc":"proc/drive_force_factor.html"},{"title":"solver__set_time_step – Smoke Ring","text":"private  function solver__set_time_step(nloop, fluid) CFL条件に基づいて時間刻み幅dtを設定する\n初期化忘れ確認 基本流体データから速度場と温度場を計算 速度の最大値（ベクトルの長さの最大値）をもとめる\nここでは配列演算を駆使して1行で書いているが\n実際にはかなりの演算をしていることに注意。\nこれはバグではないが、maxvalとsqrtは交換すべき\nだろう。このままだと3次元配列の全要素にsqrt\nを掛けてからそのmaxvalをとっているが、これを\n逆にした方が速いかもしれない。 初期条件では速度場がゼロなのでvmax=0となるが、あとで\nvmaxの割り算が出てくるので問題となる。それを回避するため\nALMOST_ZEROが十分小さければよい。 音速の最大値\nこれも上と同じ理屈で、maxvalとsqrtは交換すべき\nだろう。このままだと3次元配列の全要素にsqrt\nを掛けてからそのmaxvalをとっているが、これを\n逆にした方が速いかもしれない。 音速（の最大値）がほとんどゼロになるのは\n何かがおかしいのですぐに停止 以下では、流れの速さ、音波、粘性拡散、熱拡散の4種類の\nCFL条件で決まる時間刻み幅をそれぞれこの順番に求めている。\nCFL factor はここでは0.8と0.2にしているが、\nこれは精密な議論に基づいて決めたものではなく、\n半経験的に決めた値である。\n最後の2つ、粘性拡散と熱拡散によるCFL条件のための\nCFL factor の値 (0.2) というのは少々安全側に設定\nしすぎているかもしれない。つまりもう少し大きくしても\n問題ないかもしれない。 最終的な時間刻み幅は上記の4種類のdtの最小値できまる。 すべてのプロセスでの最小値をとる 出力が長くなるが、流体の状態を推測するのに便利なデータ。\nSKIPをさらに10倍しているのは、それほど頻繁に出力する\n必要は通常ないからである。\nSKIPに一度dtを計算し直すが、それ以外は下の行を見れば分かる通り\n前回のdtの値を流用する。その際、一度もdtを計算したことがなかったら\nまずいのでその検出をANOMALOUS_VALUEを使って検出している。 dt of the prev calc is saved.\n新たに更新（または前回計算した）dtを返す。 Type Bound solver_t Arguments Type Intent Optional Attributes Name integer, intent(in) :: nloop ループカウンタ type( fluid_t ), intent(in) :: fluid 流体データ Return Value real(kind=DR) 時間刻み幅 dt Calls proc~~solver__set_time_step~~CallsGraph proc~solver__set_time_step solver_m::solver_t%solver__set_time_step mpiut__message_leader mpiut__message_leader proc~solver__set_time_step->mpiut__message_leader mpiut__minval mpiut__minval proc~solver__set_time_step->mpiut__minval proc~subfield_vel_tm solver_m::solver_t%subfield_vel_tm proc~solver__set_time_step->proc~subfield_vel_tm ut__assert ut__assert proc~solver__set_time_step->ut__assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Source Code solver__set_time_step Source Code function solver__set_time_step ( nloop , fluid ) !! CFL条件に基づいて時間刻み幅dtを設定する integer , intent ( in ) :: nloop !! ループカウンタ type ( fluid_t ), intent ( in ) :: fluid !! 流体データ real ( DR ) :: solver__set_time_step !! 時間刻み幅 dt type ( field__vector_t ) :: vel !! 速度場 real ( DR ), dimension ( 0 : NXPP1 , 0 : NYPP1 , 0 : NZPP1 ) :: tm !! 温度場 real ( DR ) :: vmax , sound_v !! 流れ速度の最大値と音速 real ( DR ) :: dt_vel , dt_sound , dt_viscous , dt_kappa !! 流れ速度、音波、粘性拡散、熱拡散、それぞれで決まる時間刻み幅 !! 実際のdtはこれらのなかで最も厳しい（小さい）値できまる。 real ( DR ), parameter :: ALMOST_ZERO = 1.e-20_DR !! ゼロ割り演算回避のために使う小さい値 real ( DR ), parameter :: ANOMALOUS_VALUE = - 99 9.999_DR !! dtとしてありそうにない値（すぐ下で使う） real ( DR ) :: dt_local !! 各MPIプロセスで計算した時間刻み幅 real ( DR ), save :: dt_global = ANOMALOUS_VALUE !! 時間刻み幅。全プロセスの最小値。 !! 初期設定でなんらかの失敗した場合を検出するため !! 最初はありそうない値を設定しておくが、 !! CFL条件に基づいて正しい値を一度設定したらその後は !! この宣言文にはsave属性がついているので、 !! この関数を抜けたあともその値を覚えている。 integer , parameter :: SKIP = 20 !! dtを毎ステップ計算するのは大変（かなりの時間がかかる） !! のでこのSKIPステップに一度だけ計算する。毎ステップ計算する !! してもdtは1ステップでそれほど大きく変化しないからである。 !! ただし、計算が破綻（発散）するような場合は例外である。 call ut__assert ( Initialize_done , & \"solver_m(682): Forgot init?\" ) !! 初期化忘れ確認 if ( mod ( nloop , SKIP ) == 0 ) then ! ほとんどの場合は、前回計算したdtを使う。 call subfield_vel_tm ( fluid , vel , tm ) !! 基本流体データから速度場と温度場を計算 vmax = maxval ( sqrt ( vel % x ** 2 + vel % y ** 2 + vel % z ** 2 )) !! 速度の最大値（ベクトルの長さの最大値）をもとめる !! ここでは配列演算を駆使して1行で書いているが !! 実際にはかなりの演算をしていることに注意。 !! これはバグではないが、maxvalとsqrtは交換すべき !! だろう。このままだと3次元配列の全要素にsqrt !! を掛けてからそのmaxvalをとっているが、これを !! 逆にした方が速いかもしれない。 vmax = max ( vmax , ALMOST_ZERO ) !! 初期条件では速度場がゼロなのでvmax=0となるが、あとで !! vmaxの割り算が出てくるので問題となる。それを回避するため !! ALMOST_ZEROが十分小さければよい。 sound_v = GAMMA * maxval ( sqrt ( GASS_CONST_FOR_AIR * tm )) !! 音速の最大値 !! これも上と同じ理屈で、maxvalとsqrtは交換すべき !! だろう。このままだと3次元配列の全要素にsqrt !! を掛けてからそのmaxvalをとっているが、これを !! 逆にした方が速いかもしれない。 call ut__assert ( sound_v > ALMOST_ZERO , & \"solver_m(711): sound_v=0?\" ) !! 音速（の最大値）がほとんどゼロになるのは !! 何かがおかしいのですぐに停止 !! 以下では、流れの速さ、音波、粘性拡散、熱拡散の4種類の !! CFL条件で決まる時間刻み幅をそれぞれこの順番に求めている。 dt_vel = 0.8_DR * grid % delta_min / vmax dt_sound = 0.8_DR * grid % delta_min / sound_v dt_viscous = 0.2_DR * ( grid % delta_min ** 2 ) / Viscosity dt_kappa = 0.2_DR * ( grid % delta_min ** 2 ) / Gamma1_kappa !! CFL factor はここでは0.8と0.2にしているが、 !! これは精密な議論に基づいて決めたものではなく、 !! 半経験的に決めた値である。 !! 最後の2つ、粘性拡散と熱拡散によるCFL条件のための !! CFL factor の値 (0.2) というのは少々安全側に設定 !! しすぎているかもしれない。つまりもう少し大きくしても !! 問題ないかもしれない。 dt_local = min ( dt_vel , dt_sound , dt_viscous , dt_kappa ) !! 最終的な時間刻み幅は上記の4種類のdtの最小値できまる。 call mpiut__minval ( Parallel % comm , dt_local , dt_global ) !! すべてのプロセスでの最小値をとる if ( mod ( nloop , SKIP * 100 ) == 0 ) then !! 出力が長くなるが、流体の状態を推測するのに便利なデータ。 !! SKIPをさらに10倍しているのは、それほど頻繁に出力する !! 必要は通常ないからである。 associate ( comm => Parallel % comm ) call mpiut__message_leader ( comm , '     nloop' , nloop ) call mpiut__message_leader ( comm , '      vmax' , vmax ) call mpiut__message_leader ( comm , '    dt_vel' , dt_vel ) call mpiut__message_leader ( comm , '  dt_sound' , dt_sound ) call mpiut__message_leader ( comm , '  dt_kappa' , dt_kappa ) call mpiut__message_leader ( comm , 'dt_viscous' , dt_viscous ) call mpiut__message_leader ( comm , '    --> dt' , dt_global ) end associate end if end if call ut__assert ( dt_global /= ANOMALOUS_VALUE , & \"solver_m(752): dt init failed?\" ) !! SKIPに一度dtを計算し直すが、それ以外は下の行を見れば分かる通り !! 前回のdtの値を流用する。その際、一度もdtを計算したことがなかったら !! まずいのでその検出をANOMALOUS_VALUEを使って検出している。 solver__set_time_step = dt_global !! dt of the prev calc is saved. !! 新たに更新（または前回計算した）dtを返す。 end function solver__set_time_step","tags":"","loc":"proc/solver__set_time_step.html"},{"title":"the_equation – Smoke Ring","text":"private  function the_equation(t, dt, vx, vy, vz, tm, divv, fx, fy, fz, ps) ナビエ・ストークス方程式の右辺（時間変化量）dtを掛けたものを計算 Note 粘性による加熱の効果は小さいので無視している。\n   この項を入れる場合は圧力の方程式\n   the_equation.pressure に追加すればよい。\n初期化忘れしていないか確認 渦輪の駆動力はシミュレーション開始直後だけかける。\nその後は何も力をかけない（渦輪が自然に発生し、リング上の\n構造が移動していく。）つまりこのfactorはシミュレーション\n開始直後だけ非ゼロで、残りの殆どの時間はゼロが入っている。 以下のdo loopがこのシミュレーションで最も時間のかかる\n部分である。したがってここでは.div.などのユーザ定義\n演算子は（コンパイラがその使用を許したとしても）あえて\n使わず、泥臭く書いている。これは将来、\n速度向上のためにコードの最適化をしたり、\nOpenMP化することを見越してのことである。\n以下のコメントでは P 圧力\nV 速度場ベクトル\nF 質量フラックスベクトル\nT 温度 grad P\ngrad (div V) の3成分\nVFテンソルの発散 div(VF) の3成分\nLaplacin V の3成分\nLaplacin T \ndiv F \n以下がナビエ・ストークス方程式 密度の時間発展\n 質量フラックスの時間発展（3成分）\n 圧力の時間発展\n境界条件の設定（周期境界条件）\n上のdo loopは境界面上の格子点を除いた格子点（シミュレーション\n領域の内部の格子点）上での値を計算するものであった。\nここで境界面上の格子点の値の（更新されたばかりの）内部の\n格子点上のデータをコピーすることで設定する。 Arguments Type Intent Optional Attributes Name real(kind=DR), intent(in) :: t 時刻と時間刻み幅 real(kind=DR), intent(in) :: dt 時刻と時間刻み幅 real(kind=DR), intent(in), dimension(0:NXPP1,0:NYPP1,0:NZPP1) :: vx 速度3成分 real(kind=DR), intent(in), dimension(0:NXPP1,0:NYPP1,0:NZPP1) :: vy 速度3成分 real(kind=DR), intent(in), dimension(0:NXPP1,0:NYPP1,0:NZPP1) :: vz 速度3成分 real(kind=DR), intent(in), dimension(0:NXPP1,0:NYPP1,0:NZPP1) :: tm 温度と速度の発散 real(kind=DR), intent(in), dimension(0:NXPP1,0:NYPP1,0:NZPP1) :: divv 温度と速度の発散 real(kind=DR), intent(in), dimension(0:NXPP1,0:NYPP1,0:NZPP1) :: fx 質量フラックス real(kind=DR), intent(in), dimension(0:NXPP1,0:NYPP1,0:NZPP1) :: fy 質量フラックス real(kind=DR), intent(in), dimension(0:NXPP1,0:NYPP1,0:NZPP1) :: fz 質量フラックス real(kind=DR), intent(in), dimension(0:NXPP1,0:NYPP1,0:NZPP1) :: ps 圧力 Return Value type( fluid_t ) 時間刻みdtでの流体データの微小変化量 Calls proc~~the_equation~~CallsGraph proc~the_equation solver_m::the_equation proc~drive_force_factor solver_m::drive_force_factor proc~the_equation->proc~drive_force_factor set_boundary_condition set_boundary_condition proc~the_equation->set_boundary_condition ut__assert ut__assert proc~the_equation->ut__assert x x proc~the_equation->x y y proc~the_equation->y z z proc~the_equation->z proc~drive_force_factor->ut__assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~the_equation~~CalledByGraph proc~the_equation solver_m::the_equation proc~solver__advance solver_m::solver_t%solver__advance proc~solver__advance->proc~the_equation Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Source Code the_equation Source Code function the_equation ( t , dt , vx , vy , vz , tm , divv , fx , fy , fz , ps ) !! ナビエ・ストークス方程式の右辺（時間変化量）dtを掛けたものを計算 !! !! @note !!    粘性による加熱の効果は小さいので無視している。 !!    この項を入れる場合は圧力の方程式 !!    the_equation.pressure に追加すればよい。 real ( DR ), intent ( in ) :: t , dt !! 時刻と時間刻み幅 real ( DR ), dimension ( 0 : NXPP1 , 0 : NYPP1 , 0 : NZPP1 ), intent ( in ) :: vx , vy , vz !! 速度3成分 real ( DR ), dimension ( 0 : NXPP1 , 0 : NYPP1 , 0 : NZPP1 ), intent ( in ) :: tm , divv !! 温度と速度の発散 real ( DR ), dimension ( 0 : NXPP1 , 0 : NYPP1 , 0 : NZPP1 ), intent ( in ) :: fx , fy , fz !! 質量フラックス real ( DR ), dimension ( 0 : NXPP1 , 0 : NYPP1 , 0 : NZPP1 ), intent ( in ) :: ps !! 圧力 type ( fluid_t ) :: the_equation !! 時間刻みdtでの流体データの微小変化量 integer :: i , j , k real ( DR ), parameter :: ONE_THIRD = 1.0_DR / 3.0_DR !! 演算回数節約のため real ( DR ) :: gradpx , gradpy , gradpz !! 圧力の勾配 (gradient p) real ( DR ) :: gdivvx , gdivvy , gdivvz !! 速度の発散の勾配 real ( DR ) :: divfvx , divfvy , divfvz !! 速度・密度フラックステンソルの発散 real ( DR ) :: lapvx , lapvy , lapvz , laptm !! 速度と温度のラプラシアン real ( DR ) :: divf !! 質量フラックスの発散 real ( DR ) :: factor !! 渦輪駆動力の係数（時間依存） call ut__assert ( Initialize_done , & \"solver_m(275): Forgot init?\" ) !! 初期化忘れしていないか確認 factor = drive_force_factor ( t ) !! 渦輪の駆動力はシミュレーション開始直後だけかける。 !! その後は何も力をかけない（渦輪が自然に発生し、リング上の !! 構造が移動していく。）つまりこのfactorはシミュレーション !! 開始直後だけ非ゼロで、残りの殆どの時間はゼロが入っている。 !! 以下のdo loopがこのシミュレーションで最も時間のかかる !! 部分である。したがってここでは.div.などのユーザ定義 !! 演算子は（コンパイラがその使用を許したとしても）あえて !! 使わず、泥臭く書いている。これは将来、 !! 速度向上のためにコードの最適化をしたり、 !! OpenMP化することを見越してのことである。 do k = 1 , NZPP do j = 1 , NYPP do i = 1 , NXPP !! 以下のコメントでは !! P 圧力 !! V 速度場ベクトル !! F 質量フラックスベクトル !! T 温度 !! grad P gradpx = ( ps ( i + 1 , j , k ) - ps ( i - 1 , j , k ) ) * grid % d1 % x gradpy = ( ps ( i , j + 1 , k ) - ps ( i , j - 1 , k ) ) * grid % d1 % y gradpz = ( ps ( i , j , k + 1 ) - ps ( i , j , k - 1 ) ) * grid % d1 % z !! grad (div V) の3成分 gdivvx = ( divv ( i + 1 , j , k ) - divv ( i - 1 , j , k ) ) * grid % d1 % x gdivvy = ( divv ( i , j + 1 , k ) - divv ( i , j - 1 , k ) ) * grid % d1 % y gdivvz = ( divv ( i , j , k + 1 ) - divv ( i , j , k - 1 ) ) * grid % d1 % z !! VFテンソルの発散 div(VF) の3成分 divfvx = ( fx ( i + 1 , j , k ) * vx ( i + 1 , j , k ) & - fx ( i - 1 , j , k ) * vx ( i - 1 , j , k ) ) * grid % d1 % x & + ( fx ( i , j + 1 , k ) * vy ( i , j + 1 , k ) & - fx ( i , j - 1 , k ) * vy ( i , j - 1 , k ) ) * grid % d1 % y & + ( fx ( i , j , k + 1 ) * vz ( i , j , k + 1 ) & - fx ( i , j , k - 1 ) * vz ( i , j , k - 1 ) ) * grid % d1 % z divfvy = ( fy ( i + 1 , j , k ) * vx ( i + 1 , j , k ) & - fy ( i - 1 , j , k ) * vx ( i - 1 , j , k ) ) * grid % d1 % x & + ( fy ( i , j + 1 , k ) * vy ( i , j + 1 , k ) & - fy ( i , j - 1 , k ) * vy ( i , j - 1 , k ) ) * grid % d1 % y & + ( fy ( i , j , k + 1 ) * vz ( i , j , k + 1 ) & - fy ( i , j , k - 1 ) * vz ( i , j , k - 1 ) ) * grid % d1 % z divfvz = ( fz ( i + 1 , j , k ) * vx ( i + 1 , j , k ) & - fz ( i - 1 , j , k ) * vx ( i - 1 , j , k ) ) * grid % d1 % x & + ( fz ( i , j + 1 , k ) * vy ( i , j + 1 , k ) & - fz ( i , j - 1 , k ) * vy ( i , j - 1 , k ) ) * grid % d1 % y & + ( fz ( i , j , k + 1 ) * vz ( i , j , k + 1 ) & - fz ( i , j , k - 1 ) * vz ( i , j , k - 1 ) ) * grid % d1 % z !! Laplacin V の3成分 lapvx = ( vx ( i + 1 , j , k ) - 2 * vx ( i , j , k ) + vx ( i - 1 , j , k ) ) * grid % d2 % x & + ( vx ( i , j + 1 , k ) - 2 * vx ( i , j , k ) + vx ( i , j - 1 , k ) ) * grid % d2 % y & + ( vx ( i , j , k + 1 ) - 2 * vx ( i , j , k ) + vx ( i , j , k - 1 ) ) * grid % d2 % z lapvy = ( vy ( i + 1 , j , k ) - 2 * vy ( i , j , k ) + vy ( i - 1 , j , k ) ) * grid % d2 % x & + ( vy ( i , j + 1 , k ) - 2 * vy ( i , j , k ) + vy ( i , j - 1 , k ) ) * grid % d2 % y & + ( vy ( i , j , k + 1 ) - 2 * vy ( i , j , k ) + vy ( i , j , k - 1 ) ) * grid % d2 % z lapvz = ( vz ( i + 1 , j , k ) - 2 * vz ( i , j , k ) + vz ( i - 1 , j , k ) ) * grid % d2 % x & + ( vz ( i , j + 1 , k ) - 2 * vz ( i , j , k ) + vz ( i , j - 1 , k ) ) * grid % d2 % y & + ( vz ( i , j , k + 1 ) - 2 * vz ( i , j , k ) + vz ( i , j , k - 1 ) ) * grid % d2 % z !! Laplacin T laptm = ( tm ( i + 1 , j , k ) - 2 * tm ( i , j , k ) + tm ( i - 1 , j , k ) ) * grid % d2 % x & + ( tm ( i , j + 1 , k ) - 2 * tm ( i , j , k ) + tm ( i , j - 1 , k ) ) * grid % d2 % y & + ( tm ( i , j , k + 1 ) - 2 * tm ( i , j , k ) + tm ( i , j , k - 1 ) ) * grid % d2 % z !! div F divf = ( fx ( i + 1 , j , k ) - fx ( i - 1 , j , k ) ) * grid % d1 % x & + ( fy ( i , j + 1 , k ) - fy ( i , j - 1 , k ) ) * grid % d1 % y & + ( fz ( i , j , k + 1 ) - fz ( i , j , k - 1 ) ) * grid % d1 % z !! 以下がナビエ・ストークス方程式 !!  密度の時間発展 the_equation % density ( i , j , k ) = - divf * dt !!  質量フラックスの時間発展（3成分） the_equation % flux % x ( i , j , k ) = & ( - divfvx & - gradpx & + Drive_force % x ( i , j , k ) * factor & + Viscosity * ( lapvx + ONE_THIRD * gdivvx ) & ) * dt the_equation % flux % y ( i , j , k ) = & ( - divfvy & - gradpy & + Drive_force % y ( i , j , k ) * factor & + Viscosity * ( lapvy + ONE_THIRD * gdivvy ) & ) * dt the_equation % flux % z ( i , j , k ) = & ( - divfvz & - gradpz & + Drive_force % z ( i , j , k ) * factor & + Viscosity * ( lapvz + ONE_THIRD * gdivvz ) & ) * dt !!  圧力の時間発展 the_equation % pressure ( i , j , k ) = & ( - ( vx ( i , j , k ) * gradpx & + vy ( i , j , k ) * gradpy & + vz ( i , j , k ) * gradpz & ) & + Gamma1_kappa * laptm & - GAMMA * ps ( i , j , k ) * divv ( i , j , k ) & ) * dt end do end do end do call the_equation % set_boundary_condition !! 境界条件の設定（周期境界条件） !! 上のdo loopは境界面上の格子点を除いた格子点（シミュレーション !! 領域の内部の格子点）上での値を計算するものであった。 !! ここで境界面上の格子点の値の（更新されたばかりの）内部の !! 格子点上のデータをコピーすることで設定する。 end function the_equation","tags":"","loc":"proc/the_equation.html"},{"title":"set_drive_force_field – Smoke Ring","text":"private  subroutine set_drive_force_field() 渦輪を駆動するための力の場を設定する\nその力はシミュレーション開始直後、短い時間だけかける。\n空間的には局在した力を想定している。その形状は円筒形である。\n円筒の軸はx軸上にある。\n力をかける局所円筒領域のx方向の最小値\n力をかける局所円筒領域のx方向の最大値\n力をかける局所円筒領域の中心のy座標を中間にとる\n力をかける局所円筒領域の中心のz座標を中間にとる\n力をかける局所円筒領域の直径\n力をかける局所円筒領域の半径の2乗 境界上の格子点を飛ばして、シミュレーション領域内部\nを回る3重do loop。境界上の格子点で値は境界条件で設定する。\n力の中心からのz方向の距離\n力の中心からのy方向の距離\nこれは格子点のx座標そのもの\nここで半径そのもので比較するとsqrtの計算が必要になるが\nこのように2乗同士で比較すれば不要。\nいまはx方向だけに力がかかる\nとしている。斜め方向に力を\nかけるにはこの部分を変更。\n1. プロセス間通信を行い、分割領域の境界値を設定する\n2. シミュレーション領域全体の境界条件を設定する。 Arguments None Calls proc~~set_drive_force_field~~CallsGraph proc~set_drive_force_field solver_m::set_drive_force_field interface~field__boundary_condition field_m::field__boundary_condition proc~set_drive_force_field->interface~field__boundary_condition proc~boundary_condition_scalar field_m::boundary_condition_scalar interface~field__boundary_condition->proc~boundary_condition_scalar proc~boundary_condition_vector field_m::boundary_condition_vector interface~field__boundary_condition->proc~boundary_condition_vector mpiut__barrier mpiut__barrier proc~boundary_condition_scalar->mpiut__barrier mpiut__exchange mpiut__exchange proc~boundary_condition_scalar->mpiut__exchange proc~boundary_condition_vector->mpiut__barrier proc~boundary_condition_vector->mpiut__exchange Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set_drive_force_field~~CalledByGraph proc~set_drive_force_field solver_m::set_drive_force_field proc~solver__initialize solver_m::solver_t%solver__initialize proc~solver__initialize->proc~set_drive_force_field Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Source Code set_drive_force_field Source Code subroutine set_drive_force_field !! 渦輪を駆動するための力の場を設定する !! その力はシミュレーション開始直後、短い時間だけかける。 !! 空間的には局在した力を想定している。その形状は円筒形である。 !! 円筒の軸はx軸上にある。 integer :: i , j , k real ( DR ) :: xx , yy , zz real ( DR ) :: force_region_x_min , force_region_x_max real ( DR ) :: force_center_y , force_center_z real ( DR ) :: force_cylinder_diameter , force_cylinder_radius_sq real ( DR ), parameter :: THE_FORCE = 3.e3_DR !! 瞬間的な力の最大値。 !! 試行錯誤で調整せよ。 !!> !          +--------------------------------------+ ZMAX !          |                                      | !          |    +-------+                         | !          |    | Force |                         | !          |    +-------+                         | !          |                                      | !          +--------------------------------------+ ZMIN !         XMIN                                   XMAX !!< force_region_x_min = XMIN + ( XMAX - XMIN ) / 5 !! 力をかける局所円筒領域のx方向の最小値 force_region_x_max = force_region_x_min + ( XMAX - XMIN ) / 10 !! 力をかける局所円筒領域のx方向の最大値 force_center_y = ( YMAX + YMIN ) / 2 !! 力をかける局所円筒領域の中心のy座標を中間にとる force_center_z = ( ZMAX + ZMIN ) / 2 !! 力をかける局所円筒領域の中心のz座標を中間にとる force_cylinder_diameter = min ( YMAX - YMIN , ZMAX - ZMIN ) / 4 !! 力をかける局所円筒領域の直径 force_cylinder_radius_sq = ( force_cylinder_diameter / 2 ) ** 2 !! 力をかける局所円筒領域の半径の2乗 do k = 1 , NZPP !! 境界上の格子点を飛ばして、シミュレーション領域内部 !! を回る3重do loop。境界上の格子点で値は境界条件で設定する。 zz = grid % pos % z ( k ) - force_center_z !! 力の中心からのz方向の距離 do j = 1 , NYPP yy = grid % pos % y ( j ) - force_center_y !! 力の中心からのy方向の距離 do i = 1 , NXPP xx = grid % pos % x ( i ) !! これは格子点のx座標そのもの if ( ( yy ** 2 + zz ** 2 ) < force_cylinder_radius_sq & . and . & ( xx > force_region_x_min ) & . and . & ( xx < force_region_x_max ) ) then !! ここで半径そのもので比較するとsqrtの計算が必要になるが !! このように2乗同士で比較すれば不要。 Drive_force % x ( i , j , k ) = THE_FORCE !! いまはx方向だけに力がかかる Drive_force % y ( i , j , k ) = 0.0_DR !! としている。斜め方向に力を Drive_force % z ( i , j , k ) = 0.0_DR !! かけるにはこの部分を変更。 else Drive_force % x ( i , j , k ) = 0.0_DR Drive_force % y ( i , j , k ) = 0.0_DR Drive_force % z ( i , j , k ) = 0.0_DR end if end do end do end do call field__boundary_condition ( Drive_force ) !! 1. プロセス間通信を行い、分割領域の境界値を設定する !! 2. シミュレーション領域全体の境界条件を設定する。 end subroutine set_drive_force_field","tags":"","loc":"proc/set_drive_force_field.html"},{"title":"solver__advance – Smoke Ring","text":"private  subroutine solver__advance(t, dt, fluid) 4段4次ルンゲ・クッタ積分法による時間積分の実行 Note ここでは教科書に書かれている古典的な4段4次の\n   ルンゲ・クッタ積分法をそのまま実装している。\n   作業用の構造体を5つ使用している（dfluid01からdfluid04とgluid）\n   これらの作業変数の数を減らし、メモリを節約にするためには\n   Runge-Kutta-Gill法などの方法がある。 Note 速度（vel）、温度（tm）, 速度の発散（divv）などの配列などは\n   このスキームでは基本変数から毎回計算すべき一種の作業配列である。\n   したがって、このモジュール内の他の場所（サブルーチン・関数）でも\n   これらの変数（3次元の大きな配列）を宣言・使用している。\n   使用メモリを節約するためにはこれらの作業配列は共通のものを\n   一つづつ用意するというのも可能である。しかし、そうするとコードが\n   読みにくくなるであろう。 基本変数から副次的変数である速度、温度、速度の発散を求める\n 渦輪を駆動する力は時刻（t）の関数として設定しているので、\n いま解いているナビエ・ストークス方程式は時間に陽に依存する。 ---ルンゲ・クッタの第2段---\n Fortranコンパイラが自己定義演算子をきちんと処理できる\n 場合は上の簡潔な記述の方が（読みやすいので）好ましい。 ---ルンゲ・クッタの第3段---\n Fortranコンパイラが自己定義演算子をきちんと処理できる\n 場合は上の簡潔な記述の方が（読みやすいので）好ましい。 繰り返すが、渦輪を駆動する力は時刻（t）の関数として設定しているので、\n いま解いているナビエ・ストークス方程式は時間に陽に依存する。 ---ルンゲ・クッタの第4段---\n Fortranコンパイラが自己定義演算子をきちんと処理できる\n 場合は上の簡潔な記述の方が（読みやすいので）好ましい。 --- 最終結果 --- Fortranコンパイラが自己定義演算子をきちんと処理できる\n 場合は一番上の簡潔な記述の方が（読みやすいので）好ましい。 Type Bound solver_t Arguments Type Intent Optional Attributes Name real(kind=DR), intent(inout) :: t 時刻 real(kind=DR), intent(in) :: dt 時間刻み幅 type( fluid_t ), intent(inout) :: fluid 流体データ Calls proc~~solver__advance~~CallsGraph proc~solver__advance solver_m::solver_t%solver__advance proc~subfield_vel_tm_divv solver_m::solver_t%subfield_vel_tm_divv proc~solver__advance->proc~subfield_vel_tm_divv proc~the_equation solver_m::the_equation proc~solver__advance->proc~the_equation proc~drive_force_factor solver_m::drive_force_factor proc~the_equation->proc~drive_force_factor set_boundary_condition set_boundary_condition proc~the_equation->set_boundary_condition ut__assert ut__assert proc~the_equation->ut__assert x x proc~the_equation->x y y proc~the_equation->y z z proc~the_equation->z proc~drive_force_factor->ut__assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Source Code solver__advance Source Code subroutine solver__advance ( t , dt , fluid ) !! 4段4次ルンゲ・クッタ積分法による時間積分の実行 !! !! @note !!   ここでは教科書に書かれている古典的な4段4次の !!   ルンゲ・クッタ積分法をそのまま実装している。 !!   作業用の構造体を5つ使用している（dfluid01からdfluid04とgluid） !!   これらの作業変数の数を減らし、メモリを節約にするためには !!   Runge-Kutta-Gill法などの方法がある。 !! !! @note !!   速度（vel）、温度（tm）, 速度の発散（divv）などの配列などは !!   このスキームでは基本変数から毎回計算すべき一種の作業配列である。 !!   したがって、このモジュール内の他の場所（サブルーチン・関数）でも !!   これらの変数（3次元の大きな配列）を宣言・使用している。 !!   使用メモリを節約するためにはこれらの作業配列は共通のものを !!   一つづつ用意するというのも可能である。しかし、そうするとコードが !!   読みにくくなるであろう。 real ( DR ), intent ( inout ) :: t !! 時刻 real ( DR ), intent ( in ) :: dt !! 時間刻み幅 type ( fluid_t ), intent ( inout ) :: fluid !! 流体データ real ( DR ), parameter :: ONE_SIXTH = 1.0_DR / 6.0_DR !! 演算数節約の real ( DR ), parameter :: ONE_THIRD = 1.0_DR / 3.0_DR !! ために定義 type ( field__vector_t ) :: vel !! 速度場 real ( DR ), dimension ( 0 : NXPP1 , 0 : NYPP1 , 0 : NZPP1 ) :: tm !! 温度場 real ( DR ), dimension ( 0 : NXPP1 , 0 : NYPP1 , 0 : NZPP1 ) :: divv !! 速度場の発散 type ( fluid_t ) :: dfluid01 , dfluid02 , dfluid03 , dfluid04 !! 古典的な4段4次ルンゲ・クッタ積分法に必要な4つの作業配列 !! サイズが大きいことに注意。 type ( fluid_t ) :: gluid !! work variable !! さらにもう一つの作業配列 !! サイズが大きいことに注意。 !!---ルンゲ・クッタの第1段--- call subfield_vel_tm_divv ( fluid , vel , tm , divv ) !! 基本変数から副次的変数である速度、温度、速度の発散を求める dfluid01 = the_equation ( t , dt , & vel % x , vel % y , vel % z , tm , divv , & fluid % flux % x , fluid % flux % y , fluid % flux % z , & fluid % pressure ) t = t + dt / 2 !! 渦輪を駆動する力は時刻（t）の関数として設定しているので、 !! いま解いているナビエ・ストークス方程式は時間に陽に依存する。 !!---ルンゲ・クッタの第2段--- gluid = fluid + dfluid01 * 0.5_DR !! Fortranコンパイラが自己定義演算子をきちんと処理できる !! 場合は上の簡潔な記述の方が（読みやすいので）好ましい。 call subfield_vel_tm_divv ( gluid , vel , tm , divv ) dfluid02 = the_equation ( t , dt , & vel % x , vel % y , vel % z , tm , divv , & gluid % flux % x , gluid % flux % y , gluid % flux % z , & gluid % pressure ) !!---ルンゲ・クッタの第3段--- gluid = fluid + dfluid02 * 0.5_DR !! Fortranコンパイラが自己定義演算子をきちんと処理できる !! 場合は上の簡潔な記述の方が（読みやすいので）好ましい。 call subfield_vel_tm_divv ( gluid , vel , tm , divv ) dfluid03 = the_equation ( t , dt , & vel % x , vel % y , vel % z , tm , divv , & gluid % flux % x , gluid % flux % y , gluid % flux % z , & gluid % pressure ) t = t + dt / 2 !! 繰り返すが、渦輪を駆動する力は時刻（t）の関数として設定しているので、 !! いま解いているナビエ・ストークス方程式は時間に陽に依存する。 !!---ルンゲ・クッタの第4段--- gluid = fluid + dfluid03 !! Fortranコンパイラが自己定義演算子をきちんと処理できる !! 場合は上の簡潔な記述の方が（読みやすいので）好ましい。 call subfield_vel_tm_divv ( gluid , vel , tm , divv ) dfluid04 = the_equation ( t , dt , & vel % x , vel % y , vel % z , tm , divv , & gluid % flux % x , gluid % flux % y , gluid % flux % z , & gluid % pressure ) !!--- 最終結果 --- fluid = fluid + ONE_SIXTH * ( dfluid01 + 2 * dfluid02 + 2 * dfluid03 + dfluid04 ) !! Fortranコンパイラが自己定義演算子をきちんと処理できる !! 場合は一番上の簡潔な記述の方が（読みやすいので）好ましい。 end subroutine solver__advance","tags":"","loc":"proc/solver__advance.html"},{"title":"solver__diagnosis – Smoke Ring","text":"private  subroutine solver__diagnosis(nloop, time, fluid) 流体の「健康状態」を診断する\nこのルーチンは結構計算負荷が高いので、\n毎ステップではなく、SKIPステップごとに診断を実行する Already in error state.\nジョブの健康状態がfine（つまり健康）以外の値に\n設定する可能性があるのはここ以外にもある（例えばmain.f90の\nメインループでシミュレーションのループカウンタが最大値が達するなど）\nそのような場合、どうせこの後、ジョブの停止処理に入るので、\nこれ以上計算を進めなくてもよい。 質量フラックスのx成分が異常に大きい。\nこれ以上計算しても無駄（すぐに終了処理に入るべし）\nこれ以上計算しても無駄（すぐに終了処理に入るべし）\n質量フラックスのz成分が異常に大きい。\nこれ以上計算しても無駄（すぐに終了処理に入るべし）\n質量が異常に大きい\nこれ以上計算しても無駄（すぐに終了処理に入るべし）\n圧力が異常に大きい\nこれ以上計算しても無駄（すぐに終了処理に入るべし）\n圧力が負になってしまっている\nこれ以上計算しても無駄（すぐに終了処理に入るべし）\n密度が負になってしまっている\nこれ以上計算しても無駄（すぐに終了処理に入るべし）\n基本流れデータから副次的な速度場データを求める 速度の最大値（ベクトルの長さ）を計算し標準出力に書き出す\nわずか1行で書いているが、実際にはここにかなりの計算が\n含まれている。vel.x**2という配列演算は実際には3重do loop\nであり、maxval関数はその引数の3次元配列をとっている。\nつまり全要素中の最大値をとっている。そして最後に\nsqrtをとって振幅（ベクトルの長さ）を計算している。 ここでもこの1行の実行にはかなりの演算（速度ベクトル場\nのx,y,z3成分の2乗和に質量密度を掛けたもの体積積分）が\nされていることに注意。 上と同様。こちらのほうは単なる密度場の体積積分なので\n演算量は少ないが、シミュレーション領域全体に渡る体積積分\nなので計算量は大きいことにかわりない。 Type Bound solver_t Arguments Type Intent Optional Attributes Name integer, intent(in) :: nloop ループカウンタ real(kind=DR), intent(in) :: time シミュレーション時刻 type( fluid_t ), intent(in) :: fluid 流体データ Calls proc~~solver__diagnosis~~CallsGraph proc~solver__diagnosis solver_m::solver_t%solver__diagnosis mpiut__message mpiut__message proc~solver__diagnosis->mpiut__message proc~subfield_vel solver_m::solver_t%subfield_vel proc~solver__diagnosis->proc~subfield_vel ut__message ut__message proc~solver__diagnosis->ut__message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Source Code solver__diagnosis Source Code subroutine solver__diagnosis ( nloop , time , fluid ) !! 流体の「健康状態」を診断する integer , intent ( in ) :: nloop !! ループカウンタ real ( DR ), intent ( in ) :: time !! シミュレーション時刻 type ( fluid_t ), intent ( in ) :: fluid !! 流体データ integer , parameter :: SKIP = 100 !! このルーチンは結構計算負荷が高いので、 !! 毎ステップではなく、SKIPステップごとに診断を実行する real ( DR ), parameter :: ANOMALOUSLY_LARGE = 1.e20_DR !! これよりも物理量が大きくなったら異常が生じたと判断する type ( field__vector_t ) :: vel !! 流れの速度場 if ( mod ( nloop , SKIP ) /= 0 ) return !! このルーチンは結構計算負荷が高いので、 !! 毎ステップではなく、SKIPステップごとに診断を実行する if ( Job % karte /= \"fine\" ) return !! Already in error state. !! ジョブの健康状態がfine（つまり健康）以外の値に !! 設定する可能性があるのはここ以外にもある（例えばmain.f90の !! メインループでシミュレーションのループカウンタが最大値が達するなど） !! そのような場合、どうせこの後、ジョブの停止処理に入るので、 !! これ以上計算を進めなくてもよい。 if ( maxval ( abs ( fluid % flux % x )) > ANOMALOUSLY_LARGE ) then !! 質量フラックスのx成分が異常に大きい。 call ut__message ( \"solver_m(528): Massflux_x overflow.\" ) Job % karte = \"overflow\" return !! これ以上計算しても無駄（すぐに終了処理に入るべし） end if if ( maxval ( abs ( fluid % flux % y )) > ANOMALOUSLY_LARGE ) then call ut__message ( \"solver_m(535): Massflux_y overflow.\" ) Job % karte = \"overflow\" return !! これ以上計算しても無駄（すぐに終了処理に入るべし） end if if ( maxval ( abs ( fluid % flux % z )) > ANOMALOUSLY_LARGE ) then !! 質量フラックスのz成分が異常に大きい。 call ut__message ( \"solver_m(543): Massflux_z overflow.\" ) Job % karte = \"overflow\" return !! これ以上計算しても無駄（すぐに終了処理に入るべし） end if if ( maxval ( fluid % density ) > ANOMALOUSLY_LARGE ) then !! 質量が異常に大きい call ut__message ( \"solver_m(551): Density overflow.\" ) Job % karte = \"overflow\" return !! これ以上計算しても無駄（すぐに終了処理に入るべし） end if if ( maxval ( fluid % pressure ) > ANOMALOUSLY_LARGE ) then !! 圧力が異常に大きい call ut__message ( \"solver_m(559): Pressure overflow.\" ) Job % karte = \"overflow\" return !! これ以上計算しても無駄（すぐに終了処理に入るべし） end if if ( minval ( fluid % pressure ) < 0.0_DR ) then !! 圧力が負になってしまっている call ut__message ( \" solver_m(567): Negative pressure.\" ) Job % karte = \"negative anormaly\" return !! これ以上計算しても無駄（すぐに終了処理に入るべし） end if if ( minval ( fluid % density ) < 0.0_DR ) then !! 密度が負になってしまっている call ut__message ( \" solver_m(575): Negative density.\" ) Job % karte = \"negative anormaly\" return !! これ以上計算しても無駄（すぐに終了処理に入るべし） end if call subfield_vel ( fluid , vel ) !! 基本流れデータから副次的な速度場データを求める call mpiut__message ( Parallel % comm , & '#max vel:' , & nloop , & time , & sqrt ( maxval ( vel % x ** 2 + vel % y ** 2 + vel % z ** 2 )) ) !! 速度の最大値（ベクトルの長さ）を計算し標準出力に書き出す !! わずか1行で書いているが、実際にはここにかなりの計算が !! 含まれている。vel.x**2という配列演算は実際には3重do loop !! であり、maxval関数はその引数の3次元配列をとっている。 !! つまり全要素中の最大値をとっている。そして最後に !! sqrtをとって振幅（ベクトルの長さ）を計算している。 call mpiut__message ( Parallel % comm , & '#flow energy: ' , & nloop , & time , & . energyintegral . fluid ) !! ここでもこの1行の実行にはかなりの演算（速度ベクトル場 !! のx,y,z3成分の2乗和に質量密度を掛けたもの体積積分）が !! されていることに注意。 call mpiut__message ( Parallel % comm , & '#total mass: ' , & nloop , & time , & . scalarintegral . ( fluid % density ) ) !! 上と同様。こちらのほうは単なる密度場の体積積分なので !! 演算量は少ないが、シミュレーション領域全体に渡る体積積分 !! なので計算量は大きいことにかわりない。 end subroutine solver__diagnosis","tags":"","loc":"proc/solver__diagnosis.html"},{"title":"solver__initialize – Smoke Ring","text":"private  subroutine solver__initialize(fluid) モジュールの初期化\n空気の粘性率\n空気の熱拡散率\nViscosityと違ってkappaの頭文字が大文字になっていない、つまり\nこのモジュールのグローバルスコープを持つ変数としていない\nのはナビエ・ストークス方程式には下で定義するGamma1_kappa\nという量のみを通じてkappaが出てくるからである。 gammaは比熱比、つまり定積比熱と定圧比熱の比である。\n統計力学で習うように、この値は流体（気体）を構成する\n分子の構造（自由度）で決まる。 流体の初期条件の設定\n1013 hPa (一気圧)\nkg/m&#94;3 (空気の密度)\nベクトル3成分。（静止状態） 渦輪を駆動するための力の場の設定\nモジュール初期化終了フラグ Type Bound solver_t Arguments Type Intent Optional Attributes Name type( fluid_t ), intent(out) :: fluid 流体データ Calls proc~~solver__initialize~~CallsGraph proc~solver__initialize solver_m::solver_t%solver__initialize get_double get_double proc~solver__initialize->get_double proc~set_drive_force_field solver_m::set_drive_force_field proc~solver__initialize->proc~set_drive_force_field interface~field__boundary_condition field_m::field__boundary_condition proc~set_drive_force_field->interface~field__boundary_condition proc~boundary_condition_scalar field_m::boundary_condition_scalar interface~field__boundary_condition->proc~boundary_condition_scalar proc~boundary_condition_vector field_m::boundary_condition_vector interface~field__boundary_condition->proc~boundary_condition_vector mpiut__barrier mpiut__barrier proc~boundary_condition_scalar->mpiut__barrier mpiut__exchange mpiut__exchange proc~boundary_condition_scalar->mpiut__exchange proc~boundary_condition_vector->mpiut__barrier proc~boundary_condition_vector->mpiut__exchange Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Source Code solver__initialize Source Code subroutine solver__initialize ( fluid ) !! モジュールの初期化 type ( fluid_t ), intent ( out ) :: fluid !! 流体データ real ( DR ) :: kappa !! 空気の熱拡散率 !! 物理パラメータの設定 Viscosity = params % get_double ( 'Viscosity' ) !! 空気の粘性率 kappa = params % get_double ( 'Kappa' ) !! 空気の熱拡散率 !! Viscosityと違ってkappaの頭文字が大文字になっていない、つまり !! このモジュールのグローバルスコープを持つ変数としていない !! のはナビエ・ストークス方程式には下で定義するGamma1_kappa !! という量のみを通じてkappaが出てくるからである。 Gamma1_kappa = ( Gamma - 1 ) * kappa !! gammaは比熱比、つまり定積比熱と定圧比熱の比である。 !! 統計力学で習うように、この値は流体（気体）を構成する !! 分子の構造（自由度）で決まる。 !! 流体の初期条件の設定 fluid % pressure = 1.013e5_DR !! 1013 hPa (一気圧) fluid % density = 1.293_DR !! kg/m&#94;3 (空気の密度) fluid % flux = 0.0_DR !! ベクトル3成分。（静止状態） !! 渦輪を駆動するための力の場の設定 call set_drive_force_field Initialize_done = . true . !! モジュール初期化終了フラグ end subroutine solver__initialize","tags":"","loc":"proc/solver__initialize.html"},{"title":"subfield_vel – Smoke Ring","text":"private  subroutine subfield_vel(fluid, vel) fluidの基本変数から二次的な場vel（流れの速度ベクトル場）\nをもとめる。\n割り算演算子はfield_mで定義している。 Type Bound solver_t Arguments Type Intent Optional Attributes Name type( fluid_t ), intent(in) :: fluid 流体基本場 type( field__vector_t ), intent(out) :: vel 流れの速度ベクトル Called by proc~~subfield_vel~~CalledByGraph proc~subfield_vel solver_m::solver_t%subfield_vel proc~solver__diagnosis solver_m::solver_t%solver__diagnosis proc~solver__diagnosis->proc~subfield_vel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Source Code subfield_vel Source Code subroutine subfield_vel ( fluid , vel ) !! fluidの基本変数から二次的な場vel（流れの速度ベクトル場） !! をもとめる。 type ( fluid_t ) , intent ( in ) :: fluid !! 流体基本場 type ( field__vector_t ), intent ( out ) :: vel !! 流れの速度ベクトル vel = fluid % flux / fluid % density !! 割り算演算子はfield_mで定義している。 end subroutine subfield_vel","tags":"","loc":"proc/subfield_vel.html"},{"title":"subfield_vel_tm – Smoke Ring","text":"private  subroutine subfield_vel_tm(fluid, vel, tm) fluidの基本変数から二次的な場（速度ベクトル場velと温度場tm）\nをもとめる。\nfluid構造体の割り算演算子はfluid_mで定義している。 Type Bound solver_t Arguments Type Intent Optional Attributes Name type( fluid_t ), intent(in) :: fluid 流体基本場 type( field__vector_t ), intent(out) :: vel 流れ場 real(kind=DR), intent(out), dimension(0:NXPP1,0:NYPP1,0:NZPP1) :: tm 温度場 Called by proc~~subfield_vel_tm~~CalledByGraph proc~subfield_vel_tm solver_m::solver_t%subfield_vel_tm proc~solver__set_time_step solver_m::solver_t%solver__set_time_step proc~solver__set_time_step->proc~subfield_vel_tm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Source Code subfield_vel_tm Source Code subroutine subfield_vel_tm ( fluid , vel , tm ) !! fluidの基本変数から二次的な場（速度ベクトル場velと温度場tm） !! をもとめる。 type ( fluid_t ) , intent ( in ) :: fluid !! 流体基本場 type ( field__vector_t ), intent ( out ) :: vel !! 流れ場 real ( DR ), dimension ( 0 : NXPP1 , 0 : NYPP1 , 0 : NZPP1 ), intent ( out ) :: tm !! 温度場 vel = fluid % flux / fluid % density tm = fluid % pressure / ( GASS_CONST_FOR_AIR * fluid % density ) !! fluid構造体の割り算演算子はfluid_mで定義している。 end subroutine subfield_vel_tm","tags":"","loc":"proc/subfield_vel_tm.html"},{"title":"subfield_vel_tm_divv – Smoke Ring","text":"private  subroutine subfield_vel_tm_divv(fluid, vel, tm, divv) fluidの基本変数から二次的な場（速度ベクトル場velと\n温度場tmと速度の発散divv）をもとめる。 Type Bound solver_t Arguments Type Intent Optional Attributes Name type( fluid_t ), intent(in) :: fluid 流体基本場 type( field__vector_t ), intent(out) :: vel 流れ場 real(kind=DR), intent(out), dimension(0:NXPP1,0:NYPP1,0:NZPP1) :: tm 温度場 real(kind=DR), intent(out), dimension(0:NXPP1,0:NYPP1,0:NZPP1) :: divv 流れの発散 Called by proc~~subfield_vel_tm_divv~~CalledByGraph proc~subfield_vel_tm_divv solver_m::solver_t%subfield_vel_tm_divv proc~solver__advance solver_m::solver_t%solver__advance proc~solver__advance->proc~subfield_vel_tm_divv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Source Code subfield_vel_tm_divv Source Code subroutine subfield_vel_tm_divv ( fluid , vel , tm , divv ) !! fluidの基本変数から二次的な場（速度ベクトル場velと !! 温度場tmと速度の発散divv）をもとめる。 type ( fluid_t ) , intent ( in ) :: fluid !! 流体基本場 type ( field__vector_t ), intent ( out ) :: vel !! 流れ場 real ( DR ), dimension ( 0 : NXPP1 , 0 : NYPP1 , 0 : NZPP1 ), intent ( out ) :: tm !! 温度場 real ( DR ), dimension ( 0 : NXPP1 , 0 : NYPP1 , 0 : NZPP1 ), intent ( out ) :: divv !! 流れの発散 vel = fluid % flux / fluid % density ! operator defined in field.f90. tm = fluid % pressure / fluid % density divv = . div . vel end subroutine subfield_vel_tm_divv","tags":"","loc":"proc/subfield_vel_tm_divv.html"},{"title":"operator_cross_product – Smoke Ring","text":"private  function operator_cross_product(a, b) ベクトル場の外積 Arguments Type Intent Optional Attributes Name type( field__vector_t ), intent(in) :: a 掛けるベクトル場 type( field__vector_t ), intent(in) :: b 掛けるベクトル場 Return Value type( field__vector_t ) 外積 Called by proc~~operator_cross_product~~CalledByGraph proc~operator_cross_product field_m::operator_cross_product interface~operator( .x. ) field_m::operator( .x. ) interface~operator( .x. )->proc~operator_cross_product Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Source Code operator_cross_product Source Code function operator_cross_product ( a , b ) !! ベクトル場の外積 type ( field__vector_t ), intent ( in ) :: a , b !! 掛けるベクトル場 type ( field__vector_t ) :: operator_cross_product !! 外積 operator_cross_product % x = ( a % y ) * ( b % z ) - ( a % z ) * ( b % y ) operator_cross_product % y = ( a % z ) * ( b % x ) - ( a % x ) * ( b % z ) operator_cross_product % z = ( a % x ) * ( b % y ) - ( a % y ) * ( b % x ) end function operator_cross_product","tags":"","loc":"proc/operator_cross_product.html"},{"title":"operator_curl – Smoke Ring","text":"private  function operator_curl(a) ベクトル場のcurl Arguments Type Intent Optional Attributes Name type( field__vector_t ), intent(in) :: a これのcurlをとる Return Value type( field__vector_t ) curlした結果 Calls proc~~operator_curl~~CallsGraph proc~operator_curl field_m::operator_curl interface~field__boundary_condition field_m::field__boundary_condition proc~operator_curl->interface~field__boundary_condition x x proc~operator_curl->x y y proc~operator_curl->y z z proc~operator_curl->z proc~boundary_condition_scalar field_m::boundary_condition_scalar interface~field__boundary_condition->proc~boundary_condition_scalar proc~boundary_condition_vector field_m::boundary_condition_vector interface~field__boundary_condition->proc~boundary_condition_vector mpiut__barrier mpiut__barrier proc~boundary_condition_scalar->mpiut__barrier mpiut__exchange mpiut__exchange proc~boundary_condition_scalar->mpiut__exchange proc~boundary_condition_vector->mpiut__barrier proc~boundary_condition_vector->mpiut__exchange Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~operator_curl~~CalledByGraph proc~operator_curl field_m::operator_curl interface~operator( .curl. ) field_m::operator( .curl. ) interface~operator( .curl. )->proc~operator_curl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Source Code operator_curl Source Code function operator_curl ( a ) !! ベクトル場のcurl type ( field__vector_t ), intent ( in ) :: a !! これのcurlをとる type ( field__vector_t ) :: operator_curl !! curlした結果 integer :: i , j , k real ( DR ) :: dx1 , dy1 , dz1 dx1 = grid % d1 % x ! x方向の偏微分演算用定数 dy1 = grid % d1 % y ! y方向の偏微分演算用定数 dz1 = grid % d1 % z ! z方向の偏微分演算用定数 do k = 1 , NZPP ! 境界上の格子点を飛ばして、シミュレーション領域内部 ! の格子点上で差分法によりcurlを計算する do j = 1 , NYPP do i = 1 , NXPP operator_curl % x ( i , j , k ) = dy1 * ( a % z ( i , j + 1 , k ) - a % z ( i , j - 1 , k )) & - dz1 * ( a % y ( i , j , k + 1 ) - a % y ( i , j , k - 1 )) operator_curl % y ( i , j , k ) = dz1 * ( a % x ( i , j , k + 1 ) - a % x ( i , j , k - 1 )) & - dx1 * ( a % z ( i + 1 , j , k ) - a % z ( i - 1 , j , k )) operator_curl % z ( i , j , k ) = dx1 * ( a % y ( i + 1 , j , k ) - a % y ( i - 1 , j , k )) & - dy1 * ( a % x ( i , j + 1 , k ) - a % x ( i , j - 1 , k )) end do end do end do call field__boundary_condition ( operator_curl ) ! 境界の格子点は境界条件ルーチンで設定する end function operator_curl","tags":"","loc":"proc/operator_curl.html"},{"title":"operator_div – Smoke Ring","text":"private  function operator_div(a) ベクトル場のdivergence Arguments Type Intent Optional Attributes Name type( field__vector_t ), intent(in) :: a これのdivをとる Return Value real(kind=DR), dimension(0:NXPP1,0:NYPP1,0:NZPP1) 結果 Calls proc~~operator_div~~CallsGraph proc~operator_div field_m::operator_div interface~field__boundary_condition field_m::field__boundary_condition proc~operator_div->interface~field__boundary_condition x x proc~operator_div->x y y proc~operator_div->y z z proc~operator_div->z proc~boundary_condition_scalar field_m::boundary_condition_scalar interface~field__boundary_condition->proc~boundary_condition_scalar proc~boundary_condition_vector field_m::boundary_condition_vector interface~field__boundary_condition->proc~boundary_condition_vector mpiut__barrier mpiut__barrier proc~boundary_condition_scalar->mpiut__barrier mpiut__exchange mpiut__exchange proc~boundary_condition_scalar->mpiut__exchange proc~boundary_condition_vector->mpiut__barrier proc~boundary_condition_vector->mpiut__exchange Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~operator_div~~CalledByGraph proc~operator_div field_m::operator_div interface~operator( .div. ) field_m::operator( .div. ) interface~operator( .div. )->proc~operator_div Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Source Code operator_div Source Code function operator_div ( a ) !! ベクトル場のdivergence type ( field__vector_t ), intent ( in ) :: a !! これのdivをとる real ( DR ), dimension ( 0 : NXPP1 , 0 : NYPP1 , 0 : NZPP1 ) :: operator_div !! 結果 integer :: i , j , k real ( DR ) :: dx1 , dy1 , dz1 dx1 = grid % d1 % x ! x方向の偏微分演算用定数 dy1 = grid % d1 % y ! y方向の偏微分演算用定数 dz1 = grid % d1 % z ! z方向の偏微分演算用定数 do k = 1 , NZPP ! 境界上の格子点を飛ばして、シミュレーション領域内部 ! の格子点上で差分法によりdivergenceを計算する do j = 1 , NYPP do i = 1 , NXPP operator_div ( i , j , k ) = dx1 * ( a % x ( i + 1 , j , k ) - a % x ( i - 1 , j , k )) & + dy1 * ( a % y ( i , j + 1 , k ) - a % y ( i , j - 1 , k )) & + dz1 * ( a % z ( i , j , k + 1 ) - a % z ( i , j , k - 1 )) end do end do end do call field__boundary_condition ( operator_div ) ! 境界の格子点は境界条件ルーチンで設定する end function operator_div","tags":"","loc":"proc/operator_div.html"},{"title":"operator_dot_product – Smoke Ring","text":"private  function operator_dot_product(a, b) ベクトル場の内積 Arguments Type Intent Optional Attributes Name type( field__vector_t ), intent(in) :: a 内積をとるベクトル場 type( field__vector_t ), intent(in) :: b 内積をとるベクトル場 Return Value real(kind=DR), dimension(0:NXPP1,0:NYPP1,0:NZPP1) 計算結果 Called by proc~~operator_dot_product~~CalledByGraph proc~operator_dot_product field_m::operator_dot_product interface~operator( .dot. ) field_m::operator( .dot. ) interface~operator( .dot. )->proc~operator_dot_product Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Source Code operator_dot_product Source Code function operator_dot_product ( a , b ) !! ベクトル場の内積 type ( field__vector_t ), intent ( in ) :: a , b !! 内積をとるベクトル場 real ( DR ), dimension ( 0 : NXPP1 , 0 : NYPP1 , 0 : NZPP1 ) :: operator_dot_product !! 計算結果 operator_dot_product = a % x * b % x + a % y * b % y + a % z * b % z ! 配列演算 ! ! 実際にはここで3重do_loopが回っている ! OpenMP化するときにはこの簡潔な ! 書き方をやめて3重do_loopに書き直す必要がある。 end function operator_dot_product","tags":"","loc":"proc/operator_dot_product.html"},{"title":"operator_laplacian_scalar – Smoke Ring","text":"private  function operator_laplacian_scalar(a) スカラー場のラプラシアン Arguments Type Intent Optional Attributes Name real(kind=DR), intent(in), dimension(0:NXPP1,0:NYPP1,0:NZPP1) :: a 入力スカラー場 Return Value real(kind=DR), dimension(0:NXPP1,0:NYPP1,0:NZPP1) 計算結果 Calls proc~~operator_laplacian_scalar~~CallsGraph proc~operator_laplacian_scalar field_m::operator_laplacian_scalar interface~field__boundary_condition field_m::field__boundary_condition proc~operator_laplacian_scalar->interface~field__boundary_condition proc~boundary_condition_scalar field_m::boundary_condition_scalar interface~field__boundary_condition->proc~boundary_condition_scalar proc~boundary_condition_vector field_m::boundary_condition_vector interface~field__boundary_condition->proc~boundary_condition_vector mpiut__barrier mpiut__barrier proc~boundary_condition_scalar->mpiut__barrier mpiut__exchange mpiut__exchange proc~boundary_condition_scalar->mpiut__exchange proc~boundary_condition_vector->mpiut__barrier proc~boundary_condition_vector->mpiut__exchange Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~operator_laplacian_scalar~~CalledByGraph proc~operator_laplacian_scalar field_m::operator_laplacian_scalar interface~operator( .laplacian. ) field_m::operator( .laplacian. ) interface~operator( .laplacian. )->proc~operator_laplacian_scalar Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Source Code operator_laplacian_scalar Source Code function operator_laplacian_scalar ( a ) !! スカラー場のラプラシアン real ( DR ), dimension ( 0 : NXPP1 , 0 : NYPP1 , 0 : NZPP1 ), intent ( in ) :: a !! 入力スカラー場 real ( DR ), dimension ( 0 : NXPP1 , 0 : NYPP1 , 0 : NZPP1 ) :: operator_laplacian_scalar !! 計算結果 integer :: i , j , k real ( DR ) :: dx2 , dy2 , dz2 dx2 = grid % d2 % x ! x方向の2階偏微分演算用定数 dy2 = grid % d2 % y ! y方向の2階偏微分演算用定数 dz2 = grid % d2 % z ! z方向の2階偏微分演算用定数 do k = 1 , NZPP ! 境界上の格子点を飛ばして、シミュレーション領域内部 ! の格子点上で差分法により計算する do j = 1 , NYPP do i = 1 , NXPP operator_laplacian_scalar ( i , j , k ) & = dx2 * ( a ( i + 1 , j , k ) - 2 * a ( i , j , k ) + a ( i - 1 , j , k )) & + dy2 * ( a ( i , j + 1 , k ) - 2 * a ( i , j , k ) + a ( i , j - 1 , k )) & + dz2 * ( a ( i , j , k + 1 ) - 2 * a ( i , j , k ) + a ( i , j , k - 1 )) end do end do end do call field__boundary_condition ( operator_laplacian_scalar ) ! 境界の格子点は境界条件ルーチンで設定する end function operator_laplacian_scalar","tags":"","loc":"proc/operator_laplacian_scalar.html"},{"title":"operator_laplacian_vector – Smoke Ring","text":"private  function operator_laplacian_vector(a) ベクトル場のラプラシアン Arguments Type Intent Optional Attributes Name type( field__vector_t ), intent(in) :: a 入力ベクトル場 Return Value type( field__vector_t ) 計算結果 Calls proc~~operator_laplacian_vector~~CallsGraph proc~operator_laplacian_vector field_m::operator_laplacian_vector interface~field__boundary_condition field_m::field__boundary_condition proc~operator_laplacian_vector->interface~field__boundary_condition x x proc~operator_laplacian_vector->x y y proc~operator_laplacian_vector->y z z proc~operator_laplacian_vector->z proc~boundary_condition_scalar field_m::boundary_condition_scalar interface~field__boundary_condition->proc~boundary_condition_scalar proc~boundary_condition_vector field_m::boundary_condition_vector interface~field__boundary_condition->proc~boundary_condition_vector mpiut__barrier mpiut__barrier proc~boundary_condition_scalar->mpiut__barrier mpiut__exchange mpiut__exchange proc~boundary_condition_scalar->mpiut__exchange proc~boundary_condition_vector->mpiut__barrier proc~boundary_condition_vector->mpiut__exchange Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~operator_laplacian_vector~~CalledByGraph proc~operator_laplacian_vector field_m::operator_laplacian_vector interface~operator( .laplacian. ) field_m::operator( .laplacian. ) interface~operator( .laplacian. )->proc~operator_laplacian_vector Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Source Code operator_laplacian_vector Source Code function operator_laplacian_vector ( a ) !! ベクトル場のラプラシアン type ( field__vector_t ), intent ( in ) :: a !! 入力ベクトル場 type ( field__vector_t ) :: operator_laplacian_vector !! 計算結果 integer :: i , j , k real ( DR ) :: dx2 , dy2 , dz2 dx2 = grid % d2 % x ! x方向の2階偏微分演算用定数 dy2 = grid % d2 % y ! y方向の2階偏微分演算用定数 dz2 = grid % d2 % z ! z方向の2階偏微分演算用定数 do k = 1 , NZPP ! 境界上の格子点を飛ばして、シミュレーション領域内部 ! の格子点上で差分法により計算する do j = 1 , NYPP do i = 1 , NXPP operator_laplacian_vector % x ( i , j , k ) & = dx2 * ( a % x ( i + 1 , j , k ) - 2 * a % x ( i , j , k ) + a % x ( i - 1 , j , k )) & + dy2 * ( a % x ( i , j + 1 , k ) - 2 * a % x ( i , j , k ) + a % x ( i , j - 1 , k )) & + dz2 * ( a % x ( i , j , k + 1 ) - 2 * a % x ( i , j , k ) + a % x ( i , j , k - 1 )) operator_laplacian_vector % y ( i , j , k ) & = dx2 * ( a % y ( i + 1 , j , k ) - 2 * a % y ( i , j , k ) + a % y ( i - 1 , j , k )) & + dy2 * ( a % y ( i , j + 1 , k ) - 2 * a % y ( i , j , k ) + a % y ( i , j - 1 , k )) & + dz2 * ( a % y ( i , j , k + 1 ) - 2 * a % y ( i , j , k ) + a % y ( i , j , k - 1 )) operator_laplacian_vector % z ( i , j , k ) & = dx2 * ( a % z ( i + 1 , j , k ) - 2 * a % z ( i , j , k ) + a % z ( i - 1 , j , k )) & + dy2 * ( a % z ( i , j + 1 , k ) - 2 * a % z ( i , j , k ) + a % z ( i , j - 1 , k )) & + dz2 * ( a % z ( i , j , k + 1 ) - 2 * a % z ( i , j , k ) + a % z ( i , j , k - 1 )) end do end do end do call field__boundary_condition ( operator_laplacian_vector ) ! 境界の格子点は境界条件ルーチンで設定する end function operator_laplacian_vector","tags":"","loc":"proc/operator_laplacian_vector.html"},{"title":"operator_real_times_vector – Smoke Ring","text":"private  function operator_real_times_vector(real, vec) 実数にベクトル場を掛ける演算子 Arguments Type Intent Optional Attributes Name real(kind=DR), intent(in) :: real 掛ける実数 type( field__vector_t ), intent(in) :: vec 流体場 Return Value type( field__vector_t ) 計算結果 Called by proc~~operator_real_times_vector~~CalledByGraph proc~operator_real_times_vector field_m::operator_real_times_vector interface~operator( ASTERISK )~2 field_m::operator( * ) interface~operator( ASTERISK )~2->proc~operator_real_times_vector Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Source Code operator_real_times_vector Source Code function operator_real_times_vector ( real , vec ) !! 実数にベクトル場を掛ける演算子 real ( DR ), intent ( in ) :: real !! 掛ける実数 type ( field__vector_t ), intent ( in ) :: vec !! 流体場 type ( field__vector_t ) :: operator_real_times_vector !! 計算結果 operator_real_times_vector % x = real * ( vec % x ) operator_real_times_vector % y = real * ( vec % y ) operator_real_times_vector % z = real * ( vec % z ) end function operator_real_times_vector","tags":"","loc":"proc/operator_real_times_vector.html"},{"title":"operator_scalar_times_vector – Smoke Ring","text":"private  function operator_scalar_times_vector(scalar, vec) スカラー場にベクトル場を掛ける演算子 Arguments Type Intent Optional Attributes Name real(kind=DR), intent(in), dimension(0:NXPP1,0:NYPP1,0:NZPP1) :: scalar スカラー場 type( field__vector_t ), intent(in) :: vec ベクトル場 Return Value type( field__vector_t ) 計算結果 Called by proc~~operator_scalar_times_vector~~CalledByGraph proc~operator_scalar_times_vector field_m::operator_scalar_times_vector interface~operator( ASTERISK )~2 field_m::operator( * ) interface~operator( ASTERISK )~2->proc~operator_scalar_times_vector Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Source Code operator_scalar_times_vector Source Code function operator_scalar_times_vector ( scalar , vec ) !! スカラー場にベクトル場を掛ける演算子 real ( DR ), dimension ( 0 : NXPP1 , 0 : NYPP1 , 0 : NZPP1 ), intent ( in ) :: scalar !! スカラー場 type ( field__vector_t ), intent ( in ) :: vec !! ベクトル場 type ( field__vector_t ) :: operator_scalar_times_vector !! 計算結果 operator_scalar_times_vector % x = scalar * ( vec % x ) operator_scalar_times_vector % y = scalar * ( vec % y ) operator_scalar_times_vector % z = scalar * ( vec % z ) end function operator_scalar_times_vector","tags":"","loc":"proc/operator_scalar_times_vector.html"},{"title":"operator_scalarintegral – Smoke Ring","text":"private  function operator_scalarintegral(a) スカラー場の体積積分演算子 Arguments Type Intent Optional Attributes Name real(kind=DR), intent(in), dimension(0:NXPP1,0:NYPP1,0:NZPP1) :: a スカラー場 Return Value real(kind=DR) 体積積分結果 Called by proc~~operator_scalarintegral~~CalledByGraph proc~operator_scalarintegral field_m::operator_scalarintegral interface~operator( .scalarintegral. ) field_m::operator( .scalarintegral. ) interface~operator( .scalarintegral. )->proc~operator_scalarintegral Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Source Code operator_scalarintegral Source Code function operator_scalarintegral ( a ) !! スカラー場の体積積分演算子 real ( DR ), dimension ( 0 : NXPP1 , 0 : NYPP1 , 0 : NZPP1 ), intent ( in ) :: a !! スカラー場 real ( DR ) :: operator_scalarintegral !! 体積積分結果 real ( DR ) :: dvol dvol = ( grid % delta % x ) * ( grid % delta % y ) * ( grid % delta % z ) ! 現在のシュミレーションでは格子間隔はx, y, z それぞれに ! 一様であることを仮定している。つまりdx, dy, dzは空間位置に ! 依存せず一定である。 operator_scalarintegral = sum ( a ( 1 : NXPP , & 1 : NYPP , & 1 : NZPP ) ) * dvol ! ここで配列演算の添字が0:NXPP1等ではなく1:NXPPなどに ! 限定されていることに注意。これは体積積分の範囲を計算領域の ! 内部に限定していること、つまり境界上の格子点を除いて ! 積分していることを意味する。境界上の格子点まで ! 入れると重複してカウントしてしまうからである end function operator_scalarintegral","tags":"","loc":"proc/operator_scalarintegral.html"},{"title":"operator_vector_add – Smoke Ring","text":"private  function operator_vector_add(a, b) ベクトル場の和の演算子 Arguments Type Intent Optional Attributes Name type( field__vector_t ), intent(in) :: a 和をとるベクトル場 type( field__vector_t ), intent(in) :: b 和をとるベクトル場 Return Value type( field__vector_t ) 計算結果 Called by proc~~operator_vector_add~~CalledByGraph proc~operator_vector_add field_m::operator_vector_add interface~operator( + )~2 field_m::operator( + ) interface~operator( + )~2->proc~operator_vector_add Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Source Code operator_vector_add Source Code function operator_vector_add ( a , b ) !! ベクトル場の和の演算子 type ( field__vector_t ), intent ( in ) :: a , b !! 和をとるベクトル場 type ( field__vector_t ) :: operator_vector_add !! 計算結果 operator_vector_add % x = a % x + b % x operator_vector_add % y = a % y + b % y operator_vector_add % z = a % z + b % z end function operator_vector_add","tags":"","loc":"proc/operator_vector_add.html"},{"title":"operator_vector_divby_scalar – Smoke Ring","text":"private  function operator_vector_divby_scalar(vec, scalar) ベクトル場の各成分をスカラー場で割る Arguments Type Intent Optional Attributes Name type( field__vector_t ), intent(in) :: vec ベクトル場 real(kind=DR), intent(in), dimension(0:NXPP1,0:NYPP1,0:NZPP1) :: scalar スカラー場 Return Value type( field__vector_t ) 計算結果 Called by proc~~operator_vector_divby_scalar~~CalledByGraph proc~operator_vector_divby_scalar field_m::operator_vector_divby_scalar interface~operator( SLASH ) field_m::operator( / ) interface~operator( SLASH )->proc~operator_vector_divby_scalar Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Source Code operator_vector_divby_scalar Source Code function operator_vector_divby_scalar ( vec , scalar ) !! ベクトル場の各成分をスカラー場で割る type ( field__vector_t ), intent ( in ) :: vec !! ベクトル場 real ( DR ), dimension ( 0 : NXPP1 , 0 : NYPP1 , 0 : NZPP1 ), intent ( in ) :: scalar !! スカラー場 type ( field__vector_t ) :: operator_vector_divby_scalar !! 計算結果 operator_vector_divby_scalar % x = ( vec % x ) / scalar operator_vector_divby_scalar % y = ( vec % y ) / scalar operator_vector_divby_scalar % z = ( vec % z ) / scalar end function operator_vector_divby_scalar","tags":"","loc":"proc/operator_vector_divby_scalar.html"},{"title":"operator_vector_times_real – Smoke Ring","text":"private  function operator_vector_times_real(vec, real) ベクトル場の実数倍の演算子 Arguments Type Intent Optional Attributes Name type( field__vector_t ), intent(in) :: vec ベクトル場 real(kind=DR), intent(in) :: real 掛ける実数 Return Value type( field__vector_t ) 計算結果 Called by proc~~operator_vector_times_real~~CalledByGraph proc~operator_vector_times_real field_m::operator_vector_times_real interface~operator( ASTERISK )~2 field_m::operator( * ) interface~operator( ASTERISK )~2->proc~operator_vector_times_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Source Code operator_vector_times_real Source Code function operator_vector_times_real ( vec , real ) !! ベクトル場の実数倍の演算子 type ( field__vector_t ), intent ( in ) :: vec !! ベクトル場 real ( DR ), intent ( in ) :: real !! 掛ける実数 type ( field__vector_t ) :: operator_vector_times_real !! 計算結果 operator_vector_times_real % x = real * ( vec % x ) operator_vector_times_real % y = real * ( vec % y ) operator_vector_times_real % z = real * ( vec % z ) end function operator_vector_times_real","tags":"","loc":"proc/operator_vector_times_real.html"},{"title":"operator_vector_times_scalar – Smoke Ring","text":"private  function operator_vector_times_scalar(vec, scalar) ベクトル場にスカラー場を掛ける Arguments Type Intent Optional Attributes Name type( field__vector_t ), intent(in) :: vec ベクトル場 real(kind=DR), intent(in), dimension(0:NXPP1,0:NYPP1,0:NZPP1) :: scalar スカラー場 Return Value type( field__vector_t ) 計算結果 Called by proc~~operator_vector_times_scalar~~CalledByGraph proc~operator_vector_times_scalar field_m::operator_vector_times_scalar interface~operator( ASTERISK )~2 field_m::operator( * ) interface~operator( ASTERISK )~2->proc~operator_vector_times_scalar Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Source Code operator_vector_times_scalar Source Code function operator_vector_times_scalar ( vec , scalar ) !! ベクトル場にスカラー場を掛ける type ( field__vector_t ), intent ( in ) :: vec !! ベクトル場 real ( DR ), dimension ( 0 : NXPP1 , 0 : NYPP1 , 0 : NZPP1 ), intent ( in ) :: scalar !! スカラー場 type ( field__vector_t ) :: operator_vector_times_scalar !! 計算結果 operator_vector_times_scalar % x = scalar * ( vec % x ) operator_vector_times_scalar % y = scalar * ( vec % y ) operator_vector_times_scalar % z = scalar * ( vec % z ) end function operator_vector_times_scalar","tags":"","loc":"proc/operator_vector_times_scalar.html"},{"title":"assignment_real_to_vector – Smoke Ring","text":"private  subroutine assignment_real_to_vector(vector, real) ベクトル場に実数を代入。\n初期条件で0にセットするときに使う。 Arguments Type Intent Optional Attributes Name type( field__vector_t ), intent(out) :: vector ベクトル場 real(kind=DR), intent(in) :: real 代入する実数 Called by proc~~assignment_real_to_vector~~CalledByGraph proc~assignment_real_to_vector field_m::assignment_real_to_vector interface~assignment( = )~2 field_m::assignment( = ) interface~assignment( = )~2->proc~assignment_real_to_vector Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Source Code assignment_real_to_vector Source Code subroutine assignment_real_to_vector ( vector , real ) !! ベクトル場に実数を代入。 !! 初期条件で0にセットするときに使う。 type ( field__vector_t ), intent ( out ) :: vector !! ベクトル場 real ( DR ), intent ( in ) :: real !! 代入する実数 vector % x (:,:,:) = real vector % y (:,:,:) = real vector % z (:,:,:) = real end subroutine assignment_real_to_vector","tags":"","loc":"proc/assignment_real_to_vector.html"},{"title":"boundary_condition_scalar – Smoke Ring","text":"private  subroutine boundary_condition_scalar(scalar) スカラー場の境界条件設定\nプロセス間通信で領域境界データを交換 Arguments Type Intent Optional Attributes Name real(kind=DR), intent(inout), dimension(0:NXPP1,0:NYPP1,0:NZPP1) :: scalar スカラー場 周期境界条件の設定 Calls proc~~boundary_condition_scalar~~CallsGraph proc~boundary_condition_scalar field_m::boundary_condition_scalar mpiut__barrier mpiut__barrier proc~boundary_condition_scalar->mpiut__barrier mpiut__exchange mpiut__exchange proc~boundary_condition_scalar->mpiut__exchange Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~boundary_condition_scalar~~CalledByGraph proc~boundary_condition_scalar field_m::boundary_condition_scalar interface~field__boundary_condition field_m::field__boundary_condition interface~field__boundary_condition->proc~boundary_condition_scalar proc~operator_curl field_m::operator_curl proc~operator_curl->interface~field__boundary_condition proc~operator_div field_m::operator_div proc~operator_div->interface~field__boundary_condition proc~operator_laplacian_scalar field_m::operator_laplacian_scalar proc~operator_laplacian_scalar->interface~field__boundary_condition proc~operator_laplacian_vector field_m::operator_laplacian_vector proc~operator_laplacian_vector->interface~field__boundary_condition proc~set_drive_force_field solver_m::set_drive_force_field proc~set_drive_force_field->interface~field__boundary_condition interface~operator( .curl. ) field_m::operator( .curl. ) interface~operator( .curl. )->proc~operator_curl interface~operator( .div. ) field_m::operator( .div. ) interface~operator( .div. )->proc~operator_div interface~operator( .laplacian. ) field_m::operator( .laplacian. ) interface~operator( .laplacian. )->proc~operator_laplacian_scalar interface~operator( .laplacian. )->proc~operator_laplacian_vector proc~solver__initialize solver_m::solver_t%solver__initialize proc~solver__initialize->proc~set_drive_force_field Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Source Code boundary_condition_scalar Source Code subroutine boundary_condition_scalar ( scalar ) !! スカラー場の境界条件設定 real ( DR ), dimension ( 0 : NXPP1 , 0 : NYPP1 , 0 : NZPP1 ), intent ( inout ) :: scalar !! スカラー場 !! 周期境界条件の設定 call mpiut__exchange ( Parallel % comm , & Parallel % periodic_pair , & scalar ) call mpiut__barrier ( Parallel % comm ) !! プロセス間通信で領域境界データを交換 call mpiut__exchange ( Parallel % comm , & Parallel % rank % next , & scalar ) call mpiut__barrier ( Parallel % comm ) end subroutine boundary_condition_scalar","tags":"","loc":"proc/boundary_condition_scalar.html"},{"title":"boundary_condition_vector – Smoke Ring","text":"private  subroutine boundary_condition_vector(vector) ベクトル場の境界条件設定\nプロセス間通信で領域境界データを交換 Arguments Type Intent Optional Attributes Name type( field__vector_t ), intent(inout) :: vector ベクトル場 周期境界条件設定 Calls proc~~boundary_condition_vector~~CallsGraph proc~boundary_condition_vector field_m::boundary_condition_vector mpiut__barrier mpiut__barrier proc~boundary_condition_vector->mpiut__barrier mpiut__exchange mpiut__exchange proc~boundary_condition_vector->mpiut__exchange Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~boundary_condition_vector~~CalledByGraph proc~boundary_condition_vector field_m::boundary_condition_vector interface~field__boundary_condition field_m::field__boundary_condition interface~field__boundary_condition->proc~boundary_condition_vector proc~operator_curl field_m::operator_curl proc~operator_curl->interface~field__boundary_condition proc~operator_div field_m::operator_div proc~operator_div->interface~field__boundary_condition proc~operator_laplacian_scalar field_m::operator_laplacian_scalar proc~operator_laplacian_scalar->interface~field__boundary_condition proc~operator_laplacian_vector field_m::operator_laplacian_vector proc~operator_laplacian_vector->interface~field__boundary_condition proc~set_drive_force_field solver_m::set_drive_force_field proc~set_drive_force_field->interface~field__boundary_condition interface~operator( .curl. ) field_m::operator( .curl. ) interface~operator( .curl. )->proc~operator_curl interface~operator( .div. ) field_m::operator( .div. ) interface~operator( .div. )->proc~operator_div interface~operator( .laplacian. ) field_m::operator( .laplacian. ) interface~operator( .laplacian. )->proc~operator_laplacian_scalar interface~operator( .laplacian. )->proc~operator_laplacian_vector proc~solver__initialize solver_m::solver_t%solver__initialize proc~solver__initialize->proc~set_drive_force_field Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Source Code boundary_condition_vector Source Code subroutine boundary_condition_vector ( vector ) !! ベクトル場の境界条件設定 type ( field__vector_t ), intent ( inout ) :: vector !! ベクトル場 !! 周期境界条件設定 call mpiut__exchange ( Parallel % comm , & Parallel % periodic_pair , & vector % x , & vector % y , & vector % z ) call mpiut__barrier ( Parallel % comm ) !! プロセス間通信で領域境界データを交換 call mpiut__exchange ( Parallel % comm , & Parallel % rank % next , & vector % x , & vector % y , & vector % z ) call mpiut__barrier ( Parallel % comm ) end subroutine boundary_condition_vector","tags":"","loc":"proc/boundary_condition_vector.html"},{"title":"assignment( = ) – Smoke Ring","text":"public interface assignment( = ) 各種構造体に代入記号が使えるように定義 Calls interface~~assignment( = )~2~~CallsGraph interface~assignment( = )~2 field_m::assignment( = ) proc~assignment_real_to_vector field_m::assignment_real_to_vector interface~assignment( = )~2->proc~assignment_real_to_vector Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Module Procedures assignment_real_to_vector Module Procedures private  subroutine assignment_real_to_vector (vector, real) ベクトル場に実数を代入。\n初期条件で0にセットするときに使う。 Arguments Type Intent Optional Attributes Name type( field__vector_t ), intent(out) :: vector ベクトル場 real(kind=DR), intent(in) :: real 代入する実数","tags":"","loc":"interface/assignment( = )~2.html"},{"title":"field__boundary_condition – Smoke Ring","text":"public interface field__boundary_condition 境界条件呼び出しルーチンの多重定義\n境界条件を設定する変数の種類によって\n実際に使用するルーチンが違うが、\n呼び出し側では統一した名前でcallする。\nコンパイラは引数の型で使用するルーチンを\n判断する。 Calls interface~~field__boundary_condition~~CallsGraph interface~field__boundary_condition field_m::field__boundary_condition proc~boundary_condition_scalar field_m::boundary_condition_scalar interface~field__boundary_condition->proc~boundary_condition_scalar proc~boundary_condition_vector field_m::boundary_condition_vector interface~field__boundary_condition->proc~boundary_condition_vector mpiut__barrier mpiut__barrier proc~boundary_condition_scalar->mpiut__barrier mpiut__exchange mpiut__exchange proc~boundary_condition_scalar->mpiut__exchange proc~boundary_condition_vector->mpiut__barrier proc~boundary_condition_vector->mpiut__exchange Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~field__boundary_condition~~CalledByGraph interface~field__boundary_condition field_m::field__boundary_condition proc~operator_curl field_m::operator_curl proc~operator_curl->interface~field__boundary_condition proc~operator_div field_m::operator_div proc~operator_div->interface~field__boundary_condition proc~operator_laplacian_scalar field_m::operator_laplacian_scalar proc~operator_laplacian_scalar->interface~field__boundary_condition proc~operator_laplacian_vector field_m::operator_laplacian_vector proc~operator_laplacian_vector->interface~field__boundary_condition proc~set_drive_force_field solver_m::set_drive_force_field proc~set_drive_force_field->interface~field__boundary_condition interface~operator( .curl. ) field_m::operator( .curl. ) interface~operator( .curl. )->proc~operator_curl interface~operator( .div. ) field_m::operator( .div. ) interface~operator( .div. )->proc~operator_div interface~operator( .laplacian. ) field_m::operator( .laplacian. ) interface~operator( .laplacian. )->proc~operator_laplacian_scalar interface~operator( .laplacian. )->proc~operator_laplacian_vector proc~solver__initialize solver_m::solver_t%solver__initialize proc~solver__initialize->proc~set_drive_force_field Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Module Procedures boundary_condition_scalar boundary_condition_vector Module Procedures private  subroutine boundary_condition_scalar (scalar) スカラー場の境界条件設定\nプロセス間通信で領域境界データを交換 Arguments Type Intent Optional Attributes Name real(kind=DR), intent(inout), dimension(0:NXPP1,0:NYPP1,0:NZPP1) :: scalar スカラー場 Read more… private  subroutine boundary_condition_vector (vector) ベクトル場の境界条件設定\nプロセス間通信で領域境界データを交換 Arguments Type Intent Optional Attributes Name type( field__vector_t ), intent(inout) :: vector ベクトル場 Read more…","tags":"","loc":"interface/field__boundary_condition.html"},{"title":"operator( * ) – Smoke Ring","text":"public interface operator( * ) 各種構造体に掛け算記号が使えるように定義 Calls interface~~operator( ASTERISK )~2~~CallsGraph interface~operator( ASTERISK )~2 field_m::operator( * ) proc~operator_real_times_vector field_m::operator_real_times_vector interface~operator( ASTERISK )~2->proc~operator_real_times_vector proc~operator_scalar_times_vector field_m::operator_scalar_times_vector interface~operator( ASTERISK )~2->proc~operator_scalar_times_vector proc~operator_vector_times_real field_m::operator_vector_times_real interface~operator( ASTERISK )~2->proc~operator_vector_times_real proc~operator_vector_times_scalar field_m::operator_vector_times_scalar interface~operator( ASTERISK )~2->proc~operator_vector_times_scalar Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Module Procedures operator_real_times_vector operator_scalar_times_vector operator_vector_times_real operator_vector_times_scalar Module Procedures private  function operator_real_times_vector (real, vec) 実数にベクトル場を掛ける演算子 Arguments Type Intent Optional Attributes Name real(kind=DR), intent(in) :: real 掛ける実数 type( field__vector_t ), intent(in) :: vec 流体場 Return Value type( field__vector_t ) 計算結果 private  function operator_scalar_times_vector (scalar, vec) スカラー場にベクトル場を掛ける演算子 Arguments Type Intent Optional Attributes Name real(kind=DR), intent(in), dimension(0:NXPP1,0:NYPP1,0:NZPP1) :: scalar スカラー場 type( field__vector_t ), intent(in) :: vec ベクトル場 Return Value type( field__vector_t ) 計算結果 private  function operator_vector_times_real (vec, real) ベクトル場の実数倍の演算子 Arguments Type Intent Optional Attributes Name type( field__vector_t ), intent(in) :: vec ベクトル場 real(kind=DR), intent(in) :: real 掛ける実数 Return Value type( field__vector_t ) 計算結果 private  function operator_vector_times_scalar (vec, scalar) ベクトル場にスカラー場を掛ける Arguments Type Intent Optional Attributes Name type( field__vector_t ), intent(in) :: vec ベクトル場 real(kind=DR), intent(in), dimension(0:NXPP1,0:NYPP1,0:NZPP1) :: scalar スカラー場 Return Value type( field__vector_t ) 計算結果","tags":"","loc":"interface/operator( ASTERISK )~2.html"},{"title":"operator( + ) – Smoke Ring","text":"public interface operator( + ) 構造体全要素の足し算を+記号で書けるように定義 Calls interface~~operator( + )~2~~CallsGraph interface~operator( + )~2 field_m::operator( + ) proc~operator_vector_add field_m::operator_vector_add interface~operator( + )~2->proc~operator_vector_add Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Module Procedures operator_vector_add Module Procedures private  function operator_vector_add (a, b) ベクトル場の和の演算子 Arguments Type Intent Optional Attributes Name type( field__vector_t ), intent(in) :: a 和をとるベクトル場 type( field__vector_t ), intent(in) :: b 和をとるベクトル場 Return Value type( field__vector_t ) 計算結果","tags":"","loc":"interface/operator( + )~2.html"},{"title":"operator( .curl. ) – Smoke Ring","text":"public interface operator( .curl. ) ベクトル解析のcurl演算子 Calls interface~~operator( .curl. )~~CallsGraph interface~operator( .curl. ) field_m::operator( .curl. ) proc~operator_curl field_m::operator_curl interface~operator( .curl. )->proc~operator_curl interface~field__boundary_condition field_m::field__boundary_condition proc~operator_curl->interface~field__boundary_condition x x proc~operator_curl->x y y proc~operator_curl->y z z proc~operator_curl->z proc~boundary_condition_scalar field_m::boundary_condition_scalar interface~field__boundary_condition->proc~boundary_condition_scalar proc~boundary_condition_vector field_m::boundary_condition_vector interface~field__boundary_condition->proc~boundary_condition_vector mpiut__barrier mpiut__barrier proc~boundary_condition_scalar->mpiut__barrier mpiut__exchange mpiut__exchange proc~boundary_condition_scalar->mpiut__exchange proc~boundary_condition_vector->mpiut__barrier proc~boundary_condition_vector->mpiut__exchange Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Module Procedures operator_curl Module Procedures private  function operator_curl (a) ベクトル場のcurl Arguments Type Intent Optional Attributes Name type( field__vector_t ), intent(in) :: a これのcurlをとる Return Value type( field__vector_t ) curlした結果","tags":"","loc":"interface/operator( .curl. ).html"},{"title":"operator( .div. ) – Smoke Ring","text":"public interface operator( .div. ) ベクトル解析のdivergence演算子 Calls interface~~operator( .div. )~~CallsGraph interface~operator( .div. ) field_m::operator( .div. ) proc~operator_div field_m::operator_div interface~operator( .div. )->proc~operator_div interface~field__boundary_condition field_m::field__boundary_condition proc~operator_div->interface~field__boundary_condition x x proc~operator_div->x y y proc~operator_div->y z z proc~operator_div->z proc~boundary_condition_scalar field_m::boundary_condition_scalar interface~field__boundary_condition->proc~boundary_condition_scalar proc~boundary_condition_vector field_m::boundary_condition_vector interface~field__boundary_condition->proc~boundary_condition_vector mpiut__barrier mpiut__barrier proc~boundary_condition_scalar->mpiut__barrier mpiut__exchange mpiut__exchange proc~boundary_condition_scalar->mpiut__exchange proc~boundary_condition_vector->mpiut__barrier proc~boundary_condition_vector->mpiut__exchange Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Module Procedures operator_div Module Procedures private  function operator_div (a) ベクトル場のdivergence Arguments Type Intent Optional Attributes Name type( field__vector_t ), intent(in) :: a これのdivをとる Return Value real(kind=DR), dimension(0:NXPP1,0:NYPP1,0:NZPP1) 結果","tags":"","loc":"interface/operator( .div. ).html"},{"title":"operator( .dot. ) – Smoke Ring","text":"public interface operator( .dot. ) ベクトル解析の内積演算子 Calls interface~~operator( .dot. )~~CallsGraph interface~operator( .dot. ) field_m::operator( .dot. ) proc~operator_dot_product field_m::operator_dot_product interface~operator( .dot. )->proc~operator_dot_product Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Module Procedures operator_dot_product Module Procedures private  function operator_dot_product (a, b) ベクトル場の内積 Arguments Type Intent Optional Attributes Name type( field__vector_t ), intent(in) :: a 内積をとるベクトル場 type( field__vector_t ), intent(in) :: b 内積をとるベクトル場 Return Value real(kind=DR), dimension(0:NXPP1,0:NYPP1,0:NZPP1) 計算結果","tags":"","loc":"interface/operator( .dot. ).html"},{"title":"operator( .laplacian. ) – Smoke Ring","text":"public interface operator( .laplacian. ) ラプラシアン演算子\nスカラー場とベクトル場用の2つの多重定義 Calls interface~~operator( .laplacian. )~~CallsGraph interface~operator( .laplacian. ) field_m::operator( .laplacian. ) proc~operator_laplacian_scalar field_m::operator_laplacian_scalar interface~operator( .laplacian. )->proc~operator_laplacian_scalar proc~operator_laplacian_vector field_m::operator_laplacian_vector interface~operator( .laplacian. )->proc~operator_laplacian_vector interface~field__boundary_condition field_m::field__boundary_condition proc~operator_laplacian_scalar->interface~field__boundary_condition proc~operator_laplacian_vector->interface~field__boundary_condition x x proc~operator_laplacian_vector->x y y proc~operator_laplacian_vector->y z z proc~operator_laplacian_vector->z proc~boundary_condition_scalar field_m::boundary_condition_scalar interface~field__boundary_condition->proc~boundary_condition_scalar proc~boundary_condition_vector field_m::boundary_condition_vector interface~field__boundary_condition->proc~boundary_condition_vector mpiut__barrier mpiut__barrier proc~boundary_condition_scalar->mpiut__barrier mpiut__exchange mpiut__exchange proc~boundary_condition_scalar->mpiut__exchange proc~boundary_condition_vector->mpiut__barrier proc~boundary_condition_vector->mpiut__exchange Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Module Procedures operator_laplacian_scalar operator_laplacian_vector Module Procedures private  function operator_laplacian_scalar (a) スカラー場のラプラシアン Arguments Type Intent Optional Attributes Name real(kind=DR), intent(in), dimension(0:NXPP1,0:NYPP1,0:NZPP1) :: a 入力スカラー場 Return Value real(kind=DR), dimension(0:NXPP1,0:NYPP1,0:NZPP1) 計算結果 private  function operator_laplacian_vector (a) ベクトル場のラプラシアン Arguments Type Intent Optional Attributes Name type( field__vector_t ), intent(in) :: a 入力ベクトル場 Return Value type( field__vector_t ) 計算結果","tags":"","loc":"interface/operator( .laplacian. ).html"},{"title":"operator( .scalarintegral. ) – Smoke Ring","text":"public interface operator( .scalarintegral. ) 任意のスカラー場の体積積分をする演算子 Calls interface~~operator( .scalarintegral. )~~CallsGraph interface~operator( .scalarintegral. ) field_m::operator( .scalarintegral. ) proc~operator_scalarintegral field_m::operator_scalarintegral interface~operator( .scalarintegral. )->proc~operator_scalarintegral Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Module Procedures operator_scalarintegral Module Procedures private  function operator_scalarintegral (a) スカラー場の体積積分演算子 Arguments Type Intent Optional Attributes Name real(kind=DR), intent(in), dimension(0:NXPP1,0:NYPP1,0:NZPP1) :: a スカラー場 Return Value real(kind=DR) 体積積分結果","tags":"","loc":"interface/operator( .scalarintegral. ).html"},{"title":"operator( .x. ) – Smoke Ring","text":"public interface operator( .x. ) ベクトル解析の外積演算子 Calls interface~~operator( .x. )~~CallsGraph interface~operator( .x. ) field_m::operator( .x. ) proc~operator_cross_product field_m::operator_cross_product interface~operator( .x. )->proc~operator_cross_product Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Module Procedures operator_cross_product Module Procedures private  function operator_cross_product (a, b) ベクトル場の外積 Arguments Type Intent Optional Attributes Name type( field__vector_t ), intent(in) :: a 掛けるベクトル場 type( field__vector_t ), intent(in) :: b 掛けるベクトル場 Return Value type( field__vector_t ) 外積","tags":"","loc":"interface/operator( .x. ).html"},{"title":"operator( / ) – Smoke Ring","text":"public interface operator( / ) ベクトル場の3成分をあるスカラー場で割り算する\n操作は何度か出てくる（例えば質量フラックスfluxから\n速度場velocity_vectorを求めるときに\nvelocity_vector = flux / mass_density\nという割り算が必要である）この計算を\nスラッシュ記号一つで書けるように定義 Calls interface~~operator( SLASH )~~CallsGraph interface~operator( SLASH ) field_m::operator( / ) proc~operator_vector_divby_scalar field_m::operator_vector_divby_scalar interface~operator( SLASH )->proc~operator_vector_divby_scalar Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Module Procedures operator_vector_divby_scalar Module Procedures private  function operator_vector_divby_scalar (vec, scalar) ベクトル場の各成分をスカラー場で割る Arguments Type Intent Optional Attributes Name type( field__vector_t ), intent(in) :: vec ベクトル場 real(kind=DR), intent(in), dimension(0:NXPP1,0:NYPP1,0:NZPP1) :: scalar スカラー場 Return Value type( field__vector_t ) 計算結果","tags":"","loc":"interface/operator( SLASH ).html"},{"title":"grid__i_have_gi – Smoke Ring","text":"private  function grid__i_have_gi(grid, gi) result(ans) Type Bound grid_t Arguments Type Intent Optional Attributes Name class( grid_t ), intent(in) :: grid integer, intent(in) :: gi Return Value logical Contents Source Code grid__i_have_gi Source Code function grid__i_have_gi ( grid , gi ) result ( ans ) class ( grid_t ), intent ( in ) :: grid integer , intent ( in ) :: gi logical :: ans ans = gi >= grid % global_ijk % gi ( 1 ) . and . & gi <= grid % global_ijk % gi ( NXPP ) end function grid__i_have_gi","tags":"","loc":"proc/grid__i_have_gi.html"},{"title":"grid__i_have_gijk – Smoke Ring","text":"private  function grid__i_have_gijk(grid, gi, gj, gk) result(ans) Type Bound grid_t Arguments Type Intent Optional Attributes Name class( grid_t ), intent(in) :: grid integer, intent(in) :: gi integer, intent(in) :: gj integer, intent(in) :: gk Return Value logical Calls proc~~grid__i_have_gijk~~CallsGraph proc~grid__i_have_gijk grid_m::grid_t%grid__i_have_gijk i_have_gi i_have_gi proc~grid__i_have_gijk->i_have_gi i_have_gj i_have_gj proc~grid__i_have_gijk->i_have_gj i_have_gk i_have_gk proc~grid__i_have_gijk->i_have_gk Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Source Code grid__i_have_gijk Source Code function grid__i_have_gijk ( grid , gi , gj , gk ) result ( ans ) class ( grid_t ), intent ( in ) :: grid integer , intent ( in ) :: gi , gj , gk logical :: ans ans = grid % i_have_gi ( gi ) . and . & grid % i_have_gj ( gj ) . and . & grid % i_have_gk ( gk ) end function grid__i_have_gijk","tags":"","loc":"proc/grid__i_have_gijk.html"},{"title":"grid__i_have_gj – Smoke Ring","text":"private  function grid__i_have_gj(grid, gj) result(ans) Type Bound grid_t Arguments Type Intent Optional Attributes Name class( grid_t ), intent(in) :: grid integer, intent(in) :: gj Return Value logical Contents Source Code grid__i_have_gj Source Code function grid__i_have_gj ( grid , gj ) result ( ans ) class ( grid_t ), intent ( in ) :: grid integer , intent ( in ) :: gj logical :: ans ans = gj >= grid % global_ijk % gj ( 1 ) . and . & gj <= grid % global_ijk % gj ( NYPP ) end function grid__i_have_gj","tags":"","loc":"proc/grid__i_have_gj.html"},{"title":"grid__i_have_gk – Smoke Ring","text":"private  function grid__i_have_gk(grid, gk) result(ans) Type Bound grid_t Arguments Type Intent Optional Attributes Name class( grid_t ), intent(in) :: grid integer, intent(in) :: gk Return Value logical Contents Source Code grid__i_have_gk Source Code function grid__i_have_gk ( grid , gk ) result ( ans ) class ( grid_t ), intent ( in ) :: grid integer , intent ( in ) :: gk logical :: ans ans = gk >= grid % global_ijk % gk ( 1 ) . and . & gk <= grid % global_ijk % gk ( NZPP ) end function grid__i_have_gk","tags":"","loc":"proc/grid__i_have_gk.html"},{"title":"initialize_global_ijk – Smoke Ring","text":"private  function initialize_global_ijk() result(gijk) Arguments None Return Value type( grid_global_ijk_t ) Called by proc~~initialize_global_ijk~~CalledByGraph proc~initialize_global_ijk grid_m::initialize_global_ijk proc~grid__initialize grid_m::grid_t%grid__initialize proc~grid__initialize->proc~initialize_global_ijk Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Source Code initialize_global_ijk Source Code function initialize_global_ijk () result ( gijk ) type ( grid_global_ijk_t ) :: gijk integer :: i , j , k do i = 0 , NXPP1 gijk % gi ( i ) = NXPP * Parallel % pos % index % i + i + 1 end do do j = 0 , NYPP1 gijk % gj ( j ) = NYPP * Parallel % pos % index % j + j + 1 end do do k = 0 , NZPP1 gijk % gk ( k ) = NZPP * Parallel % pos % index % k + k + 1 end do end function initialize_global_ijk","tags":"","loc":"proc/initialize_global_ijk.html"},{"title":"initialize_local_ijk_from_global_ijk – Smoke Ring","text":"private  function initialize_local_ijk_from_global_ijk(gijk) result(ans) Arguments Type Intent Optional Attributes Name type( grid_global_ijk_t ), intent(in) :: gijk Return Value type( grid_local_ijk_from_global_ijk_t ) < Called by proc~~initialize_local_ijk_from_global_ijk~~CalledByGraph proc~initialize_local_ijk_from_global_ijk grid_m::initialize_local_ijk_from_global_ijk proc~grid__initialize grid_m::grid_t%grid__initialize proc~grid__initialize->proc~initialize_local_ijk_from_global_ijk Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Source Code initialize_local_ijk_from_global_ijk Source Code function initialize_local_ijk_from_global_ijk ( gijk ) result ( ans ) type ( grid_global_ijk_t ), intent ( in ) :: gijk type ( grid_local_ijk_from_global_ijk_t ) :: ans !!> !      When NXPP = 4 and NPROC_X = 2, NX_GLOBAL = 10 ! !              gi=> 1   2   3   4   5   6   7   8   9   10 !                   o---o---o---o---o---o---o---o---o---o !            gi-1=> 0   1   2   3   4   5   6   7   8   9 !                   |                   |               . !                   |      [rank 0]     |               . !                   |                   |               . !             li => 0   1   2   3   4   5               . !                   |   |   |   |   |   |               . !                   0   1   2   3   4   5 <= gi-1-0*NXPP. !                   o---o---o---o---o---o---o---o---o---o !                                   |                   | !                                   |      [rank 1]     | !                                   |                   | !                            li =>  0   1   2   3   4   5 !                                   |   |   |   |   |   | !                     gi-1-1*NXPP=> 0   1   2   3   4   5 !!< integer :: gi , gj , gk do gi = 1 , NX_GLOBAL if ( gi < gijk % gi ( 0 ) . or . gi > gijk % gi ( NXPP1 ) ) then ans % li ( gi ) = NIL ! out of scope of this process else ans % li ( gi ) = gi - 1 - NXPP * Parallel % pos % index % i end if end do do gj = 1 , NY_GLOBAL if ( gj < gijk % gj ( 0 ) . or . gj > gijk % gj ( NYPP1 ) ) then ans % lj ( gj ) = NIL ! out of scope of this process else ans % lj ( gj ) = gj - 1 - NYPP * Parallel % pos % index % j end if end do do gk = 1 , NZ_GLOBAL if ( gk < gijk % gk ( 0 ) . or . gk > gijk % gk ( NZPP1 ) ) then ans % lk ( gk ) = NIL ! out of scope of this process else ans % lk ( gk ) = gk - 1 - NZPP * Parallel % pos % index % k end if end do end function initialize_local_ijk_from_global_ijk","tags":"","loc":"proc/initialize_local_ijk_from_global_ijk.html"},{"title":"initialize_pos – Smoke Ring","text":"private  function initialize_pos(gijk, pos_by_gijk) result(pos) Arguments Type Intent Optional Attributes Name type( grid_global_ijk_t ), intent(in) :: gijk type( grid_pos_by_global_ijk_t ), intent(in) :: pos_by_gijk Return Value type( grid__pos_t ) Calls proc~~initialize_pos~~CallsGraph proc~initialize_pos grid_m::initialize_pos x x proc~initialize_pos->x y y proc~initialize_pos->y z z proc~initialize_pos->z Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~initialize_pos~~CalledByGraph proc~initialize_pos grid_m::initialize_pos proc~grid__initialize grid_m::grid_t%grid__initialize proc~grid__initialize->proc~initialize_pos Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Source Code initialize_pos Source Code function initialize_pos ( gijk , pos_by_gijk ) result ( pos ) type ( grid_global_ijk_t ), intent ( in ) :: gijk type ( grid_pos_by_global_ijk_t ), intent ( in ) :: pos_by_gijk type ( grid__pos_t ) :: pos integer :: i , j , k do i = 0 , NXPP1 pos % x ( i ) = pos_by_gijk % x ( gijk % gi ( i ) ) end do do j = 0 , NYPP1 pos % y ( j ) = pos_by_gijk % y ( gijk % gj ( j ) ) end do do k = 0 , NZPP1 pos % z ( k ) = pos_by_gijk % z ( gijk % gk ( k ) ) end do end function initialize_pos","tags":"","loc":"proc/initialize_pos.html"},{"title":"initialize_pos_by_global_ijk – Smoke Ring","text":"private  function initialize_pos_by_global_ijk(dx, dy, dz) result(pos_gijk) Arguments Type Intent Optional Attributes Name real(kind=DR), intent(in) :: dx real(kind=DR), intent(in) :: dy real(kind=DR), intent(in) :: dz Return Value type( grid_pos_by_global_ijk_t ) Called by proc~~initialize_pos_by_global_ijk~~CalledByGraph proc~initialize_pos_by_global_ijk grid_m::initialize_pos_by_global_ijk proc~grid__initialize grid_m::grid_t%grid__initialize proc~grid__initialize->proc~initialize_pos_by_global_ijk Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Source Code initialize_pos_by_global_ijk Source Code function initialize_pos_by_global_ijk ( dx , dy , dz ) result ( pos_gijk ) real ( DR ), intent ( in ) :: dx , dy , dz type ( grid_pos_by_global_ijk_t ) :: pos_gijk integer :: gi , gj , gk do gi = 1 , NX_GLOBAL pos_gijk % x ( gi ) = XMIN + dx * ( gi - 1 ) end do do gj = 1 , NY_GLOBAL pos_gijk % y ( gj ) = YMIN + dy * ( gj - 1 ) end do do gk = 1 , NZ_GLOBAL pos_gijk % z ( gk ) = ZMIN + dz * ( gk - 1 ) end do end function initialize_pos_by_global_ijk","tags":"","loc":"proc/initialize_pos_by_global_ijk.html"},{"title":"grid__initialize – Smoke Ring","text":"private  subroutine grid__initialize(grid) gridの初期化 ここでは周期境界条件を仮定している。 構造体のメンバー関数としてcallするときその\n構造体変数そのものがgridとして自動的に引数にはいる。\nたとえば、\n    call sampl_grid%initialize\nは\n    call grid__initialize(sample_grid)\nと解釈される。gridという名前でなくても構わない。 Type Bound grid_t Arguments Type Intent Optional Attributes Name class( grid_t ), intent(out) :: grid 格子構造体 Calls proc~~grid__initialize~~CallsGraph proc~grid__initialize grid_m::grid_t%grid__initialize proc~initialize_global_ijk grid_m::initialize_global_ijk proc~grid__initialize->proc~initialize_global_ijk proc~initialize_local_ijk_from_global_ijk grid_m::initialize_local_ijk_from_global_ijk proc~grid__initialize->proc~initialize_local_ijk_from_global_ijk proc~initialize_pos grid_m::initialize_pos proc~grid__initialize->proc~initialize_pos proc~initialize_pos_by_global_ijk grid_m::initialize_pos_by_global_ijk proc~grid__initialize->proc~initialize_pos_by_global_ijk x x proc~initialize_pos->x y y proc~initialize_pos->y z z proc~initialize_pos->z Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Source Code grid__initialize Source Code subroutine grid__initialize ( grid ) !! gridの初期化 !! !! ここでは周期境界条件を仮定している。 !! !! 構造体のメンバー関数としてcallするときその !! 構造体変数そのものがgridとして自動的に引数にはいる。 !! たとえば、 !!     call sampl_grid%initialize !! は !!     call grid__initialize(sample_grid) !! と解釈される。gridという名前でなくても構わない。 class ( grid_t ), intent ( out ) :: grid !! 格子構造体 real ( DR ) :: dx , dy , dz ! 格子間隔 !!> !       周期境界条件 ! !          --+-----+-----|                             |-----+-----+--- !            6     7     8                             1     2     3 !                  |-----+-----+-----+-----+-----+-----+-----| !                  1     2     3     4     5     6     7     8 !                     |===================================| !                    XMIN                                XMAX !!< dx = ( XMAX - XMIN ) / ( NX_GLOBAL - 2 ) ! from (1.5) to (NX-0.5), see above figure. dy = ( YMAX - YMIN ) / ( NY_GLOBAL - 2 ) ! ここではxminがi=1とi=2の2つの格子点の dz = ( ZMAX - ZMIN ) / ( NZ_GLOBAL - 2 ) ! ちょうど中間に位置すると仮定している。 grid % delta % x = dx ! x方向の格子間隔 grid % delta % y = dy ! y方向の格子間隔 grid % delta % z = dz ! z方向の格子間隔 grid % delta_min = min ( grid % delta % x , grid % delta % y , grid % delta % z ) ! 3つの格子間隔の最小値。 ! CFL条件はこの最小値で決まる。 grid % d1 % x = 1.0_DR / ( 2 * dx ) ! 1階差分演算用定数 grid % d1 % y = 1.0_DR / ( 2 * dy ) ! dはderivativeを表す grid % d1 % z = 1.0_DR / ( 2 * dz ) ! d1は1階差分の意味 grid % d2 % x = 1.0_DR / ( dx ** 2 ) ! 2階差分演算用定数 grid % d2 % y = 1.0_DR / ( dy ** 2 ) ! dはderivativeを表す grid % d2 % z = 1.0_DR / ( dz ** 2 ) ! d2は2階差分の意味 grid % global_ijk = initialize_global_ijk () grid % local_ijk_from_global_ijk & = initialize_local_ijk_from_global_ijk ( grid % global_ijk ) grid % pos_by_global_ijk = initialize_pos_by_global_ijk ( dx , dy , dz ) grid % pos = initialize_pos ( grid % global_ijk , grid % pos_by_global_ijk ) end subroutine grid__initialize","tags":"","loc":"proc/grid__initialize.html"},{"title":"constants_m – Smoke Ring","text":"Uses iso_fortran_env module~~constants_m~~UsesGraph module~constants_m constants_m iso_fortran_env iso_fortran_env module~constants_m->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~constants_m~~UsedByGraph module~constants_m constants_m module~field_m field_m module~field_m->module~constants_m module~grid_m grid_m module~field_m->module~grid_m module~parallel_m parallel_m module~field_m->module~parallel_m module~fluid_m fluid_m module~fluid_m->module~constants_m module~fluid_m->module~field_m module~fluid_m->module~grid_m module~fluid_m->module~parallel_m module~grid_m->module~constants_m module~grid_m->module~parallel_m module~job_m job_m module~job_m->module~constants_m module~job_m->module~parallel_m module~parallel_m->module~constants_m module~params_m params_m module~params_m->module~constants_m module~solver_m solver_m module~solver_m->module~constants_m module~solver_m->module~field_m module~solver_m->module~fluid_m module~solver_m->module~grid_m module~solver_m->module~job_m module~solver_m->module~parallel_m module~solver_m->module~params_m module~vis2d_m vis2d_m module~vis2d_m->module~constants_m module~vis2d_m->module~field_m module~vis2d_m->module~fluid_m module~vis2d_m->module~grid_m module~vis2d_m->module~parallel_m module~vis2d_m->module~solver_m program~main_m main_m program~main_m->module~constants_m program~main_m->module~field_m program~main_m->module~fluid_m program~main_m->module~grid_m program~main_m->module~job_m program~main_m->module~parallel_m program~main_m->module~params_m program~main_m->module~solver_m program~main_m->module~vis2d_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Variables DEBUG_MODE DI DR NIL NPROC_X NPROC_Y NPROC_Z NXPP NXPP1 NX_GLOBAL NYPP NYPP1 NY_GLOBAL NZPP NZPP1 NZ_GLOBAL PI SI SR TWOPI XMAX XMIN YMAX YMIN ZMAX ZMIN Variables Type Visibility Attributes Name Initial logical, public, parameter :: DEBUG_MODE = .true. integer, public, parameter :: DI = int64 integer, public, parameter :: DR = real64 integer, public, parameter :: NIL = -huge(1) < Code utility constants >>! integer, public, parameter :: NPROC_X = 2 < MPI process constants >>! integer, public, parameter :: NPROC_Y = 1 integer, public, parameter :: NPROC_Z = 2 integer, public, parameter :: NXPP = 30 < Grid size constants >>! integer, public, parameter :: NXPP1 = NXPP+1 integer, public, parameter :: NX_GLOBAL = NXPP*NPROC_X+2 integer, public, parameter :: NYPP = 20 integer, public, parameter :: NYPP1 = NYPP+1 integer, public, parameter :: NY_GLOBAL = NYPP*NPROC_Y+2 integer, public, parameter :: NZPP = 10 integer, public, parameter :: NZPP1 = NZPP+1 integer, public, parameter :: NZ_GLOBAL = NZPP*NPROC_Z+2 real(kind=DR), public, parameter :: PI = atan(1.0_DR)*4 integer, public, parameter :: SI = int32 integer, public, parameter :: SR = real32 real(kind=DR), public, parameter :: TWOPI = PI*2 real(kind=DR), public, parameter :: XMAX = +1.5_DR real(kind=DR), public, parameter :: XMIN = -1.5_DR real(kind=DR), public, parameter :: YMAX = +0.5_DR real(kind=DR), public, parameter :: YMIN = -0.5_DR real(kind=DR), public, parameter :: ZMAX = +0.5_DR real(kind=DR), public, parameter :: ZMIN = -0.5_DR","tags":"","loc":"module/constants_m.html"},{"title":"vis2d_m – Smoke Ring","text":"< Uses vv_sketch_m solver_m fluid_m parallel_m mpiut_m vv_slice_scalar_m vv_color_m constants_m ut_m vv_slice_vector_m field_m grid_m kutimer_m module~~vis2d_m~~UsesGraph module~vis2d_m vis2d_m kutimer_m kutimer_m module~vis2d_m->kutimer_m module~constants_m constants_m module~vis2d_m->module~constants_m module~field_m field_m module~vis2d_m->module~field_m module~fluid_m fluid_m module~vis2d_m->module~fluid_m module~grid_m grid_m module~vis2d_m->module~grid_m module~parallel_m parallel_m module~vis2d_m->module~parallel_m module~solver_m solver_m module~vis2d_m->module~solver_m mpiut_m mpiut_m module~vis2d_m->mpiut_m ut_m ut_m module~vis2d_m->ut_m vv_color_m vv_color_m module~vis2d_m->vv_color_m vv_sketch_m vv_sketch_m module~vis2d_m->vv_sketch_m vv_slice_scalar_m vv_slice_scalar_m module~vis2d_m->vv_slice_scalar_m vv_slice_vector_m vv_slice_vector_m module~vis2d_m->vv_slice_vector_m iso_fortran_env iso_fortran_env module~constants_m->iso_fortran_env module~field_m->module~constants_m module~field_m->module~grid_m module~field_m->module~parallel_m module~field_m->mpiut_m module~fluid_m->module~constants_m module~fluid_m->module~field_m module~fluid_m->module~grid_m module~fluid_m->module~parallel_m module~fluid_m->mpiut_m module~grid_m->module~constants_m module~grid_m->module~parallel_m module~grid_m->ut_m module~parallel_m->module~constants_m module~parallel_m->mpiut_m module~parallel_m->ut_m mpi mpi module~parallel_m->mpi module~solver_m->module~constants_m module~solver_m->module~field_m module~solver_m->module~fluid_m module~solver_m->module~grid_m module~solver_m->module~parallel_m module~solver_m->mpiut_m module~solver_m->ut_m module~job_m job_m module~solver_m->module~job_m module~params_m params_m module~solver_m->module~params_m module~job_m->module~constants_m module~job_m->module~parallel_m module~job_m->ut_m module~params_m->module~constants_m module~params_m->ut_m module~params_m->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~vis2d_m~~UsedByGraph module~vis2d_m vis2d_m program~main_m main_m program~main_m->module~vis2d_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Variables FILE_NAME_MAX TAG_NAME_MAX Derived Types vis2d_plane_xy_t vis2d_plane_xz_t vis2d_t vissubfield3d_t Functions min_max_string vec_amp_max_string Subroutines draw_arrows draw_contour draw_contour_and_arrows make_filename make_time_and_step_string vis2d__draw vis2d__initialize vis2d__set_data vis2d_plane_xy__draw vis2d_plane_xy__initialize vis2d_plane_xy__set_data vis2d_plane_xz__draw vis2d_plane_xz__initialize vis2d_plane_xz__set_data vissubfield3d__update Variables Type Visibility Attributes Name Initial integer, private, parameter :: FILE_NAME_MAX = 200 integer, private, parameter :: TAG_NAME_MAX = 100 Derived Types type, private :: vis2d_plane_xy_t Components Type Visibility Attributes Name Initial type(vv_slice_scalar_t), public :: enstrophy type(vv_slice_scalar_t), public :: flow_helicity integer, public :: gk_cut type(vv_slice_scalar_t), public :: pressure character(len=TAG_NAME_MAX), public :: tag type(vv_slice_vector_t), public :: velocity type(vv_slice_scalar_t), public :: velocity_z type(vv_slice_vector_t), public :: vorticity Type-Bound Procedures procedure\n                    ,                  public\n,                   :: draw => vis2d_plane_xy__draw Subroutine procedure\n                    ,                  public\n,                   :: initialize => vis2d_plane_xy__initialize Subroutine procedure\n                    ,                  public\n,                   :: set_data => vis2d_plane_xy__set_data Subroutine type, private :: vis2d_plane_xz_t Components Type Visibility Attributes Name Initial type(vv_slice_scalar_t), public :: enstrophy type(vv_slice_scalar_t), public :: flow_helicity integer, public :: gj_cut type(vv_slice_scalar_t), public :: pressure character(len=TAG_NAME_MAX), public :: tag type(vv_slice_vector_t), public :: velocity type(vv_slice_scalar_t), public :: velocity_y type(vv_slice_vector_t), public :: vorticity Type-Bound Procedures procedure\n                    ,                  public\n,                   :: draw => vis2d_plane_xz__draw Subroutine procedure\n                    ,                  public\n,                   :: initialize => vis2d_plane_xz__initialize Subroutine procedure\n                    ,                  public\n,                   :: set_data => vis2d_plane_xz__set_data Subroutine type, public :: vis2d_t Components Type Visibility Attributes Name Initial type( vis2d_plane_xz_t ), public :: y_lower type( vis2d_plane_xz_t ), public :: y_middle type( vis2d_plane_xz_t ), public :: y_upper type( vis2d_plane_xy_t ), public :: z_lower type( vis2d_plane_xy_t ), public :: z_middle type( vis2d_plane_xy_t ), public :: z_upper Type-Bound Procedures procedure\n                    ,                  public\n,                   :: draw => vis2d__draw Subroutine procedure\n                    ,                  public\n,                   :: initialize => vis2d__initialize Subroutine procedure\n                    ,                  public\n,                   :: set_data => vis2d__set_data Subroutine type, private :: vissubfield3d_t Components Type Visibility Attributes Name Initial real(kind=DR), public, dimension(0:NXPP1,0:NYPP1,0:NZPP1) :: enstrophy エンストロフィ（渦度の2乗） real(kind=DR), public, dimension(0:NXPP1,0:NYPP1,0:NZPP1) :: helicity ヘリシティ type( field__vector_t ), public :: velocity 流れ場 type( field__vector_t ), public :: vorticity 渦度（流れ場のcurl） Type-Bound Procedures procedure\n                    ,                  public\n,                   :: update => vissubfield3d__update Subroutine Functions private  function min_max_string (vmin, vmax) result(string) Arguments Type Intent Optional Attributes Name real, intent(in) :: vmin real, intent(in) :: vmax Return Value character(len=TAG_NAME_MAX) private  function vec_amp_max_string (vmax) result(string) Arguments Type Intent Optional Attributes Name real, intent(in) :: vmax Return Value character(len=TAG_NAME_MAX) Subroutines private  subroutine draw_arrows (ll, ur, filename, vector) Arguments Type Intent Optional Attributes Name type(vv_sketch__sim_pos_t), intent(in) :: ll type(vv_sketch__sim_pos_t), intent(in) :: ur character(len=*), intent(in) :: filename type(vv_slice_vector_t), intent(inout) :: vector private  subroutine draw_contour (ll, ur, filename, scalar) default Arguments Type Intent Optional Attributes Name type(vv_sketch__sim_pos_t), intent(in) :: ll type(vv_sketch__sim_pos_t), intent(in) :: ur character(len=*), intent(in) :: filename type(vv_slice_scalar_t), intent(inout) :: scalar private  subroutine draw_contour_and_arrows (ll, ur, filename, scalar, vector) < Read more… Arguments Type Intent Optional Attributes Name type(vv_sketch__sim_pos_t), intent(in) :: ll type(vv_sketch__sim_pos_t), intent(in) :: ur character(len=*), intent(in) :: filename type(vv_slice_scalar_t), intent(inout) :: scalar type(vv_slice_vector_t), intent(inout) :: vector private  subroutine make_filename (time_and_step_string, tag1, tag2, filename) Arguments Type Intent Optional Attributes Name character(len=TAG_NAME_MAX), intent(in) :: time_and_step_string character(len=*), intent(in) :: tag1 character(len=*), intent(in) :: tag2 character(len=FILE_NAME_MAX), intent(out) :: filename private  subroutine make_time_and_step_string (t, step, string) Arguments Type Intent Optional Attributes Name real, intent(in) :: t integer, intent(in) :: step character(len=TAG_NAME_MAX), intent(out) :: string public  subroutine vis2d__draw (vis2d, t_double, nloop, fluid) Arguments Type Intent Optional Attributes Name class( vis2d_t ), intent(inout) :: vis2d real(kind=DR), intent(in) :: t_double integer, intent(in) :: nloop type( fluid_t ), intent(in) :: fluid public  subroutine vis2d__initialize (vis2d) Arguments Type Intent Optional Attributes Name class( vis2d_t ), intent(out) :: vis2d private  subroutine vis2d__set_data (vis2d, fluid) Arguments Type Intent Optional Attributes Name class( vis2d_t ), intent(inout) :: vis2d type( fluid_t ), intent(in) :: fluid private  subroutine vis2d_plane_xy__draw (plane, t, step) < Read more… Arguments Type Intent Optional Attributes Name class( vis2d_plane_xy_t ), intent(inout) :: plane real, intent(in) :: t integer, intent(in) :: step private  subroutine vis2d_plane_xy__initialize (plane, gk_cut, tag) Arguments Type Intent Optional Attributes Name class( vis2d_plane_xy_t ), intent(out) :: plane integer, intent(in) :: gk_cut character(len=*), intent(in) :: tag private  subroutine vis2d_plane_xy__set_data (plane, fluid, vf) Arguments Type Intent Optional Attributes Name class( vis2d_plane_xy_t ), intent(inout) :: plane type( fluid_t ), intent(in) :: fluid type( vissubfield3d_t ), intent(in) :: vf private  subroutine vis2d_plane_xz__draw (plane, t, step) < Read more… Arguments Type Intent Optional Attributes Name class( vis2d_plane_xz_t ), intent(inout) :: plane real, intent(in) :: t integer, intent(in) :: step private  subroutine vis2d_plane_xz__initialize (plane, gj_cut, tag) Arguments Type Intent Optional Attributes Name class( vis2d_plane_xz_t ), intent(out) :: plane integer, intent(in) :: gj_cut character(len=*), intent(in) :: tag private  subroutine vis2d_plane_xz__set_data (plane, fluid, vf) Arguments Type Intent Optional Attributes Name class( vis2d_plane_xz_t ), intent(inout) :: plane type( fluid_t ), intent(in) :: fluid type( vissubfield3d_t ), intent(in) :: vf private  subroutine vissubfield3d__update (vf, fluid) Arguments Type Intent Optional Attributes Name class( vissubfield3d_t ), intent(out) :: vf type( fluid_t ), intent(in) :: fluid","tags":"","loc":"module/vis2d_m.html"},{"title":"fluid_m – Smoke Ring","text":"定数定義\n3次元スカラー・ベクトル場\n格子点\nMPI通信ユーティリティ\n並列化\n暗黙の型宣言無効化。必須 Uses parallel_m mpiut_m constants_m field_m grid_m module~~fluid_m~~UsesGraph module~fluid_m fluid_m module~constants_m constants_m module~fluid_m->module~constants_m module~field_m field_m module~fluid_m->module~field_m module~grid_m grid_m module~fluid_m->module~grid_m module~parallel_m parallel_m module~fluid_m->module~parallel_m mpiut_m mpiut_m module~fluid_m->mpiut_m iso_fortran_env iso_fortran_env module~constants_m->iso_fortran_env module~field_m->module~constants_m module~field_m->module~grid_m module~field_m->module~parallel_m module~field_m->mpiut_m module~grid_m->module~constants_m module~grid_m->module~parallel_m ut_m ut_m module~grid_m->ut_m module~parallel_m->module~constants_m module~parallel_m->mpiut_m mpi mpi module~parallel_m->mpi module~parallel_m->ut_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~fluid_m~~UsedByGraph module~fluid_m fluid_m module~solver_m solver_m module~solver_m->module~fluid_m module~vis2d_m vis2d_m module~vis2d_m->module~fluid_m module~vis2d_m->module~solver_m program~main_m main_m program~main_m->module~fluid_m program~main_m->module~solver_m program~main_m->module~vis2d_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Interfaces assignment( = ) operator( * ) operator( + ) operator( .energyintegral. ) Derived Types fluid_t Functions operator_energyintegral operator_fluid_add operator_fluid_times_integer operator_fluid_times_real operator_integer_times_fluid operator_real_times_fluid Subroutines assignment_real_to_fluid fluid__set_boundary_condition Interfaces public        interface assignment( = ) 流体構造体に代入記号が使えるように定義 public  subroutine assignment_real_to_fluid (fluid, real) 流体構造体に実数を代入。\n初期条件ですべての要素を0にセットするときに使う。 Arguments Type Intent Optional Attributes Name type( fluid_t ), intent(out) :: fluid 流体場 real(kind=DR), intent(in) :: real 代入する実数 public        interface operator( * ) 流体構造体の全要素の整数・実数倍 public  function operator_fluid_times_integer (fluid, integer) result(ans) 流体構造体を整数倍するための演算子 Arguments Type Intent Optional Attributes Name type( fluid_t ), intent(in) :: fluid 流体場 integer, intent(in) :: integer かける整数 Return Value type( fluid_t ) public  function operator_integer_times_fluid (integer, fluid) result(ans) 整数に流体構造体を掛け算するための演算子 Arguments Type Intent Optional Attributes Name integer, intent(in) :: integer かける整数 type( fluid_t ), intent(in) :: fluid 流体場 Return Value type( fluid_t ) 計算結果 public  function operator_fluid_times_real (fluid, real) result(ans) 流体構造体を実数倍するための演算子 Arguments Type Intent Optional Attributes Name type( fluid_t ), intent(in) :: fluid 流体場 real(kind=DR), intent(in) :: real かける実数 Return Value type( fluid_t ) 計算結果 public  function operator_real_times_fluid (real, fluid) result(ans) 実数に流体場を掛ける演算子 Arguments Type Intent Optional Attributes Name real(kind=DR), intent(in) :: real 掛ける実数 type( fluid_t ), intent(in) :: fluid 流体場 Return Value type( fluid_t ) 計算結果 public        interface operator( + ) 流体構造体の全要素の足し算を+記号で書けるように定義 public  function operator_fluid_add (a, b) result(ans) 流体構造体の足し算演算子 Arguments Type Intent Optional Attributes Name type( fluid_t ), intent(in) :: a 足し算する2つの流体場 type( fluid_t ), intent(in) :: b 足し算する2つの流体場 Return Value type( fluid_t ) 計算結果 public        interface operator( .energyintegral. ) 全エネルギーを計算（体積積分）する演算子 public  function operator_energyintegral (a) result(ans) 流体の運動エネルギーの体積積分\n現在のシュミレーションでは格子間隔はx, y, z それぞれに\n一様であることを仮定している。つまりdx, dy, dzは空間位置に\n依存せず一定である。 質量フラックスの2乗を一時的な配列にセットする Arguments Type Intent Optional Attributes Name type( fluid_t ), intent(in) :: a 流体場 Return Value real(kind=DR) 全エネルギー\n以下のエネルギー密度の式を全空間で体積積分する\nflow_energy = (1/2) * rho * vel&#94;2 = (1/2) * (massflux)&#94;2 / rho Derived Types type, public :: fluid_t このシミュレーションコードで最も大事な\n変数（構造体）。流体の状態を保持する。 Components Type Visibility Attributes Name Initial real(kind=DR), public, dimension(0:NXPP1,0:NYPP1,0:NZPP1) :: density 質量密度場 type( field__vector_t ), public :: flux 質量フラックス\n質量フラックス (flux) と速度場 (velocity_vector)\n   flux = density * velocity_vector\nという関係がある。速度場を基本変数にしても問題ない。\n単にこのシミュレーションで解く基本方程式\nナビエ・ストークス方程式）の基本変数をどちらで\n表現するか、の違いである。 real(kind=DR), public, dimension(0:NXPP1,0:NYPP1,0:NZPP1) :: pressure 圧力場 Type-Bound Procedures procedure\n                    ,                  public\n,                   :: set_boundary_condition => fluid__set_boundary_condition Subroutine Functions public  function operator_energyintegral (a) result(ans) 流体の運動エネルギーの体積積分\n現在のシュミレーションでは格子間隔はx, y, z それぞれに\n一様であることを仮定している。つまりdx, dy, dzは空間位置に\n依存せず一定である。 Read more… Arguments Type Intent Optional Attributes Name type( fluid_t ), intent(in) :: a 流体場 Return Value real(kind=DR) 全エネルギー\n以下のエネルギー密度の式を全空間で体積積分する\nflow_energy = (1/2) * rho * vel&#94;2 = (1/2) * (massflux)&#94;2 / rho public  function operator_fluid_add (a, b) result(ans) 流体構造体の足し算演算子 Arguments Type Intent Optional Attributes Name type( fluid_t ), intent(in) :: a 足し算する2つの流体場 type( fluid_t ), intent(in) :: b 足し算する2つの流体場 Return Value type( fluid_t ) 計算結果 public  function operator_fluid_times_integer (fluid, integer) result(ans) 流体構造体を整数倍するための演算子 Arguments Type Intent Optional Attributes Name type( fluid_t ), intent(in) :: fluid 流体場 integer, intent(in) :: integer かける整数 Return Value type( fluid_t ) public  function operator_fluid_times_real (fluid, real) result(ans) 流体構造体を実数倍するための演算子 Arguments Type Intent Optional Attributes Name type( fluid_t ), intent(in) :: fluid 流体場 real(kind=DR), intent(in) :: real かける実数 Return Value type( fluid_t ) 計算結果 public  function operator_integer_times_fluid (integer, fluid) result(ans) 整数に流体構造体を掛け算するための演算子 Arguments Type Intent Optional Attributes Name integer, intent(in) :: integer かける整数 type( fluid_t ), intent(in) :: fluid 流体場 Return Value type( fluid_t ) 計算結果 public  function operator_real_times_fluid (real, fluid) result(ans) 実数に流体場を掛ける演算子 Arguments Type Intent Optional Attributes Name real(kind=DR), intent(in) :: real 掛ける実数 type( fluid_t ), intent(in) :: fluid 流体場 Return Value type( fluid_t ) 計算結果 Subroutines public  subroutine assignment_real_to_fluid (fluid, real) 流体構造体に実数を代入。\n初期条件ですべての要素を0にセットするときに使う。 Arguments Type Intent Optional Attributes Name type( fluid_t ), intent(out) :: fluid 流体場 real(kind=DR), intent(in) :: real 代入する実数 public  subroutine fluid__set_boundary_condition (fluid) プロセス間通信で領域境界データを交換 Arguments Type Intent Optional Attributes Name class( fluid_t ), intent(inout) :: fluid 流体構造体の周期境界条件設定","tags":"","loc":"module/fluid_m.html"},{"title":"job_m – Smoke Ring","text":"定数定義\nユーティリティ\nMPI並列化\n暗黙の型宣言無効化。必須\nこのモジュール内の変数・ルーチン等はデフォルトで非公開 Uses constants_m ut_m parallel_m module~~job_m~~UsesGraph module~job_m job_m module~constants_m constants_m module~job_m->module~constants_m module~parallel_m parallel_m module~job_m->module~parallel_m ut_m ut_m module~job_m->ut_m iso_fortran_env iso_fortran_env module~constants_m->iso_fortran_env module~parallel_m->module~constants_m module~parallel_m->ut_m mpi mpi module~parallel_m->mpi mpiut_m mpiut_m module~parallel_m->mpiut_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~job_m~~UsedByGraph module~job_m job_m module~solver_m solver_m module~solver_m->module~job_m program~main_m main_m program~main_m->module~job_m program~main_m->module~solver_m module~vis2d_m vis2d_m program~main_m->module~vis2d_m module~vis2d_m->module~solver_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Variables Job Derived Types job_t Subroutines job__finalize job__initialize Variables Type Visibility Attributes Name Initial type( job_t ), public :: Job Derived Types type, private :: job_t Components Type Visibility Attributes Name Initial character(len=20), public :: karte = \"fine\" Type-Bound Procedures procedure\n                    ,                  public\n, nopass                  :: finalize => job__finalize Subroutine procedure\n                    ,                  public\n, nopass                  :: initialize => job__initialize Subroutine Subroutines private  subroutine job__finalize (nloop) このどちらかであれば、 Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: nloop ループカウンタ\nジョブ終了時の後始末。\n(1) 健康状態カルテに応じたメッセージを標準出力に書く\n(2) MPI並列化の終了処理 private  subroutine job__initialize () MPI並列化初期化処理。Parallel変数はparallel.efで定義\nされている。冒頭のPが大文字なのはこれがグローバル変数\nであることを示唆している。（コンパイラは大文字と小文字を\n区別しないが。） Arguments None","tags":"","loc":"module/job_m.html"},{"title":"parallel_m – Smoke Ring","text":"Uses constants_m ut_m mpiut_m mpi module~~parallel_m~~UsesGraph module~parallel_m parallel_m module~constants_m constants_m module~parallel_m->module~constants_m mpi mpi module~parallel_m->mpi mpiut_m mpiut_m module~parallel_m->mpiut_m ut_m ut_m module~parallel_m->ut_m iso_fortran_env iso_fortran_env module~constants_m->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~parallel_m~~UsedByGraph module~parallel_m parallel_m module~field_m field_m module~field_m->module~parallel_m module~grid_m grid_m module~field_m->module~grid_m module~fluid_m fluid_m module~fluid_m->module~parallel_m module~fluid_m->module~field_m module~fluid_m->module~grid_m module~grid_m->module~parallel_m module~job_m job_m module~job_m->module~parallel_m module~solver_m solver_m module~solver_m->module~parallel_m module~solver_m->module~field_m module~solver_m->module~fluid_m module~solver_m->module~grid_m module~solver_m->module~job_m module~vis2d_m vis2d_m module~vis2d_m->module~parallel_m module~vis2d_m->module~field_m module~vis2d_m->module~fluid_m module~vis2d_m->module~grid_m module~vis2d_m->module~solver_m program~main_m main_m program~main_m->module~parallel_m program~main_m->module~field_m program~main_m->module~fluid_m program~main_m->module~grid_m program~main_m->module~job_m program~main_m->module~solver_m program~main_m->module~vis2d_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Variables Parallel Derived Types parallel_t pos_t rank_t Functions calc_rank_next parallel__io_clerk parallel__rank_to_pos_index pos_ijk_to_rank Subroutines parallel__finalize parallel__initialize Variables Type Visibility Attributes Name Initial type( parallel_t ), public :: Parallel Derived Types type, private :: parallel_t Components Type Visibility Attributes Name Initial integer, public :: comm logical, public :: i_have_xmax logical, public :: i_have_xmin logical, public :: i_have_ymax logical, public :: i_have_ymin logical, public :: i_have_zmax logical, public :: i_have_zmin integer, public :: nprocs type(mpiut__rank_next_t), public :: periodic_pair type( pos_t ), public :: pos type( rank_t ), public :: rank Type-Bound Procedures procedure\n                    ,                  public\n, nopass                  :: finalize => parallel__finalize Subroutine procedure\n                    ,                  public\n, nopass                  :: initialize => parallel__initialize Subroutine procedure\n                    ,                  public\n, nopass                  :: io_clerk => parallel__io_clerk Function procedure\n                    ,                  public\n, nopass                  :: rank_to_pos_index => parallel__rank_to_pos_index Function type, private :: pos_t Components Type Visibility Attributes Name Initial type(mpiut__rank_position_t), public :: index character(len=12), public :: string type, private :: rank_t Components Type Visibility Attributes Name Initial integer, public :: me type(mpiut__rank_next_t), public :: next Functions private  function calc_rank_next (me) result(next) Arguments Type Intent Optional Attributes Name type(mpiut__rank_position_t), intent(in) :: me Return Value type(mpiut__rank_next_t) private  function parallel__io_clerk (task) result(i_am) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: task Return Value logical < private  function parallel__rank_to_pos_index (rank) result(index) Arguments Type Intent Optional Attributes Name integer, intent(in) :: rank Return Value type(mpiut__rank_position_t) < private  function pos_ijk_to_rank (i, j, k) Arguments Type Intent Optional Attributes Name integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: k Return Value integer < Subroutines private  subroutine parallel__finalize () Arguments None private  subroutine parallel__initialize () < Read more… Arguments None","tags":"","loc":"module/parallel_m.html"},{"title":"params_m – Smoke Ring","text":"Uses constants_m ut_m iso_fortran_env module~~params_m~~UsesGraph module~params_m params_m iso_fortran_env iso_fortran_env module~params_m->iso_fortran_env module~constants_m constants_m module~params_m->module~constants_m ut_m ut_m module~params_m->ut_m module~constants_m->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~params_m~~UsedByGraph module~params_m params_m module~solver_m solver_m module~solver_m->module~params_m program~main_m main_m program~main_m->module~params_m program~main_m->module~solver_m module~vis2d_m vis2d_m program~main_m->module~vis2d_m module~vis2d_m->module~solver_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Variables Kappa Params Read_done STRING_LENGTH_MAX Slicedata_nskip Slicedata_tag Total_nloop Viscosity Derived Types params_t Functions params__get_double params__get_integer params__get_logical params__get_string Subroutines params__read Variables Type Visibility Attributes Name Initial real(kind=DR), private :: Kappa type( params_t ), public :: Params logical, private, save :: Read_done = .false. integer, private, parameter :: STRING_LENGTH_MAX = 200 integer, private :: Slicedata_nskip character(len=STRING_LENGTH_MAX), private :: Slicedata_tag integer, private :: Total_nloop real(kind=DR), private :: Viscosity Derived Types type, private :: params_t Type-Bound Procedures procedure\n                    ,                  public\n, nopass                  :: get_double => params__get_double Function procedure\n                    ,                  public\n, nopass                  :: get_integer => params__get_integer Function procedure\n                    ,                  public\n, nopass                  :: get_logical => params__get_logical Function procedure\n                    ,                  public\n, nopass                  :: get_string => params__get_string Function procedure\n                    ,                  public\n, nopass                  :: read => params__read Subroutine Functions private  function params__get_double (variable) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: variable 問い合わせ変数の名前 Return Value real(kind=DR) その値\nこのモジュールの外からの問い合わせに応じてnamelistデータを返す。\nこの関数は問い合わせ変数が倍精度浮動小数点数の場合。\nこの関数の前にnamelist__readが呼ばれている必要がある。\nこの点はassertで確認している。 private  function params__get_integer (variable) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: variable 問い合わせ変数の名前 Return Value integer その値\nこのモジュールの外からの問い合わせに応じてnamelistデータを返す。\nこの関数は問い合わせ変数が整数の場合。\nこの関数の前にnamelist__readが呼ばれている必要がある。\nこの点はassertで確認している。 private  function params__get_logical (variable) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: variable 問い合わせ変数の名前 Return Value logical その値\nこのモジュールの外からの問い合わせに応じてnamelistデータを返す。\nこの関数は問い合わせ変数が論理値の場合。\nこの関数の前にnamelist__readが呼ばれている必要がある。\nこの点はassertで確認している。 private  function params__get_string (variable) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: variable 問い合わせ変数の名前 Return Value character(len=STRING_LENGTH_MAX) その値\nこのモジュールの外からの問い合わせに応じてnamelistデータを返す。\nこの関数は問い合わせ変数が文字列の場合。\nこの関数の前にnamelist__readが呼ばれている必要がある。\nこの点はassertで確認している。 Subroutines private  subroutine params__read () namelistファイルをディスクから読み込む。\n ファイル名はコマンド第一引数。 Read more… Arguments None","tags":"","loc":"module/params_m.html"},{"title":"solver_m – Smoke Ring","text":"定数定義\n スカラー場・ベクトル場\n 流体場の構造体定義\n 格子点\n ジョブ管理\n MPIユーティリティ\n MPI並列化\n パラメータ\n ユーティリティ \n 暗黙の型宣言無効化。必須 このモジュール内の変数・ルーチン等はデフォルトで非公開 < Uses parallel_m mpiut_m params_m constants_m job_m grid_m ut_m field_m fluid_m module~~solver_m~~UsesGraph module~solver_m solver_m module~constants_m constants_m module~solver_m->module~constants_m module~field_m field_m module~solver_m->module~field_m module~fluid_m fluid_m module~solver_m->module~fluid_m module~grid_m grid_m module~solver_m->module~grid_m module~job_m job_m module~solver_m->module~job_m module~parallel_m parallel_m module~solver_m->module~parallel_m module~params_m params_m module~solver_m->module~params_m mpiut_m mpiut_m module~solver_m->mpiut_m ut_m ut_m module~solver_m->ut_m iso_fortran_env iso_fortran_env module~constants_m->iso_fortran_env module~field_m->module~constants_m module~field_m->module~grid_m module~field_m->module~parallel_m module~field_m->mpiut_m module~fluid_m->module~constants_m module~fluid_m->module~field_m module~fluid_m->module~grid_m module~fluid_m->module~parallel_m module~fluid_m->mpiut_m module~grid_m->module~constants_m module~grid_m->module~parallel_m module~grid_m->ut_m module~job_m->module~constants_m module~job_m->module~parallel_m module~job_m->ut_m module~parallel_m->module~constants_m module~parallel_m->mpiut_m module~parallel_m->ut_m mpi mpi module~parallel_m->mpi module~params_m->module~constants_m module~params_m->ut_m module~params_m->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~solver_m~~UsedByGraph module~solver_m solver_m module~vis2d_m vis2d_m module~vis2d_m->module~solver_m program~main_m main_m program~main_m->module~solver_m program~main_m->module~vis2d_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Variables Drive_force GAMMA GASS_CONST_FOR_AIR Gamma1_kappa Initialize_done Solver Viscosity Derived Types solver_t Functions drive_force_factor solver__set_time_step the_equation Subroutines set_drive_force_field solver__advance solver__diagnosis solver__initialize subfield_vel subfield_vel_tm subfield_vel_tm_divv Variables Type Visibility Attributes Name Initial type( field__vector_t ), private, save :: Drive_force 渦輪を駆動する力 real(kind=DR), private, parameter :: GAMMA = 1.4_DR 空気の比熱比 real(kind=DR), private, parameter :: GASS_CONST_FOR_AIR = 2.87e2_DR 空気の気体定数\n 空気の状態方程式\n    Pressure = 287 * Mass_density * Temperature real(kind=DR), private, save :: Gamma1_kappa (GAMMA-1)*kappa\nkappaは熱拡散率 logical, private, save :: Initialize_done = .false. モジュール初期化確認フラグ type( solver_t ), public :: Solver real(kind=DR), private, save :: Viscosity 粘性率 Derived Types type, private :: solver_t Type-Bound Procedures procedure\n                    ,                  public\n, nopass                  :: advance => solver__advance Subroutine procedure\n                    ,                  public\n, nopass                  :: diagnosis => solver__diagnosis Subroutine generic,\n                  public\n,                   :: get_subfield => subfield_vel , subfield_vel_tm , subfield_vel_tm_divv 流体の基本変数（質量フラックス、質量密度、圧力）\nから二次的な量（流れ場、温度場、速度の発散）\nを計算するためのルーチン群の多重定義 procedure\n                    ,                  public\n, nopass                  :: initialize => solver__initialize Subroutine procedure\n                    ,                  public\n, nopass                  :: set_time_step => solver__set_time_step Function procedure\n                    ,                  private\n, nopass                  :: subfield_vel Subroutine procedure\n                    ,                  private\n, nopass                  :: subfield_vel_tm Subroutine procedure\n                    ,                  private\n, nopass                  :: subfield_vel_tm_divv Subroutine Functions private  function drive_force_factor (time) 渦輪を駆動する力の時間変化の調整のための係数設定 Read more… Arguments Type Intent Optional Attributes Name real(kind=DR), intent(in) :: time シミュレーション時刻 Return Value real(kind=DR) 力の強さ係数 0から1 < private  function solver__set_time_step (nloop, fluid) CFL条件に基づいて時間刻み幅dtを設定する\n初期化忘れ確認 Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: nloop ループカウンタ type( fluid_t ), intent(in) :: fluid 流体データ Return Value real(kind=DR) 時間刻み幅 dt private  function the_equation (t, dt, vx, vy, vz, tm, divv, fx, fy, fz, ps) ナビエ・ストークス方程式の右辺（時間変化量）dtを掛けたものを計算 Read more… Arguments Type Intent Optional Attributes Name real(kind=DR), intent(in) :: t 時刻と時間刻み幅 real(kind=DR), intent(in) :: dt 時刻と時間刻み幅 real(kind=DR), intent(in), dimension(0:NXPP1,0:NYPP1,0:NZPP1) :: vx 速度3成分 real(kind=DR), intent(in), dimension(0:NXPP1,0:NYPP1,0:NZPP1) :: vy 速度3成分 real(kind=DR), intent(in), dimension(0:NXPP1,0:NYPP1,0:NZPP1) :: vz 速度3成分 real(kind=DR), intent(in), dimension(0:NXPP1,0:NYPP1,0:NZPP1) :: tm 温度と速度の発散 real(kind=DR), intent(in), dimension(0:NXPP1,0:NYPP1,0:NZPP1) :: divv 温度と速度の発散 real(kind=DR), intent(in), dimension(0:NXPP1,0:NYPP1,0:NZPP1) :: fx 質量フラックス real(kind=DR), intent(in), dimension(0:NXPP1,0:NYPP1,0:NZPP1) :: fy 質量フラックス real(kind=DR), intent(in), dimension(0:NXPP1,0:NYPP1,0:NZPP1) :: fz 質量フラックス real(kind=DR), intent(in), dimension(0:NXPP1,0:NYPP1,0:NZPP1) :: ps 圧力 Return Value type( fluid_t ) 時間刻みdtでの流体データの微小変化量 Subroutines private  subroutine set_drive_force_field () 渦輪を駆動するための力の場を設定する\nその力はシミュレーション開始直後、短い時間だけかける。\n空間的には局在した力を想定している。その形状は円筒形である。\n円筒の軸はx軸上にある。\n力をかける局所円筒領域のx方向の最小値\n力をかける局所円筒領域のx方向の最大値\n力をかける局所円筒領域の中心のy座標を中間にとる\n力をかける局所円筒領域の中心のz座標を中間にとる\n力をかける局所円筒領域の直径\n力をかける局所円筒領域の半径の2乗 Read more… Arguments None private  subroutine solver__advance (t, dt, fluid) 4段4次ルンゲ・クッタ積分法による時間積分の実行 Read more… Arguments Type Intent Optional Attributes Name real(kind=DR), intent(inout) :: t 時刻 real(kind=DR), intent(in) :: dt 時間刻み幅 type( fluid_t ), intent(inout) :: fluid 流体データ private  subroutine solver__diagnosis (nloop, time, fluid) 流体の「健康状態」を診断する\nこのルーチンは結構計算負荷が高いので、\n毎ステップではなく、SKIPステップごとに診断を実行する Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: nloop ループカウンタ real(kind=DR), intent(in) :: time シミュレーション時刻 type( fluid_t ), intent(in) :: fluid 流体データ private  subroutine solver__initialize (fluid) モジュールの初期化\n空気の粘性率\n空気の熱拡散率\nViscosityと違ってkappaの頭文字が大文字になっていない、つまり\nこのモジュールのグローバルスコープを持つ変数としていない\nのはナビエ・ストークス方程式には下で定義するGamma1_kappa\nという量のみを通じてkappaが出てくるからである。 Read more… Arguments Type Intent Optional Attributes Name type( fluid_t ), intent(out) :: fluid 流体データ private  subroutine subfield_vel (fluid, vel) fluidの基本変数から二次的な場vel（流れの速度ベクトル場）\nをもとめる。\n割り算演算子はfield_mで定義している。 Arguments Type Intent Optional Attributes Name type( fluid_t ), intent(in) :: fluid 流体基本場 type( field__vector_t ), intent(out) :: vel 流れの速度ベクトル private  subroutine subfield_vel_tm (fluid, vel, tm) fluidの基本変数から二次的な場（速度ベクトル場velと温度場tm）\nをもとめる。\nfluid構造体の割り算演算子はfluid_mで定義している。 Arguments Type Intent Optional Attributes Name type( fluid_t ), intent(in) :: fluid 流体基本場 type( field__vector_t ), intent(out) :: vel 流れ場 real(kind=DR), intent(out), dimension(0:NXPP1,0:NYPP1,0:NZPP1) :: tm 温度場 private  subroutine subfield_vel_tm_divv (fluid, vel, tm, divv) fluidの基本変数から二次的な場（速度ベクトル場velと\n温度場tmと速度の発散divv）をもとめる。 Arguments Type Intent Optional Attributes Name type( fluid_t ), intent(in) :: fluid 流体基本場 type( field__vector_t ), intent(out) :: vel 流れ場 real(kind=DR), intent(out), dimension(0:NXPP1,0:NYPP1,0:NZPP1) :: tm 温度場 real(kind=DR), intent(out), dimension(0:NXPP1,0:NYPP1,0:NZPP1) :: divv 流れの発散","tags":"","loc":"module/solver_m.html"},{"title":"field_m – Smoke Ring","text":"< Uses constants_m mpiut_m parallel_m grid_m module~~field_m~~UsesGraph module~field_m field_m module~constants_m constants_m module~field_m->module~constants_m module~grid_m grid_m module~field_m->module~grid_m module~parallel_m parallel_m module~field_m->module~parallel_m mpiut_m mpiut_m module~field_m->mpiut_m iso_fortran_env iso_fortran_env module~constants_m->iso_fortran_env module~grid_m->module~constants_m module~grid_m->module~parallel_m ut_m ut_m module~grid_m->ut_m module~parallel_m->module~constants_m module~parallel_m->mpiut_m mpi mpi module~parallel_m->mpi module~parallel_m->ut_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~field_m~~UsedByGraph module~field_m field_m module~fluid_m fluid_m module~fluid_m->module~field_m module~solver_m solver_m module~solver_m->module~field_m module~solver_m->module~fluid_m module~vis2d_m vis2d_m module~vis2d_m->module~field_m module~vis2d_m->module~fluid_m module~vis2d_m->module~solver_m program~main_m main_m program~main_m->module~field_m program~main_m->module~fluid_m program~main_m->module~solver_m program~main_m->module~vis2d_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Interfaces assignment( = ) field__boundary_condition operator( * ) operator( + ) operator( .curl. ) operator( .div. ) operator( .dot. ) operator( .laplacian. ) operator( .scalarintegral. ) operator( .x. ) operator( / ) Derived Types field__vector_t Functions operator_cross_product operator_curl operator_div operator_dot_product operator_laplacian_scalar operator_laplacian_vector operator_real_times_vector operator_scalar_times_vector operator_scalarintegral operator_vector_add operator_vector_divby_scalar operator_vector_times_real operator_vector_times_scalar Subroutines assignment_real_to_vector boundary_condition_scalar boundary_condition_vector Interfaces public        interface assignment( = ) 各種構造体に代入記号が使えるように定義 private  subroutine assignment_real_to_vector (vector, real) ベクトル場に実数を代入。\n初期条件で0にセットするときに使う。 Arguments Type Intent Optional Attributes Name type( field__vector_t ), intent(out) :: vector ベクトル場 real(kind=DR), intent(in) :: real 代入する実数 public        interface field__boundary_condition 境界条件呼び出しルーチンの多重定義\n境界条件を設定する変数の種類によって\n実際に使用するルーチンが違うが、\n呼び出し側では統一した名前でcallする。\nコンパイラは引数の型で使用するルーチンを\n判断する。 private  subroutine boundary_condition_scalar (scalar) スカラー場の境界条件設定\nプロセス間通信で領域境界データを交換 Arguments Type Intent Optional Attributes Name real(kind=DR), intent(inout), dimension(0:NXPP1,0:NYPP1,0:NZPP1) :: scalar スカラー場 Read more… private  subroutine boundary_condition_vector (vector) ベクトル場の境界条件設定\nプロセス間通信で領域境界データを交換 Arguments Type Intent Optional Attributes Name type( field__vector_t ), intent(inout) :: vector ベクトル場 Read more… public        interface operator( * ) 各種構造体に掛け算記号が使えるように定義 private  function operator_real_times_vector (real, vec) 実数にベクトル場を掛ける演算子 Arguments Type Intent Optional Attributes Name real(kind=DR), intent(in) :: real 掛ける実数 type( field__vector_t ), intent(in) :: vec 流体場 Return Value type( field__vector_t ) 計算結果 private  function operator_scalar_times_vector (scalar, vec) スカラー場にベクトル場を掛ける演算子 Arguments Type Intent Optional Attributes Name real(kind=DR), intent(in), dimension(0:NXPP1,0:NYPP1,0:NZPP1) :: scalar スカラー場 type( field__vector_t ), intent(in) :: vec ベクトル場 Return Value type( field__vector_t ) 計算結果 private  function operator_vector_times_real (vec, real) ベクトル場の実数倍の演算子 Arguments Type Intent Optional Attributes Name type( field__vector_t ), intent(in) :: vec ベクトル場 real(kind=DR), intent(in) :: real 掛ける実数 Return Value type( field__vector_t ) 計算結果 private  function operator_vector_times_scalar (vec, scalar) ベクトル場にスカラー場を掛ける Arguments Type Intent Optional Attributes Name type( field__vector_t ), intent(in) :: vec ベクトル場 real(kind=DR), intent(in), dimension(0:NXPP1,0:NYPP1,0:NZPP1) :: scalar スカラー場 Return Value type( field__vector_t ) 計算結果 public        interface operator( + ) 構造体全要素の足し算を+記号で書けるように定義 private  function operator_vector_add (a, b) ベクトル場の和の演算子 Arguments Type Intent Optional Attributes Name type( field__vector_t ), intent(in) :: a 和をとるベクトル場 type( field__vector_t ), intent(in) :: b 和をとるベクトル場 Return Value type( field__vector_t ) 計算結果 public        interface operator( .curl. ) ベクトル解析のcurl演算子 private  function operator_curl (a) ベクトル場のcurl Arguments Type Intent Optional Attributes Name type( field__vector_t ), intent(in) :: a これのcurlをとる Return Value type( field__vector_t ) curlした結果 public        interface operator( .div. ) ベクトル解析のdivergence演算子 private  function operator_div (a) ベクトル場のdivergence Arguments Type Intent Optional Attributes Name type( field__vector_t ), intent(in) :: a これのdivをとる Return Value real(kind=DR), dimension(0:NXPP1,0:NYPP1,0:NZPP1) 結果 public        interface operator( .dot. ) ベクトル解析の内積演算子 private  function operator_dot_product (a, b) ベクトル場の内積 Arguments Type Intent Optional Attributes Name type( field__vector_t ), intent(in) :: a 内積をとるベクトル場 type( field__vector_t ), intent(in) :: b 内積をとるベクトル場 Return Value real(kind=DR), dimension(0:NXPP1,0:NYPP1,0:NZPP1) 計算結果 public        interface operator( .laplacian. ) ラプラシアン演算子\nスカラー場とベクトル場用の2つの多重定義 private  function operator_laplacian_scalar (a) スカラー場のラプラシアン Arguments Type Intent Optional Attributes Name real(kind=DR), intent(in), dimension(0:NXPP1,0:NYPP1,0:NZPP1) :: a 入力スカラー場 Return Value real(kind=DR), dimension(0:NXPP1,0:NYPP1,0:NZPP1) 計算結果 private  function operator_laplacian_vector (a) ベクトル場のラプラシアン Arguments Type Intent Optional Attributes Name type( field__vector_t ), intent(in) :: a 入力ベクトル場 Return Value type( field__vector_t ) 計算結果 public        interface operator( .scalarintegral. ) 任意のスカラー場の体積積分をする演算子 private  function operator_scalarintegral (a) スカラー場の体積積分演算子 Arguments Type Intent Optional Attributes Name real(kind=DR), intent(in), dimension(0:NXPP1,0:NYPP1,0:NZPP1) :: a スカラー場 Return Value real(kind=DR) 体積積分結果 public        interface operator( .x. ) ベクトル解析の外積演算子 private  function operator_cross_product (a, b) ベクトル場の外積 Arguments Type Intent Optional Attributes Name type( field__vector_t ), intent(in) :: a 掛けるベクトル場 type( field__vector_t ), intent(in) :: b 掛けるベクトル場 Return Value type( field__vector_t ) 外積 public        interface operator( / ) ベクトル場の3成分をあるスカラー場で割り算する\n操作は何度か出てくる（例えば質量フラックスfluxから\n速度場velocity_vectorを求めるときに\nvelocity_vector = flux / mass_density\nという割り算が必要である）この計算を\nスラッシュ記号一つで書けるように定義 private  function operator_vector_divby_scalar (vec, scalar) ベクトル場の各成分をスカラー場で割る Arguments Type Intent Optional Attributes Name type( field__vector_t ), intent(in) :: vec ベクトル場 real(kind=DR), intent(in), dimension(0:NXPP1,0:NYPP1,0:NZPP1) :: scalar スカラー場 Return Value type( field__vector_t ) 計算結果 Derived Types type, public :: field__vector_t 3次元ベクトル場構造体\nここではコンパイル時に配列のサイズが\n既に決まっているとしているが、そうでない\n場合、つまり実行時に配列サイズを確定\nしたい場合にはallocatableな配列を使えば良い。 Read more… Components Type Visibility Attributes Name Initial real(kind=DR), public, dimension(0:NXPP1,0:NYPP1,0:NZPP1) :: x x成分 real(kind=DR), public, dimension(0:NXPP1,0:NYPP1,0:NZPP1) :: y y成分 real(kind=DR), public, dimension(0:NXPP1,0:NYPP1,0:NZPP1) :: z z成分 Functions private  function operator_cross_product (a, b) ベクトル場の外積 Arguments Type Intent Optional Attributes Name type( field__vector_t ), intent(in) :: a 掛けるベクトル場 type( field__vector_t ), intent(in) :: b 掛けるベクトル場 Return Value type( field__vector_t ) 外積 private  function operator_curl (a) ベクトル場のcurl Arguments Type Intent Optional Attributes Name type( field__vector_t ), intent(in) :: a これのcurlをとる Return Value type( field__vector_t ) curlした結果 private  function operator_div (a) ベクトル場のdivergence Arguments Type Intent Optional Attributes Name type( field__vector_t ), intent(in) :: a これのdivをとる Return Value real(kind=DR), dimension(0:NXPP1,0:NYPP1,0:NZPP1) 結果 private  function operator_dot_product (a, b) ベクトル場の内積 Arguments Type Intent Optional Attributes Name type( field__vector_t ), intent(in) :: a 内積をとるベクトル場 type( field__vector_t ), intent(in) :: b 内積をとるベクトル場 Return Value real(kind=DR), dimension(0:NXPP1,0:NYPP1,0:NZPP1) 計算結果 private  function operator_laplacian_scalar (a) スカラー場のラプラシアン Arguments Type Intent Optional Attributes Name real(kind=DR), intent(in), dimension(0:NXPP1,0:NYPP1,0:NZPP1) :: a 入力スカラー場 Return Value real(kind=DR), dimension(0:NXPP1,0:NYPP1,0:NZPP1) 計算結果 private  function operator_laplacian_vector (a) ベクトル場のラプラシアン Arguments Type Intent Optional Attributes Name type( field__vector_t ), intent(in) :: a 入力ベクトル場 Return Value type( field__vector_t ) 計算結果 private  function operator_real_times_vector (real, vec) 実数にベクトル場を掛ける演算子 Arguments Type Intent Optional Attributes Name real(kind=DR), intent(in) :: real 掛ける実数 type( field__vector_t ), intent(in) :: vec 流体場 Return Value type( field__vector_t ) 計算結果 private  function operator_scalar_times_vector (scalar, vec) スカラー場にベクトル場を掛ける演算子 Arguments Type Intent Optional Attributes Name real(kind=DR), intent(in), dimension(0:NXPP1,0:NYPP1,0:NZPP1) :: scalar スカラー場 type( field__vector_t ), intent(in) :: vec ベクトル場 Return Value type( field__vector_t ) 計算結果 private  function operator_scalarintegral (a) スカラー場の体積積分演算子 Arguments Type Intent Optional Attributes Name real(kind=DR), intent(in), dimension(0:NXPP1,0:NYPP1,0:NZPP1) :: a スカラー場 Return Value real(kind=DR) 体積積分結果 private  function operator_vector_add (a, b) ベクトル場の和の演算子 Arguments Type Intent Optional Attributes Name type( field__vector_t ), intent(in) :: a 和をとるベクトル場 type( field__vector_t ), intent(in) :: b 和をとるベクトル場 Return Value type( field__vector_t ) 計算結果 private  function operator_vector_divby_scalar (vec, scalar) ベクトル場の各成分をスカラー場で割る Arguments Type Intent Optional Attributes Name type( field__vector_t ), intent(in) :: vec ベクトル場 real(kind=DR), intent(in), dimension(0:NXPP1,0:NYPP1,0:NZPP1) :: scalar スカラー場 Return Value type( field__vector_t ) 計算結果 private  function operator_vector_times_real (vec, real) ベクトル場の実数倍の演算子 Arguments Type Intent Optional Attributes Name type( field__vector_t ), intent(in) :: vec ベクトル場 real(kind=DR), intent(in) :: real 掛ける実数 Return Value type( field__vector_t ) 計算結果 private  function operator_vector_times_scalar (vec, scalar) ベクトル場にスカラー場を掛ける Arguments Type Intent Optional Attributes Name type( field__vector_t ), intent(in) :: vec ベクトル場 real(kind=DR), intent(in), dimension(0:NXPP1,0:NYPP1,0:NZPP1) :: scalar スカラー場 Return Value type( field__vector_t ) 計算結果 Subroutines private  subroutine assignment_real_to_vector (vector, real) ベクトル場に実数を代入。\n初期条件で0にセットするときに使う。 Arguments Type Intent Optional Attributes Name type( field__vector_t ), intent(out) :: vector ベクトル場 real(kind=DR), intent(in) :: real 代入する実数 private  subroutine boundary_condition_scalar (scalar) スカラー場の境界条件設定\nプロセス間通信で領域境界データを交換 Arguments Type Intent Optional Attributes Name real(kind=DR), intent(inout), dimension(0:NXPP1,0:NYPP1,0:NZPP1) :: scalar スカラー場 Read more… private  subroutine boundary_condition_vector (vector) ベクトル場の境界条件設定\nプロセス間通信で領域境界データを交換 Arguments Type Intent Optional Attributes Name type( field__vector_t ), intent(inout) :: vector ベクトル場 Read more…","tags":"","loc":"module/field_m.html"},{"title":"grid_m – Smoke Ring","text":"Uses constants_m ut_m parallel_m module~~grid_m~~UsesGraph module~grid_m grid_m module~constants_m constants_m module~grid_m->module~constants_m module~parallel_m parallel_m module~grid_m->module~parallel_m ut_m ut_m module~grid_m->ut_m iso_fortran_env iso_fortran_env module~constants_m->iso_fortran_env module~parallel_m->module~constants_m module~parallel_m->ut_m mpi mpi module~parallel_m->mpi mpiut_m mpiut_m module~parallel_m->mpiut_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~grid_m~~UsedByGraph module~grid_m grid_m module~field_m field_m module~field_m->module~grid_m module~fluid_m fluid_m module~fluid_m->module~grid_m module~fluid_m->module~field_m module~solver_m solver_m module~solver_m->module~grid_m module~solver_m->module~field_m module~solver_m->module~fluid_m module~vis2d_m vis2d_m module~vis2d_m->module~grid_m module~vis2d_m->module~field_m module~vis2d_m->module~fluid_m module~vis2d_m->module~solver_m program~main_m main_m program~main_m->module~grid_m program~main_m->module~field_m program~main_m->module~fluid_m program~main_m->module~solver_m program~main_m->module~vis2d_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Variables Grid Derived Types grid__delta_t grid__derivative_operator_1st_t grid__derivative_operator_2nd_t grid__pos_t grid_global_ijk_t grid_local_ijk_from_global_ijk_t grid_pos_by_global_ijk_t grid_t Functions grid__i_have_gi grid__i_have_gijk grid__i_have_gj grid__i_have_gk initialize_global_ijk initialize_local_ijk_from_global_ijk initialize_pos initialize_pos_by_global_ijk Subroutines grid__initialize Variables Type Visibility Attributes Name Initial type( grid_t ), public :: Grid Derived Types type, private :: grid__delta_t 格子間隔構造体 Components Type Visibility Attributes Name Initial real(kind=DR), public :: x x方向の格子間隔 real(kind=DR), public :: y y方向の格子間隔 real(kind=DR), public :: z z方向の格子間隔 type, private :: grid__derivative_operator_1st_t 1階微分（差分）をとる時の演算子（定数）\n演算回数の節約のため Components Type Visibility Attributes Name Initial real(kind=DR), public :: x x偏微分 real(kind=DR), public :: y y偏微分 real(kind=DR), public :: z z偏微分 type, private :: grid__derivative_operator_2nd_t 2階微分（差分）をとる時の演算子（定数）\n演算回数の節約のため Components Type Visibility Attributes Name Initial real(kind=DR), public :: x x偏微分 real(kind=DR), public :: y y偏微分 real(kind=DR), public :: z z偏微分 type, private :: grid__pos_t 格子点位置を収める構造体\nposはpositionの意味 Components Type Visibility Attributes Name Initial real(kind=DR), public, dimension(0:NXPP1) :: x x座標（MPI領域分割した real(kind=DR), public, dimension(0:NYPP1) :: y y座標  各プロセスでの real(kind=DR), public, dimension(0:NZPP1) :: z z座標  局所的な番号） type, private :: grid_global_ijk_t global (gi,gj,gk) from local (li,lj,lk) Components Type Visibility Attributes Name Initial integer, public, dimension(0:NXPP1) :: gi MPIで領域分割した各プロセス integer, public, dimension(0:NYPP1) :: gj の局所的な格子点位置から integer, public, dimension(0:NZPP1) :: gk シミュ領域全体の格子点位置をとる type, private :: grid_local_ijk_from_global_ijk_t The opposite of above. Components Type Visibility Attributes Name Initial integer, public, dimension(NX_GLOBAL) :: li グローバルな格子点位置 integer, public, dimension(NY_GLOBAL) :: lj から局所的な格子点位置を integer, public, dimension(NZ_GLOBAL) :: lk 求める type, private :: grid_pos_by_global_ijk_t Components Type Visibility Attributes Name Initial real(kind=DR), public, dimension(NX_GLOBAL) :: x シミュ領域全体にわたる real(kind=DR), public, dimension(NY_GLOBAL) :: y 格子点番号 global な real(kind=DR), public, dimension(NZ_GLOBAL) :: z 番号という意味でgi等とよぶ type, private :: grid_t 格子点関係のデータを全て収める構造体\nこのモジュールの中心変数。これを介して外部と\nやり取りする。このグリッド変数の定義 (下記のgrid_t）\nと実体（このgrid）が同じ場所（このgrid_mモジュール内）\nにあるのは少々変則的かもしれないが、このように規模の\n小さいシミュレーションプログラムではこの方が\nむしろわかりやすいかもしれない。 Components Type Visibility Attributes Name Initial type( grid__derivative_operator_1st_t ), public :: d1 1階微分演算子定数 type( grid__derivative_operator_2nd_t ), public :: d2 2階微分演算子定数 type( grid__delta_t ), public :: delta 格子間隔 real(kind=DR), public :: delta_min 最小の格子間隔 type( grid_global_ijk_t ), public :: global_ijk type( grid_local_ijk_from_global_ijk_t ), public :: local_ijk_from_global_ijk type( grid__pos_t ), public :: pos 格子点位置 type( grid_pos_by_global_ijk_t ), public :: pos_by_global_ijk Type-Bound Procedures procedure\n                    ,                  public\n,                   :: i_have_gi => grid__i_have_gi Function global格子点giの位置をそのプロセスが含むかどうか。 procedure\n                    ,                  public\n,                   :: i_have_gijk => grid__i_have_gijk Function global格子点(gi,gj,gk)をそのプロセスが持っている\nかどうか。 procedure\n                    ,                  public\n,                   :: i_have_gj => grid__i_have_gj Function global格子点gjの位置を procedure\n                    ,                  public\n,                   :: i_have_gk => grid__i_have_gk Function global格子点gkの位置を procedure\n                    ,                  public\n,                   :: initialize => grid__initialize Subroutine 初期化関数\n初期化のためのメンバー関数\nこうするとgrid%initializeという形でcallできる Functions private  function grid__i_have_gi (grid, gi) result(ans) Arguments Type Intent Optional Attributes Name class( grid_t ), intent(in) :: grid integer, intent(in) :: gi Return Value logical private  function grid__i_have_gijk (grid, gi, gj, gk) result(ans) Arguments Type Intent Optional Attributes Name class( grid_t ), intent(in) :: grid integer, intent(in) :: gi integer, intent(in) :: gj integer, intent(in) :: gk Return Value logical private  function grid__i_have_gj (grid, gj) result(ans) Arguments Type Intent Optional Attributes Name class( grid_t ), intent(in) :: grid integer, intent(in) :: gj Return Value logical private  function grid__i_have_gk (grid, gk) result(ans) Arguments Type Intent Optional Attributes Name class( grid_t ), intent(in) :: grid integer, intent(in) :: gk Return Value logical private  function initialize_global_ijk () result(gijk) Arguments None Return Value type( grid_global_ijk_t ) private  function initialize_local_ijk_from_global_ijk (gijk) result(ans) Arguments Type Intent Optional Attributes Name type( grid_global_ijk_t ), intent(in) :: gijk Return Value type( grid_local_ijk_from_global_ijk_t ) < private  function initialize_pos (gijk, pos_by_gijk) result(pos) Arguments Type Intent Optional Attributes Name type( grid_global_ijk_t ), intent(in) :: gijk type( grid_pos_by_global_ijk_t ), intent(in) :: pos_by_gijk Return Value type( grid__pos_t ) private  function initialize_pos_by_global_ijk (dx, dy, dz) result(pos_gijk) Arguments Type Intent Optional Attributes Name real(kind=DR), intent(in) :: dx real(kind=DR), intent(in) :: dy real(kind=DR), intent(in) :: dz Return Value type( grid_pos_by_global_ijk_t ) Subroutines private  subroutine grid__initialize (grid) gridの初期化 Read more… Arguments Type Intent Optional Attributes Name class( grid_t ), intent(out) :: grid 格子構造体","tags":"","loc":"module/grid_m.html"},{"title":"main_m – Smoke Ring","text":"Uses solver_m vis2d_m parallel_m mpiut_m params_m constants_m job_m grid_m ut_m field_m fluid_m kutimer_m program~~main_m~~UsesGraph program~main_m main_m kutimer_m kutimer_m program~main_m->kutimer_m module~constants_m constants_m program~main_m->module~constants_m module~field_m field_m program~main_m->module~field_m module~fluid_m fluid_m program~main_m->module~fluid_m module~grid_m grid_m program~main_m->module~grid_m module~job_m job_m program~main_m->module~job_m module~parallel_m parallel_m program~main_m->module~parallel_m module~params_m params_m program~main_m->module~params_m module~solver_m solver_m program~main_m->module~solver_m module~vis2d_m vis2d_m program~main_m->module~vis2d_m mpiut_m mpiut_m program~main_m->mpiut_m ut_m ut_m program~main_m->ut_m iso_fortran_env iso_fortran_env module~constants_m->iso_fortran_env module~field_m->module~constants_m module~field_m->module~grid_m module~field_m->module~parallel_m module~field_m->mpiut_m module~fluid_m->module~constants_m module~fluid_m->module~field_m module~fluid_m->module~grid_m module~fluid_m->module~parallel_m module~fluid_m->mpiut_m module~grid_m->module~constants_m module~grid_m->module~parallel_m module~grid_m->ut_m module~job_m->module~constants_m module~job_m->module~parallel_m module~job_m->ut_m module~parallel_m->module~constants_m module~parallel_m->mpiut_m module~parallel_m->ut_m mpi mpi module~parallel_m->mpi module~params_m->module~constants_m module~params_m->ut_m module~params_m->iso_fortran_env module~solver_m->module~constants_m module~solver_m->module~field_m module~solver_m->module~fluid_m module~solver_m->module~grid_m module~solver_m->module~job_m module~solver_m->module~parallel_m module~solver_m->module~params_m module~solver_m->mpiut_m module~solver_m->ut_m module~vis2d_m->kutimer_m module~vis2d_m->module~constants_m module~vis2d_m->module~field_m module~vis2d_m->module~fluid_m module~vis2d_m->module~grid_m module~vis2d_m->module~parallel_m module~vis2d_m->module~solver_m module~vis2d_m->mpiut_m module~vis2d_m->ut_m vv_color_m vv_color_m module~vis2d_m->vv_color_m vv_sketch_m vv_sketch_m module~vis2d_m->vv_sketch_m vv_slice_scalar_m vv_slice_scalar_m module~vis2d_m->vv_slice_scalar_m vv_slice_vector_m vv_slice_vector_m module~vis2d_m->vv_slice_vector_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. 定数\nスカラー場・ベクトル場\n流体場の構造体定義\n格子点情報\nジョブ管理\n時間測定モジュール ;call kutimer__('main  ','sample')\nmpi関係ユーティリティ\nMPI並列化\nパラメータ\nナビエ・ストークス方程式ソルバ\nユーティリティ\n断面可視化\n暗黙の型宣言無効化。必須 パラメーターの読み込み。paramsの後に続くアンダースコア\n二つは、これがparamsモジュールの中にあるサブルーチンの\n呼び出しであることを意味している。paramsモジュールの\n名前はparams_mである。params_mはparams.f90にある。\nシミュレーションジョブの初期化\nされている。冒頭のPが大文字なのはこれがグローバル変数\nであることを示唆している。（コンパイラは大文字と小文字を\n区別しないが。）\ngridモジュールの初期化。\nパーセント記号はメンバアクセス演算子。\nここでは構造体のメンバー関数の呼び出しをしている。\ngridモジュール（grid_m）はgrid.f90で定義されている。\nsolverジュール（solver_m）の初期化。\n可視化モジュール（vis2d_m）の初期化。 時刻の初期化。単位は秒。\nループカウンタの初期化。 このモジュールはシミュレーション領域の断面図をSVGで出力する。 solverモジュールで定義されているdiagnosis（診断）\nサブルーチンを呼び出す。医者が患者を診るのがdiagnosis\nである。そこでの診断結果はJob.carte\nにセットする。carteはカルテである。 時間刻み幅 dt の決定。dtはCFL条件を満足するように決めるが、\nCFL条件は流体の状態に流体の状態に依存して変化する。\nたとえば、流体の一部が高温になると、そこでの音速が速くなり、\n音速によって決まるCFL条件が厳しくなる（つまりdtが小さくなる）\nここでは初期状態における流体の状態に基づいてdtが決まる このシミュレーションのメインループである。ジョブカルテが\n「健康 (fine)」状態である限りシミュレーションを続行する。 \nナビエ・ストークス方程式に基づいて流体 (fluid) の状態を\n一時刻ステップ dt だけ進める。\n流体の状態が変わったのでCFL条件に基づき時間刻み幅dt\nを設定し直す。\n厳密に言えば毎ステップこの再設定をしているわけではなく、\nこのsolver__set_time_stepルーチンの冒頭で判断し、\n数十ステップに一度だけ実際には変更を行うようなskip操作\nをしている。CFL条件に基づいた計算は時間がかかるが、\n毎ステップdtを精密に調整する必要はないからである。 ループカウンタのインクリメント\n診断。異常があればjob.carteにセットする。\nシミュレーション領域の断面図をSVGで出力する。\nあらかじめparamsモジュールで設定されたループカウンタの\n上限値に達したらジョブを停止する。\nジョブの後始末。MPI終了処理を含む。 Contents Variables dt fluid nloop time vis2d Source Code main_m Variables Type Attributes Name Initial real(kind=DR) :: dt type( fluid_t ) :: fluid integer :: nloop real(kind=DR) :: time type( vis2d_t ) :: vis2d Source Code program main_m use constants_m !! 定数 use field_m !! スカラー場・ベクトル場 use fluid_m !! 流体場の構造体定義 use grid_m !! 格子点情報 use job_m !! ジョブ管理 use kutimer_m !! 時間測定モジュール ;call kutimer__('main  ','sample') use mpiut_m !! mpi関係ユーティリティ use parallel_m !! MPI並列化 use params_m !! パラメータ use solver_m !! ナビエ・ストークス方程式ソルバ use ut_m !! ユーティリティ use vis2d_m !! 断面可視化 implicit none !! 暗黙の型宣言無効化。必須 integer :: nloop ! シミュレーションのループカウンタ real ( DR ) :: dt , time ! 時間刻み幅と時刻 type ( fluid_t ) :: fluid ! 流体場データの構造体 type ( vis2d_t ) :: vis2d call kutimer__start ( 'main  ' ) call Params % read ; call kutimer__ ( 'main  ' , 'params' ) !! パラメーターの読み込み。paramsの後に続くアンダースコア !! 二つは、これがparamsモジュールの中にあるサブルーチンの !! 呼び出しであることを意味している。paramsモジュールの !! 名前はparams_mである。params_mはparams.f90にある。 call Job % initialize ; call kutimer__ ( 'main  ' , 'job  i' ) !! シミュレーションジョブの初期化 !! されている。冒頭のPが大文字なのはこれがグローバル変数 !! であることを示唆している。（コンパイラは大文字と小文字を !! 区別しないが。） call Grid % initialize ; call kutimer__ ( 'main  ' , 'grid i' ) !! gridモジュールの初期化。 !! パーセント記号はメンバアクセス演算子。 !! ここでは構造体のメンバー関数の呼び出しをしている。 !! gridモジュール（grid_m）はgrid.f90で定義されている。 call Solver % initialize ( fluid ) ; call kutimer__ ( 'main  ' , 'solv i' ) !! solverジュール（solver_m）の初期化。 call vis2d % initialize ; call kutimer__ ( 'main  ' , 'vis  i' ) !! 可視化モジュール（vis2d_m）の初期化。 time = 0.0_DR !! 時刻の初期化。単位は秒。 nloop = 0 !! ループカウンタの初期化。 call vis2d % draw ( time , nloop , fluid ) !! このモジュールはシミュレーション領域の断面図をSVGで出力する。 call Solver % diagnosis ( nloop , time , fluid ) ; call kutimer__ ( 'main  ' , 'solv d' ) !! solverモジュールで定義されているdiagnosis（診断） !! サブルーチンを呼び出す。医者が患者を診るのがdiagnosis !! である。そこでの診断結果はJob.carte !! にセットする。carteはカルテである。 dt = Solver % set_time_step ( nloop , fluid ) ; call kutimer__ ( 'main  ' , 'set dt' ) !! 時間刻み幅 dt の決定。dtはCFL条件を満足するように決めるが、 !! CFL条件は流体の状態に流体の状態に依存して変化する。 !! たとえば、流体の一部が高温になると、そこでの音速が速くなり、 !! 音速によって決まるCFL条件が厳しくなる（つまりdtが小さくなる） !! ここでは初期状態における流体の状態に基づいてdtが決まる do while ( Job % karte == \"fine\" ) ; call kutimer__count !! このシミュレーションのメインループである。ジョブカルテが !! 「健康 (fine)」状態である限りシミュレーションを続行する。 call Solver % advance ( time , dt , fluid ) ; call kutimer__ ( 'main  ' , 'solv a' ) !! ナビエ・ストークス方程式に基づいて流体 (fluid) の状態を !! 一時刻ステップ dt だけ進める。 dt = Solver % set_time_step ( nloop , fluid ) ; call kutimer__ ( 'main  ' , 'set dt' ) !! 流体の状態が変わったのでCFL条件に基づき時間刻み幅dt !! を設定し直す。 !! 厳密に言えば毎ステップこの再設定をしているわけではなく、 !! このsolver__set_time_stepルーチンの冒頭で判断し、 !! 数十ステップに一度だけ実際には変更を行うようなskip操作 !! をしている。CFL条件に基づいた計算は時間がかかるが、 !! 毎ステップdtを精密に調整する必要はないからである。 nloop = nloop + 1 !! ループカウンタのインクリメント call Solver % diagnosis ( nloop , time , fluid ) ; call kutimer__ ( 'main  ' , 'solv d' ) !! 診断。異常があればjob.carteにセットする。 call vis2d % draw ( time , nloop , fluid ) !! シミュレーション領域の断面図をSVGで出力する。 if ( nloop >= Params % get_integer ( 'Total_nloop' ) ) then Job % karte = \"loop_max\" !! あらかじめparamsモジュールで設定されたループカウンタの !! 上限値に達したらジョブを停止する。 end if end do call kutimer__end ( 'main  ' ) call kutimer__print call Job % finalize ( nloop ) !! ジョブの後始末。MPI終了処理を含む。 end program main_m","tags":"","loc":"program/main_m.html"},{"title":"constants.F90 – Smoke Ring","text":"< Files dependent on this one sourcefile~~constants.f90~~AfferentGraph sourcefile~constants.f90 constants.F90 sourcefile~field.f90 field.F90 sourcefile~field.f90->sourcefile~constants.f90 sourcefile~grid.f90 grid.F90 sourcefile~field.f90->sourcefile~grid.f90 sourcefile~parallel.f90 parallel.F90 sourcefile~field.f90->sourcefile~parallel.f90 sourcefile~fluid.f90 fluid.F90 sourcefile~fluid.f90->sourcefile~constants.f90 sourcefile~fluid.f90->sourcefile~field.f90 sourcefile~fluid.f90->sourcefile~grid.f90 sourcefile~fluid.f90->sourcefile~parallel.f90 sourcefile~grid.f90->sourcefile~constants.f90 sourcefile~grid.f90->sourcefile~parallel.f90 sourcefile~job.f90 job.F90 sourcefile~job.f90->sourcefile~constants.f90 sourcefile~job.f90->sourcefile~parallel.f90 sourcefile~main.f90 main.F90 sourcefile~main.f90->sourcefile~constants.f90 sourcefile~main.f90->sourcefile~field.f90 sourcefile~main.f90->sourcefile~fluid.f90 sourcefile~main.f90->sourcefile~grid.f90 sourcefile~main.f90->sourcefile~job.f90 sourcefile~main.f90->sourcefile~parallel.f90 sourcefile~params.f90 params.F90 sourcefile~main.f90->sourcefile~params.f90 sourcefile~solver.f90 solver.F90 sourcefile~main.f90->sourcefile~solver.f90 sourcefile~vis2d.f90 vis2d.F90 sourcefile~main.f90->sourcefile~vis2d.f90 sourcefile~parallel.f90->sourcefile~constants.f90 sourcefile~params.f90->sourcefile~constants.f90 sourcefile~solver.f90->sourcefile~constants.f90 sourcefile~solver.f90->sourcefile~field.f90 sourcefile~solver.f90->sourcefile~fluid.f90 sourcefile~solver.f90->sourcefile~grid.f90 sourcefile~solver.f90->sourcefile~job.f90 sourcefile~solver.f90->sourcefile~parallel.f90 sourcefile~solver.f90->sourcefile~params.f90 sourcefile~vis2d.f90->sourcefile~constants.f90 sourcefile~vis2d.f90->sourcefile~field.f90 sourcefile~vis2d.f90->sourcefile~fluid.f90 sourcefile~vis2d.f90->sourcefile~grid.f90 sourcefile~vis2d.f90->sourcefile~parallel.f90 sourcefile~vis2d.f90->sourcefile~solver.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Modules constants_m Source Code constants.F90 Source Code !!> !     author: Akira Kageyama !     date: 2023.05.05 ! !     Fortran定数と数学定数 ! !     @note 定数であることが目で見てわかりやすいように全ての文字を !           大文字で書いているがコンパイラには無意味。 ! !     @note シミュレーション領域は直方体と仮定している。 !           x方向の長さXMAX-XMINである。座標系の原点を !           シミュレーション領域の中心におくためには !           XMAXとXMIN絶対値を等しくとる。 ! !     @note シミュレーションの（x方向の）空間解像度を上げる !           ためには同じXMAX-XMINに対して格子点数NXを上げれば良い。 ! !     @note x,y,z それぞれの方向の空間解像度、 !           つまり格子間隔dx,dy,dzが異なっていても構わないが、 !           その差が極端に大きくしないほうがよい。 !!< module constants_m use iso_fortran_env implicit none logical , parameter :: DEBUG_MODE = . true . ! << f90 constants >> integer , parameter :: SI = int32 ! 単精度整数 integer , parameter :: DI = int64 ! 倍精度整数 integer , parameter :: SR = real32 ! 単精度実数 integer , parameter :: DR = real64 ! 倍精度実数 ! << Mathematical constants >> real ( DR ), parameter :: PI = atan ( 1.0_DR ) * 4 real ( DR ), parameter :: TWOPI = PI * 2 !<< MPI process constants >>! integer , parameter :: NPROC_X = 2 ! x方向MPIプロセス数 mkjob.sh でこの行をgrepする integer , parameter :: NPROC_Y = 1 ! y方向MPIプロセス数 mkjob.sh でこの行をgrepする integer , parameter :: NPROC_Z = 2 ! z方向MPIプロセス数 mkjob.sh でこの行をgrepする !<< Code utility constants >>! integer , parameter :: NIL = - huge ( 1 ) !<< Grid size constants >>! integer , parameter :: NXPP = 30 ! PP = Per Process integer , parameter :: NYPP = 20 integer , parameter :: NZPP = 10 integer , parameter :: NXPP1 = NXPP + 1 ! PP1 = PP plus one integer , parameter :: NYPP1 = NYPP + 1 integer , parameter :: NZPP1 = NZPP + 1 integer , parameter :: NX_GLOBAL = NXPP * NPROC_X + 2 ! x方向の全格子点数 integer , parameter :: NY_GLOBAL = NYPP * NPROC_Y + 2 integer , parameter :: NZ_GLOBAL = NZPP * NPROC_Z + 2 ! 格子サイズのメモ ! NX_GLOBAL =  60    ! 格子点数 x方向 粗い解像度 ! NY_GLOBAL =  20    ! 格子点数 y方向 粗い解像度 ! NZ_GLOBAL =  20    ! 格子点数 z方向 粗い解像度 ! --- ! NX_GLOBAL =  92    ! 格子点数 x方向 ! NY_GLOBAL =  32    ! 格子点数 y方向 ! NZ_GLOBAL =  32    ! 格子点数 z方向 ! --- ! NX_GLOBAL = 152    ! 格子点数 x方向 少し高めの解像度 ! NY_GLOBAL =  52    ! 格子点数 y方向 少し高めの解像度 ! NZ_GLOBAL =  52    ! 格子点数 z方向 少し高めの解像度 ! << Box Size >> real ( DR ), parameter :: XMIN = - 1.5_DR ! 計算領域範囲 +x  単位はメートル real ( DR ), parameter :: XMAX = + 1.5_DR ! 計算領域範囲 -x real ( DR ), parameter :: YMIN = - 0.5_DR ! 計算領域範囲 +y real ( DR ), parameter :: YMAX = + 0.5_DR ! 計算領域範囲 -y real ( DR ), parameter :: ZMIN = - 0.5_DR ! 計算領域範囲 +z real ( DR ), parameter :: ZMAX = + 0.5_DR ! 計算領域範囲 -z end module constants_m","tags":"","loc":"sourcefile/constants.f90.html"},{"title":"vis2d.F90 – Smoke Ring","text":"This file depends on sourcefile~~vis2d.f90~~EfferentGraph sourcefile~vis2d.f90 vis2d.F90 sourcefile~constants.f90 constants.F90 sourcefile~vis2d.f90->sourcefile~constants.f90 sourcefile~field.f90 field.F90 sourcefile~vis2d.f90->sourcefile~field.f90 sourcefile~fluid.f90 fluid.F90 sourcefile~vis2d.f90->sourcefile~fluid.f90 sourcefile~grid.f90 grid.F90 sourcefile~vis2d.f90->sourcefile~grid.f90 sourcefile~parallel.f90 parallel.F90 sourcefile~vis2d.f90->sourcefile~parallel.f90 sourcefile~solver.f90 solver.F90 sourcefile~vis2d.f90->sourcefile~solver.f90 sourcefile~field.f90->sourcefile~constants.f90 sourcefile~field.f90->sourcefile~grid.f90 sourcefile~field.f90->sourcefile~parallel.f90 sourcefile~fluid.f90->sourcefile~constants.f90 sourcefile~fluid.f90->sourcefile~field.f90 sourcefile~fluid.f90->sourcefile~grid.f90 sourcefile~fluid.f90->sourcefile~parallel.f90 sourcefile~grid.f90->sourcefile~constants.f90 sourcefile~grid.f90->sourcefile~parallel.f90 sourcefile~parallel.f90->sourcefile~constants.f90 sourcefile~solver.f90->sourcefile~constants.f90 sourcefile~solver.f90->sourcefile~field.f90 sourcefile~solver.f90->sourcefile~fluid.f90 sourcefile~solver.f90->sourcefile~grid.f90 sourcefile~solver.f90->sourcefile~parallel.f90 sourcefile~job.f90 job.F90 sourcefile~solver.f90->sourcefile~job.f90 sourcefile~params.f90 params.F90 sourcefile~solver.f90->sourcefile~params.f90 sourcefile~job.f90->sourcefile~constants.f90 sourcefile~job.f90->sourcefile~parallel.f90 sourcefile~params.f90->sourcefile~constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~vis2d.f90~~AfferentGraph sourcefile~vis2d.f90 vis2d.F90 sourcefile~main.f90 main.F90 sourcefile~main.f90->sourcefile~vis2d.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Modules vis2d_m Source Code vis2d.F90 Source Code module vis2d_m !!> ! !    vis2d.ef !      2023.05.04: Copied from tetrahedral_dynamo project. ! !!< use constants_m use grid_m use field_m use fluid_m use kutimer_m use mpiut_m use parallel_m use ut_m use vv_color_m use vv_sketch_m use vv_slice_scalar_m use vv_slice_vector_m use solver_m implicit none private public :: vis2d__initialize , & vis2d__draw integer , parameter :: TAG_NAME_MAX = 100 integer , parameter :: FILE_NAME_MAX = 200 type vis2d_plane_xy_t integer :: gk_cut character ( len = TAG_NAME_MAX ) :: tag type ( vv_slice_scalar_t ) :: pressure type ( vv_slice_scalar_t ) :: flow_helicity type ( vv_slice_scalar_t ) :: velocity_z type ( vv_slice_scalar_t ) :: enstrophy type ( vv_slice_vector_t ) :: velocity type ( vv_slice_vector_t ) :: vorticity contains procedure :: initialize => vis2d_plane_xy__initialize procedure :: set_data => vis2d_plane_xy__set_data procedure :: draw => vis2d_plane_xy__draw end type vis2d_plane_xy_t type vis2d_plane_xz_t integer :: gj_cut character ( len = TAG_NAME_MAX ) :: tag type ( vv_slice_scalar_t ) :: pressure type ( vv_slice_scalar_t ) :: flow_helicity type ( vv_slice_scalar_t ) :: velocity_y type ( vv_slice_scalar_t ) :: enstrophy type ( vv_slice_vector_t ) :: velocity type ( vv_slice_vector_t ) :: vorticity contains procedure :: initialize => vis2d_plane_xz__initialize procedure :: set_data => vis2d_plane_xz__set_data procedure :: draw => vis2d_plane_xz__draw end type vis2d_plane_xz_t type , public :: vis2d_t type ( vis2d_plane_xy_t ) :: z_middle type ( vis2d_plane_xy_t ) :: z_upper type ( vis2d_plane_xy_t ) :: z_lower type ( vis2d_plane_xz_t ) :: y_middle type ( vis2d_plane_xz_t ) :: y_upper type ( vis2d_plane_xz_t ) :: y_lower contains procedure :: initialize => vis2d__initialize procedure :: set_data => vis2d__set_data procedure :: draw => vis2d__draw end type vis2d_t type , private :: vissubfield3d_t real ( DR ), dimension ( 0 : NXPP1 , 0 : NYPP1 , 0 : NZPP1 ) :: enstrophy !! エンストロフィ（渦度の2乗） real ( DR ), dimension ( 0 : NXPP1 , 0 : NYPP1 , 0 : NZPP1 ) :: helicity !! ヘリシティ type ( field__vector_t ) :: velocity !! 流れ場 type ( field__vector_t ) :: vorticity !! 渦度（流れ場のcurl） contains procedure :: update => vissubfield3d__update end type vissubfield3d_t contains subroutine vissubfield3d__update ( vf , fluid ) class ( vissubfield3d_t ), intent ( out ) :: vf type ( fluid_t ) , intent ( in ) :: fluid call solver % get_subfield ( fluid , vf % velocity ) vf % vorticity = . curl . vf % velocity ! curl演算子はfield_mで定義 vf % helicity = vf % velocity . dot . vf % vorticity ! ヘリシティ = 流れと渦度の内積 vf % enstrophy = vf % vorticity . dot . vf % vorticity ! 内積演算子はfield_mで定義 end subroutine vissubfield3d__update subroutine vis2d_plane_xy__draw ( plane , t , step ) class ( vis2d_plane_xy_t ), intent ( inout ) :: plane real , intent ( in ) :: t integer , intent ( in ) :: step character ( len = TAG_NAME_MAX ) :: tas character ( len = FILE_NAME_MAX ) :: filename type ( vv_sketch__sim_pos_t ) :: ll , & ! lower left ur ! upper right ll % u = XMIN ll % v = YMIN ur % u = XMAX ur % v = YMAX call kutimer__start ( 'vis2xy' ) call make_time_and_step_string ( t , step , tas ) !!> !    call make_filename( tas, plane.tag, plane.pressure.tag, filename ) !    call draw_contour( ll, ur, filename, plane.pressure ) !                                               call kutimer__('vis2xy','  pres') !    call make_filename( tas, plane.tag, plane.flow_helicity.tag, filename ) !    call draw_contour( ll, ur, filename, plane.flow_helicity ) !                                               call kutimer__('vis2xy','f heli') !    call make_filename( tas, plane.tag, plane.velocity_z.tag, filename ) !    call draw_contour( ll, ur, filename, plane.velocity_z ) !                                               call kutimer__('vis2xy',' vel z') !    call make_filename( tas, plane.tag, plane.enstrophy.tag, filename ) !    call draw_contour( ll, ur, filename, plane.enstrophy ) !                                               call kutimer__('vis2xy','   ens') !    call make_filename( tas, plane.tag, plane.velocity.tag, filename ) !    call draw_arrows( ll, ur, filename, plane.velocity ) !                                               call kutimer__('vis2xy','   vel') !    call make_filename( tas, plane.tag, plane.vorticity.tag, filename ) !    call draw_arrows( ll, ur, filename, plane.vorticity ) !                                               call kutimer__('vis2xy','   vor') !!< call make_filename ( tas , plane % tag , 'enstrophy_and_flow' , filename ) call draw_contour_and_arrows ( ll , ur , filename , plane % enstrophy , & plane % velocity ) call kutimer__ ( 'vis2xy' , 'ensvel' ) call kutimer__end ( 'vis2xy' ) end subroutine vis2d_plane_xy__draw subroutine vis2d_plane_xz__draw ( plane , t , step ) class ( vis2d_plane_xz_t ), intent ( inout ) :: plane real , intent ( in ) :: t integer , intent ( in ) :: step character ( len = TAG_NAME_MAX ) :: tas ! time and step string character ( len = FILE_NAME_MAX ) :: filename type ( vv_sketch__sim_pos_t ) :: ll , & ! lower left ur ! upper right ll % u = XMIN ll % v = ZMIN ur % u = XMAX ur % v = ZMAX call kutimer__start ( 'vis2xz' ) call make_time_and_step_string ( t , step , tas ) !!> !    call make_filename( tas, plane.tag, plane.pressure.tag, filename ) !    call draw_contour( ll, ur, filename, plane.pressure ) !                                               call kutimer__('vis2xz','  pres') !    call make_filename( tas, plane.tag, plane.flow_helicity.tag, filename ) !    call draw_contour( ll, ur, filename, plane.flow_helicity ) !                                               call kutimer__('vis2xz','f heli') !    call make_filename( tas, plane.tag, plane.velocity_y.tag, filename ) !    call draw_contour( ll, ur, filename, plane.velocity_y ) !                                               call kutimer__('vis2xz',' vel z') !!< call make_filename ( tas , plane % tag , plane % enstrophy % tag , filename ) call draw_contour ( ll , ur , filename , plane % enstrophy ) call kutimer__ ( 'vis2xz' , '   ens' ) !!> !    call make_filename( tas, plane.tag, plane.velocity.tag, filename ) !    call draw_arrows( ll, ur, filename, plane.velocity ) !                                               call kutimer__('vis2xz','   vel') !    call make_filename( tas, plane.tag, plane.vorticity.tag, filename ) !    call draw_arrows( ll, ur, filename, plane.vorticity ) !                                               call kutimer__('vis2xz','   vor') !!< call make_filename ( tas , plane % tag , 'combined_ens_vel' , filename ) call draw_contour_and_arrows ( ll , ur , filename , plane % enstrophy , & plane % velocity ) call kutimer__ ( 'vis2xz' , 'ensvel' ) call kutimer__end ( 'vis2xz' ) end subroutine vis2d_plane_xz__draw subroutine make_time_and_step_string ( t , step , string ) real , intent ( in ) :: t integer , intent ( in ) :: step character ( len = TAG_NAME_MAX ), intent ( out ) :: string character ( len = 1 ), parameter :: CHAR_USCORE = \"_\" character ( len = 10 ) :: str_time_with_sign character ( len = 8 ) :: str_step_with_sign character ( len = 9 ) :: str_time_without_sign character ( len = 7 ) :: str_step_without_sign str_time_with_sign = ut__real_to_str10 ( t ) str_step_with_sign = ut__int_to_str8 ( step ) call ut__assert ( str_time_with_sign ( 1 : 1 ) == \"+\" , & \"vis2d_m/make_time_and_step_string(203): \" // & \"str_time_with_sign is strange.\" ) call ut__assert ( str_step_with_sign ( 1 : 1 ) == \"+\" , & \"vis2d_m/make_time_and_step_string(206): \" // & \"str_step_with_sign is strange.\" ) str_time_without_sign = str_time_with_sign ( 2 : 10 ) str_step_without_sign = str_step_with_sign ( 2 : 8 ) string = \"s=\" // str_step_without_sign & // CHAR_USCORE // & \"t=\" // str_time_without_sign end subroutine make_time_and_step_string subroutine make_filename ( time_and_step_string , tag1 , tag2 , filename ) character ( len = TAG_NAME_MAX ), intent ( in ) :: time_and_step_string character ( len =* ), intent ( in ) :: tag1 , tag2 character ( len = FILE_NAME_MAX ), intent ( out ) :: filename character ( len = 1 ), parameter :: CHAR_USCORE = \"_\" character ( len = 1 ), parameter :: CHAR_SLASH = \"/\" character ( len =* ), parameter :: DIR = '../data/vis2d' filename = DIR // CHAR_SLASH // & trim ( tag1 ) // CHAR_USCORE // & trim ( tag2 ) // CHAR_USCORE // & trim ( time_and_step_string ) // '.svg' end subroutine make_filename subroutine vis2d_plane_xy__initialize ( plane , & gk_cut , & tag ) class ( vis2d_plane_xy_t ), intent ( out ) :: plane integer , intent ( in ) :: gk_cut character ( len =* ), intent ( in ) :: tag real ( SR ), dimension (:), allocatable :: grid_u real ( SR ), dimension (:), allocatable :: grid_v integer :: nu , nv nu = NX_GLOBAL nv = NY_GLOBAL allocate ( grid_u ( nu ), grid_v ( nv )) grid_u (:) = real ( Grid % pos_by_global_ijk % x (:), SR ) grid_v (:) = real ( Grid % pos_by_global_ijk % y (:), SR ) plane % gk_cut = gk_cut plane % tag = tag call plane % pressure % initialize ( 'pressure' , & nu , & nv , & grid_u , & grid_v ) call plane % flow_helicity % initialize ( 'flow_helicity' , & nu , & nv , & grid_u , & grid_v ) call plane % velocity_z % initialize ( 'velocity_z' , & nu , & nv , & grid_u , & grid_v ) call plane % enstrophy % initialize ( 'enstrophy' , & nu , & nv , & grid_u , & grid_v ) call plane % velocity % initialize ( 'velocity' , & nu , & nv , & grid_u , & grid_v ) call plane % vorticity % initialize ( 'vorticity' , & nu , & nv , & grid_u , & grid_v ) end subroutine vis2d_plane_xy__initialize subroutine vis2d_plane_xz__initialize ( plane , & gj_cut , & tag ) class ( vis2d_plane_xz_t ), intent ( out ) :: plane integer , intent ( in ) :: gj_cut character ( len =* ), intent ( in ) :: tag real ( SR ), dimension (:), allocatable :: grid_u real ( SR ), dimension (:), allocatable :: grid_v integer :: nu , nv nu = NX_GLOBAL nv = NZ_GLOBAL allocate ( grid_u ( nu ), grid_v ( nv )) grid_u (:) = real ( Grid % pos_by_global_ijk % x (:), SR ) grid_v (:) = real ( Grid % pos_by_global_ijk % z (:), SR ) plane % gj_cut = gj_cut plane % tag = tag call plane % pressure % initialize ( 'pressure' , & nu , & nv , & grid_u , & grid_v ) call plane % flow_helicity % initialize ( 'flow_helicity' , & nu , & nv , & grid_u , & grid_v ) call plane % velocity_y % initialize ( 'velocity_y' , & nu , & nv , & grid_u , & grid_v ) call plane % enstrophy % initialize ( 'enstrophy' , & nu , & nv , & grid_u , & grid_v ) call plane % velocity % initialize ( 'velocity' , & nu , & nv , & grid_u , & grid_v ) call plane % vorticity % initialize ( 'vorticity' , & nu , & nv , & grid_u , & grid_v ) end subroutine vis2d_plane_xz__initialize subroutine vis2d_plane_xy__set_data ( plane , fluid , vf ) class ( vis2d_plane_xy_t ) , intent ( inout ) :: plane type ( fluid_t ) , intent ( in ) :: fluid type ( vissubfield3d_t ) , intent ( in ) :: vf integer :: nu , nv , gk_cut nu = plane % pressure % mesh % vert % nu nv = plane % pressure % mesh % vert % nv gk_cut = plane % gk_cut plane % pressure % val_vert = iCut ( nu , nv , gk_cut , & fluid % pressure ) plane % flow_helicity % val_vert = iCut ( nu , nv , gk_cut , & vf % helicity ) plane % velocity_z % val_vert = iCut ( nu , nv , gk_cut , & vf % velocity % z ) plane % enstrophy % val_vert = iCut ( nu , nv , gk_cut , & vf % enstrophy ) plane % velocity % comp_u = iCut ( nu , nv , gk_cut , & vf % velocity % x ) plane % velocity % comp_v = iCut ( nu , nv , gk_cut , & vf % velocity % y ) plane % vorticity % comp_u = iCut ( nu , nv , gk_cut , & vf % vorticity % x ) plane % vorticity % comp_v = iCut ( nu , nv , gk_cut , & vf % vorticity % y ) contains function iCut ( nu , nv , gk_cut , field3d1 , field3d0 ) result ( field2d ) integer , intent ( in ) :: nu , nv , gk_cut real ( DR ), dimension ( 0 : NXPP1 , 0 : NYPP1 , 0 : NZPP1 ), intent ( in ) :: field3d1 real ( DR ), dimension ( 0 : NXPP1 , 0 : NYPP1 , 0 : NZPP1 ), intent ( in ), optional :: field3d0 real , dimension ( nu , nv ) :: field2d !!> !          When NXPP=3, NPROC_X=2, NX_GLOBAL=8 ! !         [rank 0] !                        li=0   1    2    3    4 !             field3d1&0...o----o----o----o----o !                          |    |    |    | !             field2d......o----o----o----o----x----x----x----x !                        gi=1   2    3    4    5    6    7    8 ! !         [rank 1] !                                       li=0   1    2    3    4 !             field3d1&0..................o----o----o----o----o !                                              |    |    |    | !             field2d......x----x----x----x----o----o----o----o !                        gi=1   2    3    4    5    6    7    8 ! ! !         <<all_reduce_sum>> !                        gi=1   2    3    4    5    6    7    8 !                 [rank 0] o----o----o----o----x----x----x----x !                 [rank 1] x----x----x----x----o----o----o----o !                          |    |    |    |    |    |    |    | !             field2d......o----o----o----o----o----o----o----o ! !!< integer :: li , lj , lk_cut , gi , gj integer :: li_from , li_to , lj_from , lj_to field2d (:,:) = 0.0 if ( Grid % i_have_gk ( gk_cut ) ) then lk_cut = Grid % local_ijk_from_global_ijk % lk ( gk_cut ) li_from = 1 ! default li_to = NXPP ! default lj_from = 1 ! default lj_to = NYPP ! default if ( Parallel % i_have_xmin ) li_from = 0 if ( Parallel % i_have_xmax ) li_to = NXPP1 if ( Parallel % i_have_ymin ) lj_from = 0 if ( Parallel % i_have_ymax ) lj_to = NYPP1 if ( present ( field3d0 ) ) then do lj = lj_from , lj_to do li = li_from , li_to gj = Grid % global_ijk % gj ( lj ) gi = Grid % global_ijk % gi ( li ) field2d ( gi , gj ) = real ( field3d1 ( li , lj , lk_cut ) & - field3d0 ( li , lj , lk_cut ), SR ) end do end do else do lj = lj_from , lj_to do li = li_from , li_to gj = Grid % global_ijk % gj ( lj ) gi = Grid % global_ijk % gi ( li ) field2d ( gi , gj ) = real ( field3d1 ( li , lj , lk_cut ), SR ) end do end do end if end if call mpiut__allreduce_sum ( Parallel % comm , field2d ) end function iCut end subroutine vis2d_plane_xy__set_data subroutine vis2d_plane_xz__set_data ( plane , fluid , vf ) class ( vis2d_plane_xz_t ) , intent ( inout ) :: plane type ( fluid_t ) , intent ( in ) :: fluid type ( vissubfield3d_t ) , intent ( in ) :: vf integer :: nu , nv , gj_cut nu = plane % pressure % mesh % vert % nu nv = plane % pressure % mesh % vert % nv gj_cut = plane % gj_cut plane % pressure % val_vert = iCut ( nu , nv , gj_cut , & fluid % pressure ) plane % flow_helicity % val_vert = iCut ( nu , nv , gj_cut , & vf % helicity ) plane % velocity_y % val_vert = iCut ( nu , nv , gj_cut , & vf % velocity % y ) plane % enstrophy % val_vert = iCut ( nu , nv , gj_cut , & vf % enstrophy ) plane % velocity % comp_u = iCut ( nu , nv , gj_cut , & vf % velocity % x ) plane % velocity % comp_v = iCut ( nu , nv , gj_cut , & vf % velocity % z ) plane % vorticity % comp_u = iCut ( nu , nv , gj_cut , & vf % vorticity % x ) plane % vorticity % comp_v = iCut ( nu , nv , gj_cut , & vf % vorticity % z ) contains function iCut ( nu , nv , gj_cut , field3d1 , field3d0 ) result ( field2d ) integer , intent ( in ) :: nu , nv , gj_cut real ( DR ), dimension ( 0 : NXPP1 , 0 : NYPP1 , 0 : NZPP1 ), intent ( in ) :: field3d1 real ( DR ), dimension ( 0 : NXPP1 , 0 : NYPP1 , 0 : NZPP1 ), intent ( in ), optional :: field3d0 real , dimension ( nu , nv ) :: field2d integer :: li , lk , lj_cut , gi , gk integer :: li_from , li_to , lk_from , lk_to field2d (:,:) = 0.0 if ( Grid % i_have_gj ( gj_cut ) ) then lj_cut = Grid % local_ijk_from_global_ijk % lj ( gj_cut ) li_from = 1 ! default li_to = NXPP ! default lk_from = 1 ! default lk_to = NZPP ! default if ( Parallel % i_have_xmin ) li_from = 0 if ( Parallel % i_have_xmax ) li_to = NXPP1 if ( Parallel % i_have_zmin ) lk_from = 0 if ( Parallel % i_have_zmax ) lk_to = NZPP1 if ( present ( field3d0 ) ) then do lk = lk_from , lk_to do li = li_from , li_to gk = Grid % global_ijk % gk ( lk ) gi = Grid % global_ijk % gi ( li ) field2d ( gi , gk ) = real ( field3d1 ( li , lj_cut , lk ) & - field3d0 ( li , lj_cut , lk ), SR ) end do end do else do lk = lk_from , lk_to do li = li_from , li_to gk = Grid % global_ijk % gk ( lk ) gi = Grid % global_ijk % gi ( li ) field2d ( gi , gk ) = real ( field3d1 ( li , lj_cut , lk ), SR ) end do end do end if end if call mpiut__allreduce_sum ( Parallel % comm , field2d ) end function iCut end subroutine vis2d_plane_xz__set_data subroutine vis2d__initialize ( vis2d ) class ( vis2d_t ), intent ( out ) :: vis2d integer :: gk_cut , gj_cut gk_cut = int ( NZ_GLOBAL * 0.5 ) call vis2d % z_middle % initialize ( gk_cut , 'z_middle' ) gk_cut = int ( NZ_GLOBAL * 0.75 ) call vis2d % z_upper % initialize ( gk_cut , 'z_upper' ) gk_cut = int ( NZ_GLOBAL * 0.25 ) call vis2d % z_lower % initialize ( gk_cut , 'z_lower' ) gj_cut = int ( NY_GLOBAL * 0.5 ) call vis2d % y_middle % initialize ( gj_cut , 'y_middle' ) gj_cut = int ( NY_GLOBAL * 0.75 ) call vis2d % y_upper % initialize ( gj_cut , 'y_upper' ) gj_cut = int ( NY_GLOBAL * 0.25 ) call vis2d % y_lower % initialize ( gj_cut , 'y_lower' ) end subroutine vis2d__initialize subroutine vis2d__set_data ( vis2d , fluid ) class ( vis2d_t ) , intent ( inout ) :: vis2d type ( fluid_t ) , intent ( in ) :: fluid type ( vissubfield3d_t ) :: vissubfield3d call vissubfield3d % update ( fluid ) call vis2d % z_middle % set_data ( fluid , vissubfield3d ) call vis2d % z_upper % set_data ( fluid , vissubfield3d ) call vis2d % z_lower % set_data ( fluid , vissubfield3d ) call vis2d % y_middle % set_data ( fluid , vissubfield3d ) call vis2d % y_upper % set_data ( fluid , vissubfield3d ) call vis2d % y_lower % set_data ( fluid , vissubfield3d ) end subroutine vis2d__set_data function min_max_string ( vmin , vmax ) result ( string ) real , intent ( in ) :: vmin , vmax character ( len = TAG_NAME_MAX ) :: string character ( len = 10 ) :: str10_vmax , str10_vmin str10_vmin = ut__real_to_str10 ( vmin ) str10_vmax = ut__real_to_str10 ( vmax ) string = 'vmin = ' // str10_vmin // ' vmax = ' // str10_vmax end function min_max_string function vec_amp_max_string ( vmax ) result ( string ) real , intent ( in ) :: vmax character ( len = TAG_NAME_MAX ) :: string character ( len = 10 ) :: str10_vmax str10_vmax = ut__real_to_str10 ( vmax ) string = 'vmax = ' // str10_vmax end function vec_amp_max_string subroutine draw_contour ( ll , ur , filename , scalar ) type ( vv_sketch__sim_pos_t ), intent ( in ) :: ll , & ! lower left ur ! upper right character ( len =* ), intent ( in ) :: filename type ( vv_slice_scalar_t ), intent ( inout ) :: scalar type ( vv_sketch_t ) :: vv_sketch real :: level_min , level_max , dlevel , level , level_nrm real :: level_range type ( vv_color_t ) :: color , color_black integer :: l character ( len = TAG_NAME_MAX ) :: message real , parameter :: ALMOST_ZERO = 1.e-20_SR real , parameter :: TOO_SMALL_DIFF_FOR_CONTOUR = 1.e-3_SR real :: max_min_diff_normalized real :: level_amplitude logical :: flag_skip_contour color_black = VV_COLOR__CONST % black flag_skip_contour = . false . !! default call vv_sketch % initialize ( ll , ur , & screen_width_in_pixel = 100 0.0 , & title = scalar % tag , & filename = trim ( filename ) ) ! --<boundary curve>-- call scalar % mesh % draw ( vv_sketch , & line_color = VV_COLOR__CONST % black , & width_in_pixels = 1.0 ) level_min = minval ( scalar % val_vert ) level_max = maxval ( scalar % val_vert ) message = min_max_string ( level_min , level_max ) call iText_in_header_and_footer ( message ) level_amplitude = max ( abs ( level_max ), abs ( level_min )) if ( level_amplitude <= ALMOST_ZERO ) then call vv_sketch % finalize return end if level_range = level_max - level_min max_min_diff_normalized = level_range / level_amplitude if ( max_min_diff_normalized <= TOO_SMALL_DIFF_FOR_CONTOUR ) then call vv_sketch % finalize return end if call vv_sketch % group_push ( line_color = VV_COLOR__CONST % magenta , & line_width_in_pixel = 1.0 ) dlevel = level_range / 10 do l = 1 , 10 level = level_min + dlevel * ( real ( l ) - 0.5 ) level_nrm = ( level - level_min ) / level_range color = vv_color__normalized_real_to_color ( level_nrm ) call scalar % vis_contour ( vv_sketch , & level , & line_color = color_black , & fill_color = color ) ! debug_print=.true. ) ! for debug. end do call vv_sketch % group_pop call vv_sketch % finalize contains subroutine iText_in_header_and_footer ( message ) character ( len = TAG_NAME_MAX ), intent ( in ) :: message real :: text_v_pos_in_physical_unit real :: tsep ! text v position separation betwen lines call vv_sketch % group_push ( line_color = color_black , & line_width_in_pixel = 1.0 ) tsep = ( ur % v - ll % v ) * 0.1 ! --<figure title in the header>-- text_v_pos_in_physical_unit = ur % v + tsep call vv_sketch % text ( ( ll % u + ur % u ) / 2 , & text_v_pos_in_physical_unit , & vv_sketch % title , & font_size_in_pixel = 3 0.0 , & text_anchor = 'middle' ) ! --<simple text in the footer>-- text_v_pos_in_physical_unit = ll % v - tsep call vv_sketch % text ( ll % u , & text_v_pos_in_physical_unit , & trim ( filename ), & font_size_in_pixel = 1 5.0 , & text_anchor = 'start' ) text_v_pos_in_physical_unit = text_v_pos_in_physical_unit - tsep call vv_sketch % text ( ll % u , & text_v_pos_in_physical_unit , & message , & font_size_in_pixel = 1 5.0 , & text_anchor = 'start' ) call vv_sketch % group_pop end subroutine iText_in_header_and_footer end subroutine draw_contour subroutine draw_arrows ( ll , ur , filename , vector ) type ( vv_sketch__sim_pos_t ), intent ( in ) :: ll , & ! lower left ur ! upper right character ( len =* ), intent ( in ) :: filename type ( vv_slice_vector_t ), intent ( inout ) :: vector real :: vec_amp_max type ( vv_sketch_t ) :: vv_sketch type ( vv_color_t ) :: color_black type ( vv_color_t ) :: color_limegreen , color_darkgreen character ( len = TAG_NAME_MAX ) :: message real , parameter :: ALMOST_ZERO = 1.e-20_SR color_black = VV_COLOR__CONST % black color_limegreen = VV_COLOR__CONST % limegreen color_darkgreen = VV_COLOR__CONST % darkgreen call vv_sketch % initialize ( ll , ur , & screen_width_in_pixel = 100 0.0 , & title = vector % tag , & filename = trim ( filename ), & unit_arrow_in_pixel = 2 0.0 , & write_arrow_template = . true . ) ! --<boundary curve>-- call vector % mesh % draw ( vv_sketch , & line_color = VV_COLOR__CONST % black , & width_in_pixels = 1.0 ) vec_amp_max = sqrt ( maxval ( vector % comp_u (:,:) ** 2 & + vector % comp_v (:,:) ** 2 )) message = vec_amp_max_string ( vec_amp_max ) call iText_in_header_and_footer ( message ) if ( vec_amp_max <= ALMOST_ZERO ) then call vv_sketch % finalize return end if call vv_sketch % group_push ( line_color = color_limegreen , & fill_color = color_darkgreen , & line_width_in_pixel = 1.0 ) vector % comp_u (:,:) = vector % comp_u (:,:) / vec_amp_max vector % comp_v (:,:) = vector % comp_v (:,:) / vec_amp_max call vector % vis_arrows ( vv_sketch , arrow_template = \"#arrow02\" ) call vv_sketch % group_pop call vv_sketch % finalize contains subroutine iText_in_header_and_footer ( message ) character ( len = TAG_NAME_MAX ), intent ( in ) :: message real :: text_v_pos_in_physical_unit real :: tsep ! text v position separation betwen lines call vv_sketch % group_push ( line_color = color_black , & line_width_in_pixel = 1.0 ) tsep = ( ur % v - ll % v ) * 0.1 ! --<figure title in the header>-- text_v_pos_in_physical_unit = ur % v + tsep call vv_sketch % text ( ( ll % u + ur % u ) / 2 , & text_v_pos_in_physical_unit , & vv_sketch % title , & font_size_in_pixel = 3 0.0 , & text_anchor = 'middle' ) ! --<simple text in the footer>-- text_v_pos_in_physical_unit = ll % v - tsep call vv_sketch % text ( ll % u , & text_v_pos_in_physical_unit , & trim ( filename ), & font_size_in_pixel = 1 5.0 , & text_anchor = 'start' ) text_v_pos_in_physical_unit = text_v_pos_in_physical_unit - tsep call vv_sketch % text ( ll % u , & text_v_pos_in_physical_unit , & message , & font_size_in_pixel = 1 5.0 , & text_anchor = 'start' ) call vv_sketch % group_pop end subroutine iText_in_header_and_footer end subroutine draw_arrows subroutine draw_contour_and_arrows ( ll , ur , filename , scalar , vector ) type ( vv_sketch__sim_pos_t ), intent ( in ) :: ll , & ! lower left ur ! upper right character ( len =* ), intent ( in ) :: filename type ( vv_slice_scalar_t ), intent ( inout ) :: scalar type ( vv_slice_vector_t ), intent ( inout ) :: vector real :: vec_amp_max type ( vv_sketch_t ) :: vv_sketch real :: level_min , level_max , dlevel , level , level_nrm real :: max_min_diff_normalized real :: level_range real :: level_amplitude type ( vv_color_t ) :: color , color_black type ( vv_color_t ) :: color_brown , color_sandybrown integer :: l character ( len = TAG_NAME_MAX ) :: message1 , message2 character ( len = TAG_NAME_MAX * 2 ) :: figure_title real , parameter :: ALMOST_ZERO = 1.e-20_SR real , parameter :: TOO_SMALL_DIFF_FOR_CONTOUR = 1.e-3_SR color_black = VV_COLOR__CONST % black color_brown = VV_COLOR__CONST % brown color_sandybrown = VV_COLOR__CONST % sandybrown figure_title = trim ( scalar % tag ) // ' (contour) and ' // & trim ( vector % tag ) // ' (arrows)' call vv_sketch % initialize ( ll , ur , & screen_width_in_pixel = 100 0.0 , & title = figure_title , & filename = trim ( filename ), & unit_arrow_in_pixel = 2 0.0 , & write_arrow_template = . true . ) ! --<boundary curve>-- call scalar % mesh % draw ( vv_sketch , & line_color = VV_COLOR__CONST % black , & width_in_pixels = 1.0 ) level_min = minval ( scalar % val_vert ) level_max = maxval ( scalar % val_vert ) message1 = min_max_string ( level_min , level_max ) vec_amp_max = sqrt ( maxval ( vector % comp_u (:,:) ** 2 & + vector % comp_v (:,:) ** 2 )) message2 = vec_amp_max_string ( vec_amp_max ) call iText_in_header_and_footer ( message1 , message2 ) !!> !        Contours !!< level_amplitude = max ( abs ( level_max ), abs ( level_min )) if ( level_amplitude > ALMOST_ZERO ) then call vv_sketch % group_push ( line_color = color_black , & line_width_in_pixel = 1.0 ) level_range = level_max - level_min max_min_diff_normalized = level_range / level_amplitude if ( max_min_diff_normalized >= TOO_SMALL_DIFF_FOR_CONTOUR ) then dlevel = level_range / 10 do l = 1 , 10 level = level_min + dlevel * ( real ( l ) - 0.5 ) level_nrm = ( level - level_min ) / level_range color = vv_color__normalized_real_to_color ( level_nrm ) call scalar % vis_contour ( vv_sketch , & level , & line_color = color_black , & fill_color = color ) end do end if call vv_sketch % group_pop end if !!> !        Arrows !!< if ( vec_amp_max > ALMOST_ZERO ) then call vv_sketch % group_push ( line_color = color_brown , & fill_color = color_sandybrown , & line_width_in_pixel = 1.0 ) vector % comp_u (:,:) = vector % comp_u (:,:) / vec_amp_max vector % comp_v (:,:) = vector % comp_v (:,:) / vec_amp_max call vector % vis_arrows ( vv_sketch , arrow_template = \"#arrow02\" ) call vv_sketch % group_pop end if call vv_sketch % finalize contains subroutine iText_in_header_and_footer ( message1 , message2 ) character ( len = TAG_NAME_MAX ), intent ( in ) :: message1 , message2 real :: text_v_pos_in_physical_unit real :: tsep ! text v position separation betwen lines call vv_sketch % group_push ( line_color = color_black , & line_width_in_pixel = 1.0 ) tsep = ( ur % v - ll % v ) * 0.1 ! --<figure title in the header>-- text_v_pos_in_physical_unit = ur % v + tsep call vv_sketch % text ( ( ll % u + ur % u ) / 2 , & text_v_pos_in_physical_unit , & vv_sketch % title , & font_size_in_pixel = 3 0.0 , & text_anchor = 'middle' ) ! --<simple text in the footer>-- text_v_pos_in_physical_unit = ll % v - tsep call vv_sketch % text ( ll % u , & text_v_pos_in_physical_unit , & trim ( filename ), & font_size_in_pixel = 1 5.0 , & text_anchor = 'start' ) text_v_pos_in_physical_unit = text_v_pos_in_physical_unit - tsep call vv_sketch % text ( ll % u , & text_v_pos_in_physical_unit , & 'Contour: ' // trim ( message1 ), & font_size_in_pixel = 1 5.0 , & text_anchor = 'start' ) text_v_pos_in_physical_unit = text_v_pos_in_physical_unit - tsep call vv_sketch % text ( ll % u , & text_v_pos_in_physical_unit , & 'Arrow: ' // trim ( message2 ), & font_size_in_pixel = 1 5.0 , & text_anchor = 'start' ) call vv_sketch % group_pop end subroutine iText_in_header_and_footer end subroutine draw_contour_and_arrows subroutine vis2d__draw ( vis2d , t_double , nloop , fluid ) class ( vis2d_t ), intent ( inout ) :: vis2d real ( DR ) , intent ( in ) :: t_double integer , intent ( in ) :: nloop type ( fluid_t ) , intent ( in ) :: fluid real :: t integer :: ctr = 0 t = real ( t_double , SR ) call kutimer__start ( 'vis2  ' ) if ( mod ( ctr , 100 ) == 0 ) then call vis2d % set_data ( fluid ) !{vis2  }{set d} if ( Parallel % rank % me == 0 ) then call vis2d % z_upper % draw ( t , nloop ) call vis2d % z_middle % draw ( t , nloop ) !{vis2  }{   xy} !       call vis2d.z_lower.draw ( t, nloop ) !       call vis2d.y_upper.draw ( t, nloop ) !       call vis2d.y_middle.draw( t, nloop ) !       call vis2d.y_lower.draw ( t, nloop )    !{vis2  }{   xz} end if call mpiut__barrier ( Parallel % comm ) end if ; ctr = ctr + 1 call kutimer__end ( 'vis2  ' ) end subroutine vis2d__draw end module vis2d_m","tags":"","loc":"sourcefile/vis2d.f90.html"},{"title":"fluid.F90 – Smoke Ring","text":"< This file depends on sourcefile~~fluid.f90~~EfferentGraph sourcefile~fluid.f90 fluid.F90 sourcefile~constants.f90 constants.F90 sourcefile~fluid.f90->sourcefile~constants.f90 sourcefile~field.f90 field.F90 sourcefile~fluid.f90->sourcefile~field.f90 sourcefile~grid.f90 grid.F90 sourcefile~fluid.f90->sourcefile~grid.f90 sourcefile~parallel.f90 parallel.F90 sourcefile~fluid.f90->sourcefile~parallel.f90 sourcefile~field.f90->sourcefile~constants.f90 sourcefile~field.f90->sourcefile~grid.f90 sourcefile~field.f90->sourcefile~parallel.f90 sourcefile~grid.f90->sourcefile~constants.f90 sourcefile~grid.f90->sourcefile~parallel.f90 sourcefile~parallel.f90->sourcefile~constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~fluid.f90~~AfferentGraph sourcefile~fluid.f90 fluid.F90 sourcefile~main.f90 main.F90 sourcefile~main.f90->sourcefile~fluid.f90 sourcefile~solver.f90 solver.F90 sourcefile~main.f90->sourcefile~solver.f90 sourcefile~vis2d.f90 vis2d.F90 sourcefile~main.f90->sourcefile~vis2d.f90 sourcefile~solver.f90->sourcefile~fluid.f90 sourcefile~vis2d.f90->sourcefile~fluid.f90 sourcefile~vis2d.f90->sourcefile~solver.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Modules fluid_m Source Code fluid.F90 Source Code !!> !   author: Akira Kageyama !   date: 2023.05.05 ! !   流体場データ構造体 ! !   @note 配列演算を多用している。つまり一行で書かれている部分も !         実際は3重do loopで書かれような大量の演算をしているところが !         多い。このコードをOpenMP化する時には、そのような部分を !         3重do loopに展開して書き直す必要がある。 !!< module fluid_m use constants_m !! 定数定義 use field_m !! 3次元スカラー・ベクトル場 use grid_m !! 格子点 use mpiut_m !! MPI通信ユーティリティ use parallel_m !! 並列化 implicit none !! 暗黙の型宣言無効化。必須 public :: operator ( + ), & operator ( * ), & operator ( . energyintegral . ) public :: assignment ( = ) interface operator ( . energyintegral . ) !! 全エネルギーを計算（体積積分）する演算子 module procedure operator_energyintegral end interface type , public :: fluid_t !! このシミュレーションコードで最も大事な !! 変数（構造体）。流体の状態を保持する。 real ( DR ), dimension ( 0 : NXPP1 , 0 : NYPP1 , 0 : NZPP1 ) :: pressure !! 圧力場 real ( DR ), dimension ( 0 : NXPP1 , 0 : NYPP1 , 0 : NZPP1 ) :: density !! 質量密度場 type ( field__vector_t ) :: flux !! 質量フラックス !! 質量フラックス (flux) と速度場 (velocity_vector) !!    flux = density * velocity_vector !! という関係がある。速度場を基本変数にしても問題ない。 !! 単にこのシミュレーションで解く基本方程式 !! ナビエ・ストークス方程式）の基本変数をどちらで !! 表現するか、の違いである。 contains procedure :: set_boundary_condition => fluid__set_boundary_condition end type fluid_t !--- << Operators >> ---! interface operator ( + ) !! 流体構造体の全要素の足し算を+記号で書けるように定義 module procedure operator_fluid_add end interface interface operator ( * ) !! 流体構造体の全要素の整数・実数倍 module procedure operator_fluid_times_integer module procedure operator_integer_times_fluid module procedure operator_fluid_times_real module procedure operator_real_times_fluid end interface interface assignment ( = ) !!流体構造体に代入記号が使えるように定義 module procedure assignment_real_to_fluid end interface contains function operator_energyintegral ( a ) result ( ans ) !! 流体の運動エネルギーの体積積分 type ( fluid_t ), intent ( in ) :: a !! 流体場 real ( DR ) :: ans !! 全エネルギー !! 以下のエネルギー密度の式を全空間で体積積分する !! flow_energy = (1/2) * rho * vel&#94;2 = (1/2) * (massflux)&#94;2 / rho real ( DR ) :: dvol real ( DR ), dimension ( 0 : NXPP1 , 0 : NYPP1 , 0 : NZPP1 ) :: flux_sq ! sq は2乗(squared)を意味する dvol = ( grid % delta % x ) * ( grid % delta % y ) * ( grid % delta % z ) !! 現在のシュミレーションでは格子間隔はx, y, z それぞれに !! 一様であることを仮定している。つまりdx, dy, dzは空間位置に !! 依存せず一定である。 flux_sq = ( a % flux ) . dot . ( a % flux ) !! 質量フラックスの2乗を一時的な配列にセットする ans = 0.5_DR * sum ( flux_sq ( 1 : NXPP , 1 : NYPP , 1 : NZPP ) & / a % density ( 1 : NXPP , 1 : NYPP , 1 : NZPP ) & ) * dvol ! ここで配列演算の添字が1からNXではなく2からNX-1などに ! 限定されていることに注意。これは体積積分の範囲を計算領域の ! 内部に限定していること、つまり境界上の格子点を除いて ! 積分していることを意味する。境界上の格子点まで ! 入れると重複してカウントしてしまうからである end function operator_energyintegral subroutine assignment_real_to_fluid ( fluid , real ) !! 流体構造体に実数を代入。 !! 初期条件ですべての要素を0にセットするときに使う。 type ( fluid_t ), intent ( out ) :: fluid !! 流体場 real ( DR ), intent ( in ) :: real !! 代入する実数 fluid % pressure (:,:,:) = real fluid % density (:,:,:) = real fluid % flux % x (:,:,:) = real fluid % flux % y (:,:,:) = real fluid % flux % z (:,:,:) = real end subroutine assignment_real_to_fluid function operator_fluid_add ( a , b ) result ( ans ) !! 流体構造体の足し算演算子 type ( fluid_t ), intent ( in ) :: a , b !! 足し算する2つの流体場 type ( fluid_t ) :: ans !! 計算結果 ans % flux % x = a % flux % x + b % flux % x ans % flux % y = a % flux % y + b % flux % y ans % flux % z = a % flux % z + b % flux % z ans % density = a % density + b % density ans % pressure = a % pressure + b % pressure end function operator_fluid_add function operator_fluid_times_integer ( fluid , integer ) result ( ans ) !! 流体構造体を整数倍するための演算子 type ( fluid_t ), intent ( in ) :: fluid !! 流体場 integer , intent ( in ) :: integer !! かける整数 type ( fluid_t ) :: ans ans % pressure = integer * ( fluid % pressure ) ans % density = integer * ( fluid % density ) ans % flux % x = integer * ( fluid % flux % x ) ans % flux % y = integer * ( fluid % flux % y ) ans % flux % z = integer * ( fluid % flux % z ) end function operator_fluid_times_integer function operator_fluid_times_real ( fluid , real ) result ( ans ) !! 流体構造体を実数倍するための演算子 type ( fluid_t ), intent ( in ) :: fluid !! 流体場 real ( DR ), intent ( in ) :: real !! かける実数 type ( fluid_t ) :: ans !! 計算結果 ans % pressure = real * ( fluid % pressure ) ans % density = real * ( fluid % density ) ans % flux % x = real * ( fluid % flux % x ) ans % flux % y = real * ( fluid % flux % y ) ans % flux % z = real * ( fluid % flux % z ) end function operator_fluid_times_real function operator_integer_times_fluid ( integer , fluid ) result ( ans ) !! 整数に流体構造体を掛け算するための演算子 integer , intent ( in ) :: integer !! かける整数 type ( fluid_t ), intent ( in ) :: fluid !! 流体場 type ( fluid_t ) :: ans !! 計算結果 ans % pressure = integer * ( fluid % pressure ) ans % density = integer * ( fluid % density ) ans % flux % x = integer * ( fluid % flux % x ) ans % flux % y = integer * ( fluid % flux % y ) ans % flux % z = integer * ( fluid % flux % z ) end function operator_integer_times_fluid function operator_real_times_fluid ( real , fluid ) result ( ans ) !! 実数に流体場を掛ける演算子 real ( DR ), intent ( in ) :: real !! 掛ける実数 type ( fluid_t ), intent ( in ) :: fluid !! 流体場 type ( fluid_t ) :: ans !! 計算結果 ans % pressure = real * ( fluid % pressure ) ans % density = real * ( fluid % density ) ans % flux % x = real * ( fluid % flux % x ) ans % flux % y = real * ( fluid % flux % y ) ans % flux % z = real * ( fluid % flux % z ) end function operator_real_times_fluid subroutine fluid__set_boundary_condition ( fluid ) class ( fluid_t ), intent ( inout ) :: fluid !! 流体構造体の周期境界条件設定 call mpiut__exchange ( Parallel % comm , & Parallel % periodic_pair , & fluid % pressure , & fluid % density , & fluid % flux % x , & fluid % flux % y , & fluid % flux % z ) call mpiut__barrier ( Parallel % comm ) !! プロセス間通信で領域境界データを交換 call mpiut__exchange ( Parallel % comm , & Parallel % rank % next , & fluid % pressure , & fluid % density , & fluid % flux % x , & fluid % flux % y , & fluid % flux % z ) call mpiut__barrier ( Parallel % comm ) end subroutine fluid__set_boundary_condition end module fluid_m","tags":"","loc":"sourcefile/fluid.f90.html"},{"title":"job.F90 – Smoke Ring","text":"< This file depends on sourcefile~~job.f90~~EfferentGraph sourcefile~job.f90 job.F90 sourcefile~constants.f90 constants.F90 sourcefile~job.f90->sourcefile~constants.f90 sourcefile~parallel.f90 parallel.F90 sourcefile~job.f90->sourcefile~parallel.f90 sourcefile~parallel.f90->sourcefile~constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~job.f90~~AfferentGraph sourcefile~job.f90 job.F90 sourcefile~main.f90 main.F90 sourcefile~main.f90->sourcefile~job.f90 sourcefile~solver.f90 solver.F90 sourcefile~main.f90->sourcefile~solver.f90 sourcefile~vis2d.f90 vis2d.F90 sourcefile~main.f90->sourcefile~vis2d.f90 sourcefile~solver.f90->sourcefile~job.f90 sourcefile~vis2d.f90->sourcefile~solver.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Modules job_m Source Code job.F90 Source Code !!> !   author: Akira Kageyama !   date: 2023.05.05 ! !   シミュレーションジョブの制御 ! !   @note !      配列演算を多用している。つまり一行で書かれている部分も !      実際は3重do loopで書かれような大量の演算をしているところが !      多い。このコードをOpenMP化する時には、そのような部分を !      3重do loopに展開して書き直す必要がある。 !!< module job_m use constants_m !! 定数定義 use ut_m !! ユーティリティ use parallel_m !! MPI並列化 implicit none !! 暗黙の型宣言無効化。必須 private !! このモジュール内の変数・ルーチン等はデフォルトで非公開 type :: job_t character ( len = 20 ) :: karte = \"fine\" ! カルテ。初期は「健康」 contains procedure , nopass :: initialize => job__initialize procedure , nopass :: finalize => job__finalize end type job_t type ( job_t ), public :: Job contains subroutine job__initialize call Parallel % initialize !! MPI並列化初期化処理。Parallel変数はparallel.efで定義 !! されている。冒頭のPが大文字なのはこれがグローバル変数 !! であることを示唆している。（コンパイラは大文字と小文字を !! 区別しないが。） end subroutine job__initialize subroutine job__finalize ( nloop ) integer , intent ( in ) :: nloop !! ループカウンタ !! ジョブ終了時の後始末。 !! (1) 健康状態カルテに応じたメッセージを標準出力に書く !! (2) MPI並列化の終了処理 select case ( trim ( job % karte )) case ( \"fine\" , \"loop_max\" ) !! このどちらかであれば、 call ut__deco_message ( \"#\" , \"Successfully finished.\" ) !! # で第2引数の文字列を囲む。 case ( \"time out\" ) call ut__deco_message ( \"-\" , \"Time out at nloop = \" , nloop ) case ( \"overflow\" ) call ut__deco_message ( \"%\" , \"Overflow at nloop = \" , nloop ) case ( \"negative anormaly\" ) call ut__deco_message ( \"%\" , \"Underflow at nloop = \" , nloop ) case default call ut__deco_message ( \"?\" , \"Stopped at nloop = \" , nloop ) end select call Parallel % finalize !! MPI並列化終了処理 end subroutine job__finalize end module job_m","tags":"","loc":"sourcefile/job.f90.html"},{"title":"parallel.F90 – Smoke Ring","text":"< This file depends on sourcefile~~parallel.f90~~EfferentGraph sourcefile~parallel.f90 parallel.F90 sourcefile~constants.f90 constants.F90 sourcefile~parallel.f90->sourcefile~constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~parallel.f90~~AfferentGraph sourcefile~parallel.f90 parallel.F90 sourcefile~field.f90 field.F90 sourcefile~field.f90->sourcefile~parallel.f90 sourcefile~grid.f90 grid.F90 sourcefile~field.f90->sourcefile~grid.f90 sourcefile~fluid.f90 fluid.F90 sourcefile~fluid.f90->sourcefile~parallel.f90 sourcefile~fluid.f90->sourcefile~field.f90 sourcefile~fluid.f90->sourcefile~grid.f90 sourcefile~grid.f90->sourcefile~parallel.f90 sourcefile~job.f90 job.F90 sourcefile~job.f90->sourcefile~parallel.f90 sourcefile~main.f90 main.F90 sourcefile~main.f90->sourcefile~parallel.f90 sourcefile~main.f90->sourcefile~field.f90 sourcefile~main.f90->sourcefile~fluid.f90 sourcefile~main.f90->sourcefile~grid.f90 sourcefile~main.f90->sourcefile~job.f90 sourcefile~solver.f90 solver.F90 sourcefile~main.f90->sourcefile~solver.f90 sourcefile~vis2d.f90 vis2d.F90 sourcefile~main.f90->sourcefile~vis2d.f90 sourcefile~solver.f90->sourcefile~parallel.f90 sourcefile~solver.f90->sourcefile~field.f90 sourcefile~solver.f90->sourcefile~fluid.f90 sourcefile~solver.f90->sourcefile~grid.f90 sourcefile~solver.f90->sourcefile~job.f90 sourcefile~vis2d.f90->sourcefile~parallel.f90 sourcefile~vis2d.f90->sourcefile~field.f90 sourcefile~vis2d.f90->sourcefile~fluid.f90 sourcefile~vis2d.f90->sourcefile~grid.f90 sourcefile~vis2d.f90->sourcefile~solver.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Modules parallel_m Source Code parallel.F90 Source Code !!> !  parallel.f !    * MPI process parallelization ! !  History !    2023.05.01: Copied from tetra_dynamo project. !!< module parallel_m use constants_m use mpi use mpiut_m use ut_m implicit none private type , private :: rank_t integer :: me ! Rank number of myself. type ( mpiut__rank_next_t ) :: next ! Neighbor ranks. end type rank_t type , private :: pos_t type ( mpiut__rank_position_t ) :: index character ( len = 12 ) :: string ! e.g., \"p012_035_064\" end type pos_t type , private :: parallel_t integer :: nprocs integer :: comm type ( rank_t ) :: rank type ( pos_t ) :: pos type ( mpiut__rank_next_t ) :: periodic_pair logical :: i_have_xmax logical :: i_have_xmin logical :: i_have_ymax logical :: i_have_ymin logical :: i_have_zmax logical :: i_have_zmin contains procedure , nopass :: initialize => parallel__initialize procedure , nopass :: finalize => parallel__finalize procedure , nopass :: io_clerk => parallel__io_clerk procedure , nopass :: rank_to_pos_index & => parallel__rank_to_pos_index end type parallel_t type ( parallel_t ), public :: Parallel contains function calc_rank_next ( me ) result ( next ) type ( mpiut__rank_position_t ), intent ( in ) :: me type ( mpiut__rank_next_t ) :: next integer :: i , j , k i = me % i j = me % j k = me % k next % ip1 = pos_ijk_to_rank ( i + 1 , j , k ) next % im1 = pos_ijk_to_rank ( i - 1 , j , k ) next % jp1 = pos_ijk_to_rank ( i , j + 1 , k ) next % jm1 = pos_ijk_to_rank ( i , j - 1 , k ) next % kp1 = pos_ijk_to_rank ( i , j , k + 1 ) next % km1 = pos_ijk_to_rank ( i , j , k - 1 ) end function calc_rank_next function pos_ijk_to_rank ( i , j , k ) integer , intent ( in ) :: i , j , k integer :: pos_ijk_to_rank !!> !       Purpose: Returns rank number for the divided region at i,j,k. !        Author: Akira Kageyama !          Date: 2013.06.13 (revised) !!< if ( i < 0 . or . i >= NPROC_X & . or . & j < 0 . or . j >= NPROC_Y & . or . & k < 0 . or . k >= NPROC_Z ) then pos_ijk_to_rank = MPI_PROC_NULL else pos_ijk_to_rank = i + j * NPROC_X + k * NPROC_X * NPROC_Y end if end function pos_ijk_to_rank subroutine parallel__initialize !!> !    The following is the process allocation map. We do !    not use the automatic allocation by MPI_Carte_create. ! !               /     /     /     /     /| !              /  12 / 13  / 14  / 15  / | !             /-----/-----/-----/-----/  |           k !            /     /     /     /     /|  /          / !           /     /     /     /     / | /|         / !          +-----+-----+-----+-----+  |/ |        +------ i !    N     |     |     |     |     |  /  |        | !    P     |  0  |  1  |  2  |  3  | /|  /        | !    R     |     |     |     |     |/ | /|        | !    O = 3 +-----+-----+-----+-----+  |/ |        | !    C     |     |     |     |     |  /  |         j !          |  4  |  5  |  6  |  7  | /|  / !    Y     |     |     |     |     |/ | / !          +-----+-----+-----+-----+  |/ !          |     |     |     |     |  / !          |  8  |  9  | 10  | 11  | / !          |     |     |     |     |/pos.index.k = rank / (mx*my) !          +-----+-----+-----+-----+ pos.index.j = mod(rank,mx*my)/mx !                                    pos.index.i = mod(rank,mx) !                  NPROC_X = 4 !!< integer :: me , nprocs , comm call mpiut__init ! No OpenMP ! call mpiut__init( MPI_THREAD_MULTIPLE ) comm = MPI_COMM_WORLD me = mpiut__comm_rank ( comm ) nprocs = mpiut__comm_size ( comm ) call mpiut__assert ( nprocs == NPROC_X * NPROC_Y * NPROC_Z , & 'parallel_m/parallel__initialize: nprocs inconsistent.' ) Parallel % comm = comm Parallel % nprocs = nprocs Parallel % rank % me = me Parallel % pos % index = Parallel % rank_to_pos_index ( me ) Parallel % rank % next = calc_rank_next ( Parallel % pos % index ) ! Sample: \"p012_035_064\" Parallel % pos % string = \"p\" & ! 1 letter // ut__i2c3 ( Parallel % pos % index % i ) & ! 3 letters // '_' & ! 1 letter // ut__i2c3 ( Parallel % pos % index % j ) & ! 3 letters // '_' & ! 1 letter // ut__i2c3 ( Parallel % pos % index % k ) ! 3 letters associate ( periodic_pair => Parallel % periodic_pair , & pos_index => Parallel % pos % index , & have_xmax => Parallel % i_have_xmax , & have_xmin => Parallel % i_have_xmin , & have_ymax => Parallel % i_have_ymax , & have_ymin => Parallel % i_have_ymin , & have_zmax => Parallel % i_have_zmax , & have_zmin => Parallel % i_have_zmin ) periodic_pair % ip1 = MPI_PROC_NULL ! Default values. periodic_pair % im1 = MPI_PROC_NULL ! These will be periodic_pair % jp1 = MPI_PROC_NULL ! overwritten. periodic_pair % jm1 = MPI_PROC_NULL periodic_pair % kp1 = MPI_PROC_NULL periodic_pair % km1 = MPI_PROC_NULL have_xmax = . false . ! Default values. have_xmin = . false . ! These will be have_ymax = . false . ! overwritten. have_ymin = . false . have_zmax = . false . have_zmin = . false . if ( pos_index % i == NPROC_X - 1 ) have_xmax = . true . if ( pos_index % i == 0 ) have_xmin = . true . if ( pos_index % j == NPROC_Y - 1 ) have_ymax = . true . if ( pos_index % j == 0 ) have_ymin = . true . if ( pos_index % k == NPROC_Z - 1 ) have_zmax = . true . if ( pos_index % k == 0 ) have_zmin = . true . if ( have_xmax ) periodic_pair % ip1 = me - NPROC_X + 1 if ( have_xmin ) periodic_pair % im1 = me + NPROC_X - 1 if ( have_ymax ) periodic_pair % jp1 = me - NPROC_X * ( NPROC_Y - 1 ) if ( have_ymin ) periodic_pair % jm1 = me + NPROC_X * ( NPROC_Y - 1 ) if ( have_zmax ) periodic_pair % kp1 = me - NPROC_X * NPROC_Y * ( NPROC_Z - 1 ) if ( have_zmin ) periodic_pair % km1 = me + NPROC_X * NPROC_Y * ( NPROC_Z - 1 ) end associate call iPrint call mpiut__barrier ( comm ) contains subroutine iPrint call mpiut__message_leader ( comm , & 'parallel_m: comm' , & Parallel % comm ) call mpiut__message_leader ( comm , & 'parallel_m: nprocs' , & Parallel % nprocs ) call mpiut__message_leader ( comm , & 'parallel_m: rank.me' , & Parallel % rank % me ) call mpiut__message_leader ( comm , & 'parallel_m: pos.index.i' , & Parallel % pos % index % i ) call mpiut__message_leader ( comm , & 'parallel_m: pos.index.j' , & Parallel % pos % index % j ) call mpiut__message_leader ( comm , & 'parallel_m: pos.index.k' , & Parallel % pos % index % k ) call mpiut__message_leader ( comm , & 'parallel_m: pos.string' , & Parallel % pos % string ) call mpiut__message_leader ( comm , & 'parallel_m: rank.next.ip1' , & Parallel % rank % next % ip1 ) call mpiut__message_leader ( comm , & 'parallel_m: rank.next.im1' , & Parallel % rank % next % im1 ) call mpiut__message_leader ( comm , & 'parallel_m: rank.next.jp1' , & Parallel % rank % next % jp1 ) call mpiut__message_leader ( comm , & 'parallel_m: rank.next.jm1' , & Parallel % rank % next % jm1 ) call mpiut__message_leader ( comm , & 'parallel_m: rank.next.kp1' , & Parallel % rank % next % kp1 ) call mpiut__message_leader ( comm , & 'parallel_m: rank.next.km1' , & Parallel % rank % next % km1 ) call mpiut__message_leader ( comm , & 'parallel_m: have_xmax' , & Parallel % i_have_xmax ) call mpiut__message_leader ( comm , & 'parallel_m: have_xmin' , & Parallel % i_have_xmin ) call mpiut__message_leader ( comm , & 'parallel_m: have_ymax' , & Parallel % i_have_ymax ) call mpiut__message_leader ( comm , & 'parallel_m: have_ymin' , & Parallel % i_have_ymin ) call mpiut__message_leader ( comm , & 'parallel_m: have_zmax' , & Parallel % i_have_zmax ) call mpiut__message_leader ( comm , & 'parallel_m: have_zmin' , & Parallel % i_have_zmin ) call mpiut__message_leader ( comm , & 'parallel_m: periodic_pair.ip1' , & Parallel % periodic_pair % ip1 ) call mpiut__message_leader ( comm , & 'parallel_m: periodic_pair.im1' , & Parallel % periodic_pair % im1 ) call mpiut__message_leader ( comm , & 'parallel_m: periodic_pair.jp1' , & Parallel % periodic_pair % jp1 ) call mpiut__message_leader ( comm , & 'parallel_m: periodic_pair.jm1' , & Parallel % periodic_pair % jm1 ) call mpiut__message_leader ( comm , & 'parallel_m: periodic_pair.kp1' , & Parallel % periodic_pair % kp1 ) call mpiut__message_leader ( comm , & 'parallel_m: periodic_pair.km1' , & Parallel % periodic_pair % km1 ) end subroutine iPrint end subroutine parallel__initialize subroutine parallel__finalize call mpiut__finalize end subroutine parallel__finalize function parallel__io_clerk ( task ) result ( i_am ) character ( len =* ), intent ( in ), optional :: task logical :: i_am !!> !        Returns the rank number who is in charge of data io. !        We assign different processes for different data, to !        avoid the IO conflicts. You will not need this function !        in future when the parallel IO of MPI2 is implemented !        in this code. This is just for a temporary use till then. !!< integer :: target_rank integer :: nprocs nprocs = Parallel % nprocs if ( . not . present ( task ) ) then target_rank = 0 else select case ( task ) case ( '2d_slice_xy' ) target_rank = mod ( 0 , nprocs ) case ( '2d_slice_yz' ) target_rank = mod ( 1 , nprocs ) case ( '2d_slice_zx' ) target_rank = mod ( 2 , nprocs ) case ( '2d_slice_xy2' ) target_rank = mod ( 3 , nprocs ) case ( '2d_slice_xy3' ) target_rank = mod ( 4 , nprocs ) case ( 'heavy data' ) target_rank = Parallel % nprocs - 1 case default target_rank = 0 end select end if i_am = ( target_rank == Parallel % rank % me ) end function parallel__io_clerk function parallel__rank_to_pos_index ( rank ) result ( index ) integer , intent ( in ) :: rank type ( mpiut__rank_position_t ) :: index !!> !        Returns the process position (i,j,k) for the rank. !!< call mpiut__assert ( rank >= 0 , & 'parallel_m/parallel__rank_to_pos_index: negative rank.' ) call mpiut__assert ( rank < NPROC_X * NPROC_Y * NPROC_Z , & 'parallel_m/parallel__rank_to_pos_index: rank out of range.' ) index % k = rank / ( NPROC_X * NPROC_Y ) index % j = mod ( rank , NPROC_X * NPROC_Y ) / NPROC_X index % i = mod ( rank , NPROC_X ) end function parallel__rank_to_pos_index end module parallel_m","tags":"","loc":"sourcefile/parallel.f90.html"},{"title":"params.F90 – Smoke Ring","text":"< This file depends on sourcefile~~params.f90~~EfferentGraph sourcefile~params.f90 params.F90 sourcefile~constants.f90 constants.F90 sourcefile~params.f90->sourcefile~constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~params.f90~~AfferentGraph sourcefile~params.f90 params.F90 sourcefile~main.f90 main.F90 sourcefile~main.f90->sourcefile~params.f90 sourcefile~solver.f90 solver.F90 sourcefile~main.f90->sourcefile~solver.f90 sourcefile~vis2d.f90 vis2d.F90 sourcefile~main.f90->sourcefile~vis2d.f90 sourcefile~solver.f90->sourcefile~params.f90 sourcefile~vis2d.f90->sourcefile~solver.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Modules params_m Source Code params.F90 Source Code !!> !   author: Akira Kageyama !   date: 2023.05.05 ! !   シミュレーションパラメータ ! !   @note !      パラメーターはnamelistを使ってファイルから読み込む ! !   @note !      先頭一文字だけが大文字になっている変数例えば Read_done などは !      このモジュールを名前空間とする変数を意味する。つまりモジュール !      外からはアクセスできないがモジュール内のルーチン関数からは !      アクセスできるものである。 !      このようにスコープの広い変数を乱用するとバグの温床になるが !      この程度の小さなプログラムであれば問題ないであろう。 ! !   @note !      ファイル番号10番をparams__readで使っている。 ! !   @note !     namelistファイルの内容を変更する場合は: !       (1) このファイルの少し下の行にあるnamelist文を書き換える。 !       (2) params__readを書き換える。 !       (3) namelist__get_double, _integer等の対応する行も書き換える。 ! !   @note !     namelist文中のスラッシュで囲まれた名称（たとえば/simulation/） !     や、namelist変数名（たとえばTotal_nloop）はnamelistファイル !     の中での記述と対応していなければいけない。 !!< module params_m use constants_m ! 定数定義 use ut_m ! ユーティリティ use iso_fortran_env , only : output_unit implicit none ! 暗黙の型宣言無効化。必須 private ! このモジュール内の変数・ルーチン等はデフォルトで非公開 logical , save :: Read_done = . false . ! 読み込みが済んだか否か integer , parameter :: STRING_LENGTH_MAX = 200 ! 文字列長 ! 足りなくなったら大きくする。 integer :: Total_nloop ! 一度のジョブで計算するループ回数 integer :: Slicedata_nskip ! 何ステップ毎に断面データを書き出すか character ( len = STRING_LENGTH_MAX ) :: Slicedata_tag ! 断面データファイル名用 real ( DR ) :: Viscosity , Kappa ! 粘性率と熱拡散率 namelist / simulation / Total_nloop namelist / visualization / Slicedata_nskip , & Slicedata_tag namelist / fluid_property / Viscosity , & Kappa type :: params_t contains procedure , nopass :: read => params__read procedure , nopass :: get_double => params__get_double procedure , nopass :: get_integer => params__get_integer procedure , nopass :: get_logical => params__get_logical procedure , nopass :: get_string => params__get_string end type params_t type ( params_t ), public :: Params contains function params__get_double ( variable ) character ( len =* ), intent ( in ) :: variable !! 問い合わせ変数の名前 real ( DR ) :: params__get_double !! その値 !! このモジュールの外からの問い合わせに応じてnamelistデータを返す。 !! この関数は問い合わせ変数が倍精度浮動小数点数の場合。 !! この関数の前にnamelist__readが呼ばれている必要がある。 !! この点はassertで確認している。 call ut__assert ( Read_done , & 'params_m(__LINE):  Read params file first.' ) select case ( variable ) case ( 'Kappa' ) ! 熱拡散率 params__get_double = Kappa case ( 'Viscosity' ) ! 粘性率 params__get_double = Viscosity case default ! そんなnamelist変数は想定外 call ut__message ( '? arg = ' , variable ) call ut__fatal ( 'params_m(90): case error.' ) end select end function params__get_double function params__get_integer ( variable ) character ( len =* ), intent ( in ) :: variable !! 問い合わせ変数の名前 integer :: params__get_integer !! その値 !! このモジュールの外からの問い合わせに応じてnamelistデータを返す。 !! この関数は問い合わせ変数が整数の場合。 !! この関数の前にnamelist__readが呼ばれている必要がある。 !! この点はassertで確認している。 call ut__assert ( Read_done , & 'params_m(104): Read params file first.' ) select case ( variable ) case ( 'Slicedata_nskip' ) ! 何ステップごとに params__get_integer = Slicedata_nskip ! 断面をディスクに書き出すか case ( 'Total_nloop' ) ! シミュレーションジョブ params__get_integer = Total_nloop ! の実行最大ループ数 case default ! 想定外 call ut__message ( '? arg = ' , variable ) call ut__fatal ( 'params_m(113): case error.' ) end select end function params__get_integer function params__get_logical ( variable ) character ( len =* ), intent ( in ) :: variable !! 問い合わせ変数の名前 logical :: params__get_logical !! その値 !! このモジュールの外からの問い合わせに応じてnamelistデータを返す。 !! この関数は問い合わせ変数が論理値の場合。 !! この関数の前にnamelist__readが呼ばれている必要がある。 !! この点はassertで確認している。 call ut__assert ( Read_done , & 'params_m(127): Read params file first.' ) select case ( variable ) case default ! 想定外 call ut__message ( '? arg = ' , variable ) call ut__fatal ( 'params_m(132): case error.' ) end select end function params__get_logical subroutine params__read !! namelistファイルをディスクから読み込む。 !! ファイル名はコマンド第一引数。 !! !! namelistデータファイルの内容を変更する場合は !! 以下のread文も適宜変更する。 !! character ( len = STRING_LENGTH_MAX ) :: params_file integer :: file_unit call ut__assert ( command_argument_count () == 1 , & \"params_m(148): Usage: smoke_ring param_file\" ) call get_command_argument ( 1 , params_file ) !*******<params_file のサンプル>********* ! &simulation      Total_nloop = 2000 / ! &visualization   Slicedata_nskip  = 100, Slicedata_tag = '_data_slice' / ! &fluid_property  Viscosity = 3.0e-2, Kappa = 3.e-2 / !*******</params_file のサンプル>********* open ( newunit = file_unit , file = trim ( params_file )) read ( file_unit , nml = simulation ) read ( file_unit , nml = visualization ) read ( file_unit , nml = fluid_property ) close ( file_unit ) write ( output_unit , nml = simulation ) write ( output_unit , nml = visualization ) write ( output_unit , nml = fluid_property ) Read_done = . true . end subroutine params__read function params__get_string ( variable ) character ( len =* ), intent ( in ) :: variable !! 問い合わせ変数の名前 character ( len = STRING_LENGTH_MAX ) :: params__get_string !! その値 !! このモジュールの外からの問い合わせに応じてnamelistデータを返す。 !! この関数は問い合わせ変数が文字列の場合。 !! この関数の前にnamelist__readが呼ばれている必要がある。 !! この点はassertで確認している。 call ut__assert ( Read_done , & 'params_m(180): Read params file first.' ) select case ( variable ) case ( 'Slicedata_tag' ) ! 断面ファイル名に使う params__get_string = Slicedata_tag case default call ut__message ( '? arg = ' , variable ) ! 想定外 call ut__fatal ( 'params_m(187): case error.' ) end select end function params__get_string end module params_m","tags":"","loc":"sourcefile/params.f90.html"},{"title":"main.F90 – Smoke Ring","text":"< This file depends on sourcefile~~main.f90~~EfferentGraph sourcefile~main.f90 main.F90 sourcefile~constants.f90 constants.F90 sourcefile~main.f90->sourcefile~constants.f90 sourcefile~field.f90 field.F90 sourcefile~main.f90->sourcefile~field.f90 sourcefile~fluid.f90 fluid.F90 sourcefile~main.f90->sourcefile~fluid.f90 sourcefile~grid.f90 grid.F90 sourcefile~main.f90->sourcefile~grid.f90 sourcefile~job.f90 job.F90 sourcefile~main.f90->sourcefile~job.f90 sourcefile~parallel.f90 parallel.F90 sourcefile~main.f90->sourcefile~parallel.f90 sourcefile~params.f90 params.F90 sourcefile~main.f90->sourcefile~params.f90 sourcefile~solver.f90 solver.F90 sourcefile~main.f90->sourcefile~solver.f90 sourcefile~vis2d.f90 vis2d.F90 sourcefile~main.f90->sourcefile~vis2d.f90 sourcefile~field.f90->sourcefile~constants.f90 sourcefile~field.f90->sourcefile~grid.f90 sourcefile~field.f90->sourcefile~parallel.f90 sourcefile~fluid.f90->sourcefile~constants.f90 sourcefile~fluid.f90->sourcefile~field.f90 sourcefile~fluid.f90->sourcefile~grid.f90 sourcefile~fluid.f90->sourcefile~parallel.f90 sourcefile~grid.f90->sourcefile~constants.f90 sourcefile~grid.f90->sourcefile~parallel.f90 sourcefile~job.f90->sourcefile~constants.f90 sourcefile~job.f90->sourcefile~parallel.f90 sourcefile~parallel.f90->sourcefile~constants.f90 sourcefile~params.f90->sourcefile~constants.f90 sourcefile~solver.f90->sourcefile~constants.f90 sourcefile~solver.f90->sourcefile~field.f90 sourcefile~solver.f90->sourcefile~fluid.f90 sourcefile~solver.f90->sourcefile~grid.f90 sourcefile~solver.f90->sourcefile~job.f90 sourcefile~solver.f90->sourcefile~parallel.f90 sourcefile~solver.f90->sourcefile~params.f90 sourcefile~vis2d.f90->sourcefile~constants.f90 sourcefile~vis2d.f90->sourcefile~field.f90 sourcefile~vis2d.f90->sourcefile~fluid.f90 sourcefile~vis2d.f90->sourcefile~grid.f90 sourcefile~vis2d.f90->sourcefile~parallel.f90 sourcefile~vis2d.f90->sourcefile~solver.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Programs main_m Source Code main.F90 Source Code !!> !   author: Akira Kageyama !   date: 2023.05.05 ! !   渦輪 (smoke ring) の形成シミュレーション ! !   神戸大学情報知能工学科の講義 \"HPC\" （B3対象）用サンプルコード ! !   ### 形状 !     直方体領域。3次元周期境界条件。カーテシアン座標。 ! !   ### 計算手法 !     空間離散化は2次中心差分法。時間積分は4次ルンゲ・クッタ法。 ! !   ### 実行方法 !     (1) cd src !     (2) make !     (3) cd ../slice_grapher !     (4) make !!< program main_m use constants_m !! 定数 use field_m !! スカラー場・ベクトル場 use fluid_m !! 流体場の構造体定義 use grid_m !! 格子点情報 use job_m !! ジョブ管理 use kutimer_m !! 時間測定モジュール ;call kutimer__('main  ','sample') use mpiut_m !! mpi関係ユーティリティ use parallel_m !! MPI並列化 use params_m !! パラメータ use solver_m !! ナビエ・ストークス方程式ソルバ use ut_m !! ユーティリティ use vis2d_m !! 断面可視化 implicit none !! 暗黙の型宣言無効化。必須 integer :: nloop ! シミュレーションのループカウンタ real ( DR ) :: dt , time ! 時間刻み幅と時刻 type ( fluid_t ) :: fluid ! 流体場データの構造体 type ( vis2d_t ) :: vis2d call kutimer__start ( 'main  ' ) call Params % read ; call kutimer__ ( 'main  ' , 'params' ) !! パラメーターの読み込み。paramsの後に続くアンダースコア !! 二つは、これがparamsモジュールの中にあるサブルーチンの !! 呼び出しであることを意味している。paramsモジュールの !! 名前はparams_mである。params_mはparams.f90にある。 call Job % initialize ; call kutimer__ ( 'main  ' , 'job  i' ) !! シミュレーションジョブの初期化 !! されている。冒頭のPが大文字なのはこれがグローバル変数 !! であることを示唆している。（コンパイラは大文字と小文字を !! 区別しないが。） call Grid % initialize ; call kutimer__ ( 'main  ' , 'grid i' ) !! gridモジュールの初期化。 !! パーセント記号はメンバアクセス演算子。 !! ここでは構造体のメンバー関数の呼び出しをしている。 !! gridモジュール（grid_m）はgrid.f90で定義されている。 call Solver % initialize ( fluid ) ; call kutimer__ ( 'main  ' , 'solv i' ) !! solverジュール（solver_m）の初期化。 call vis2d % initialize ; call kutimer__ ( 'main  ' , 'vis  i' ) !! 可視化モジュール（vis2d_m）の初期化。 time = 0.0_DR !! 時刻の初期化。単位は秒。 nloop = 0 !! ループカウンタの初期化。 call vis2d % draw ( time , nloop , fluid ) !! このモジュールはシミュレーション領域の断面図をSVGで出力する。 call Solver % diagnosis ( nloop , time , fluid ) ; call kutimer__ ( 'main  ' , 'solv d' ) !! solverモジュールで定義されているdiagnosis（診断） !! サブルーチンを呼び出す。医者が患者を診るのがdiagnosis !! である。そこでの診断結果はJob.carte !! にセットする。carteはカルテである。 dt = Solver % set_time_step ( nloop , fluid ) ; call kutimer__ ( 'main  ' , 'set dt' ) !! 時間刻み幅 dt の決定。dtはCFL条件を満足するように決めるが、 !! CFL条件は流体の状態に流体の状態に依存して変化する。 !! たとえば、流体の一部が高温になると、そこでの音速が速くなり、 !! 音速によって決まるCFL条件が厳しくなる（つまりdtが小さくなる） !! ここでは初期状態における流体の状態に基づいてdtが決まる do while ( Job % karte == \"fine\" ) ; call kutimer__count !! このシミュレーションのメインループである。ジョブカルテが !! 「健康 (fine)」状態である限りシミュレーションを続行する。 call Solver % advance ( time , dt , fluid ) ; call kutimer__ ( 'main  ' , 'solv a' ) !! ナビエ・ストークス方程式に基づいて流体 (fluid) の状態を !! 一時刻ステップ dt だけ進める。 dt = Solver % set_time_step ( nloop , fluid ) ; call kutimer__ ( 'main  ' , 'set dt' ) !! 流体の状態が変わったのでCFL条件に基づき時間刻み幅dt !! を設定し直す。 !! 厳密に言えば毎ステップこの再設定をしているわけではなく、 !! このsolver__set_time_stepルーチンの冒頭で判断し、 !! 数十ステップに一度だけ実際には変更を行うようなskip操作 !! をしている。CFL条件に基づいた計算は時間がかかるが、 !! 毎ステップdtを精密に調整する必要はないからである。 nloop = nloop + 1 !! ループカウンタのインクリメント call Solver % diagnosis ( nloop , time , fluid ) ; call kutimer__ ( 'main  ' , 'solv d' ) !! 診断。異常があればjob.carteにセットする。 call vis2d % draw ( time , nloop , fluid ) !! シミュレーション領域の断面図をSVGで出力する。 if ( nloop >= Params % get_integer ( 'Total_nloop' ) ) then Job % karte = \"loop_max\" !! あらかじめparamsモジュールで設定されたループカウンタの !! 上限値に達したらジョブを停止する。 end if end do call kutimer__end ( 'main  ' ) call kutimer__print call Job % finalize ( nloop ) !! ジョブの後始末。MPI終了処理を含む。 end program main_m","tags":"","loc":"sourcefile/main.f90.html"},{"title":"solver.F90 – Smoke Ring","text":"< This file depends on sourcefile~~solver.f90~~EfferentGraph sourcefile~solver.f90 solver.F90 sourcefile~constants.f90 constants.F90 sourcefile~solver.f90->sourcefile~constants.f90 sourcefile~field.f90 field.F90 sourcefile~solver.f90->sourcefile~field.f90 sourcefile~fluid.f90 fluid.F90 sourcefile~solver.f90->sourcefile~fluid.f90 sourcefile~grid.f90 grid.F90 sourcefile~solver.f90->sourcefile~grid.f90 sourcefile~job.f90 job.F90 sourcefile~solver.f90->sourcefile~job.f90 sourcefile~parallel.f90 parallel.F90 sourcefile~solver.f90->sourcefile~parallel.f90 sourcefile~params.f90 params.F90 sourcefile~solver.f90->sourcefile~params.f90 sourcefile~field.f90->sourcefile~constants.f90 sourcefile~field.f90->sourcefile~grid.f90 sourcefile~field.f90->sourcefile~parallel.f90 sourcefile~fluid.f90->sourcefile~constants.f90 sourcefile~fluid.f90->sourcefile~field.f90 sourcefile~fluid.f90->sourcefile~grid.f90 sourcefile~fluid.f90->sourcefile~parallel.f90 sourcefile~grid.f90->sourcefile~constants.f90 sourcefile~grid.f90->sourcefile~parallel.f90 sourcefile~job.f90->sourcefile~constants.f90 sourcefile~job.f90->sourcefile~parallel.f90 sourcefile~parallel.f90->sourcefile~constants.f90 sourcefile~params.f90->sourcefile~constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~solver.f90~~AfferentGraph sourcefile~solver.f90 solver.F90 sourcefile~main.f90 main.F90 sourcefile~main.f90->sourcefile~solver.f90 sourcefile~vis2d.f90 vis2d.F90 sourcefile~main.f90->sourcefile~vis2d.f90 sourcefile~vis2d.f90->sourcefile~solver.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Modules solver_m Source Code solver.F90 Source Code !!> !   author: Akira Kageyama !   date: 2023.05.05 ! !   ナビエ・ストークス方程式ソルバ ! !   @note !     Initialize_done, Viscosity など、頭文字だけが大文字の !     変数名はこのモジュール全体にscopeを持つ変数である。 !     つまりこのモジュールの中の任意のサブルーチン・関数からアクセスできる。 !     ただし、このモジュールの外からはアクセスできない（privateである） ! !   @note !     サブルーチンsubfield_velでは構造体の割り算 !        vel = fluid.flux / fluid.density !     をコメントアウトとしている。 !     Fortranコンパイラが自己定義演算子を問題なく使えるのであれば !     コメントを外してこれを使うほうが記述が簡潔になる。 !     詳しくはfieldモジュールを見よ。 ! !     サブルーチンsolver__advanceでの !         gluid = fluid + dfluid01*0.5_DR !     などといった記述についても同様。 ! !   @bug !     関数 solver__set_time_step で !        vmax = maxval(sqrt(vel.x**2+vel.y**2+vel.z**2)) !     という演算はmaxvalとsqrtは交換して !        vmax = sqrt(maxval(vel.x**2+vel.y**2+vel.z**2)) !     とした方が速くなる可能性が高い。 !     このままだと3次元配列の全要素にsqrt !     を掛けてからそのmaxvalをとっているが、この順番は !     逆にした方が速いだろう。 ! !    @bug !     その少し下の !        sound_v = GAMMA*maxval(sqrt(GASS_CONST_FOR_AIR*tm)) !     も同様に !        sound_v = GAMMA*sqrt(maxval(GASS_CONST_FOR_AIR*tm)) !     とすべきだろう。 !!< module solver_m use constants_m !! 定数定義 use field_m !! スカラー場・ベクトル場 use fluid_m !! 流体場の構造体定義 use grid_m !! 格子点 use job_m !! ジョブ管理 use mpiut_m !! MPIユーティリティ use parallel_m !! MPI並列化 use params_m !! パラメータ use ut_m !! ユーティリティ implicit none !! 暗黙の型宣言無効化。必須 private !! このモジュール内の変数・ルーチン等はデフォルトで非公開 type , private :: solver_t contains procedure , nopass :: advance => solver__advance procedure , nopass :: diagnosis => solver__diagnosis procedure , nopass :: initialize => solver__initialize procedure , nopass :: set_time_step => solver__set_time_step procedure , nopass , private :: subfield_vel procedure , nopass , private :: subfield_vel_tm procedure , nopass , private :: subfield_vel_tm_divv generic :: get_subfield => subfield_vel , & subfield_vel_tm , & subfield_vel_tm_divv !! 流体の基本変数（質量フラックス、質量密度、圧力） !! から二次的な量（流れ場、温度場、速度の発散） !! を計算するためのルーチン群の多重定義 end type solver_t type ( solver_t ), public :: Solver real ( DR ), parameter :: GAMMA = 1.4_DR !! 空気の比熱比 real ( DR ), parameter :: GASS_CONST_FOR_AIR = 2.87e2_DR !! 空気の気体定数 !!  空気の状態方程式 !!     Pressure = 287 * Mass_density * Temperature logical , save :: Initialize_done = . false . !! モジュール初期化確認フラグ real ( DR ), save :: Viscosity !! 粘性率 real ( DR ), save :: Gamma1_kappa !! (GAMMA-1)*kappa !! kappaは熱拡散率 type ( field__vector_t ), save :: Drive_force !! 渦輪を駆動する力 contains function drive_force_factor ( time ) !! 渦輪を駆動する力の時間変化の調整のための係数設定 !! !! @note この係数は0以上1以下。これはassertで確認している。 !! real ( DR ), intent ( in ) :: time !! シミュレーション時刻 real ( DR ) :: drive_force_factor !! 力の強さ係数 0から1 !!> !                                           factor !                   ___________               | !                  /|         |\\              | !           ______/ |         | \\______       +--------> time !                 | |         |  | !                 | |         |  | !                 | t0        t1 | !               t_start         t_end !!< real ( DR ), parameter :: T_START = 0.0_DR !! 力をかけ始める時刻 real ( DR ), parameter :: T_END = 0.01_DR !! 力をかけ終わる時刻 !! 試行錯誤で調整せよ real ( DR ), parameter :: T0 = T_START + ( T_END - T_START ) / 4 real ( DR ), parameter :: T1 = T_END - ( T_END - T_START ) / 4 !! 上のコメント図をみよ !! これも試行錯誤で調整せよ real ( DR ), parameter :: ONE = 1.0_DR !! コードの読みやすさのため定義 real ( DR ), parameter :: ZERO = 0.0_DR !! コードの読みやすさのため定義 call ut__assert ( T_START < T0 . and . T0 < T1 . and . T1 < T_END , & \"solver_m(121): Time inconsistent.\" ) !! この関係は以下の前提なのでアサートで確認しておく !! 上のコメント図の時間依存係数 if ( time <= T_START ) then drive_force_factor = ZERO else if ( time <= T0 ) then drive_force_factor = ( time - T_START ) / ( T0 - T_START ) else if ( time <= T1 ) then drive_force_factor = ONE else if ( time <= T_END ) then drive_force_factor = ONE - ( time - T1 ) / ( T_END - T1 ) else drive_force_factor = ZERO end if call ut__assert ( drive_force_factor >= 0.0_DR . and . & drive_force_factor <= 1.0_DR , & \"solver_m(139): strange value.\" ) end function drive_force_factor subroutine set_drive_force_field !! 渦輪を駆動するための力の場を設定する !! その力はシミュレーション開始直後、短い時間だけかける。 !! 空間的には局在した力を想定している。その形状は円筒形である。 !! 円筒の軸はx軸上にある。 integer :: i , j , k real ( DR ) :: xx , yy , zz real ( DR ) :: force_region_x_min , force_region_x_max real ( DR ) :: force_center_y , force_center_z real ( DR ) :: force_cylinder_diameter , force_cylinder_radius_sq real ( DR ), parameter :: THE_FORCE = 3.e3_DR !! 瞬間的な力の最大値。 !! 試行錯誤で調整せよ。 !!> !          +--------------------------------------+ ZMAX !          |                                      | !          |    +-------+                         | !          |    | Force |                         | !          |    +-------+                         | !          |                                      | !          +--------------------------------------+ ZMIN !         XMIN                                   XMAX !!< force_region_x_min = XMIN + ( XMAX - XMIN ) / 5 !! 力をかける局所円筒領域のx方向の最小値 force_region_x_max = force_region_x_min + ( XMAX - XMIN ) / 10 !! 力をかける局所円筒領域のx方向の最大値 force_center_y = ( YMAX + YMIN ) / 2 !! 力をかける局所円筒領域の中心のy座標を中間にとる force_center_z = ( ZMAX + ZMIN ) / 2 !! 力をかける局所円筒領域の中心のz座標を中間にとる force_cylinder_diameter = min ( YMAX - YMIN , ZMAX - ZMIN ) / 4 !! 力をかける局所円筒領域の直径 force_cylinder_radius_sq = ( force_cylinder_diameter / 2 ) ** 2 !! 力をかける局所円筒領域の半径の2乗 do k = 1 , NZPP !! 境界上の格子点を飛ばして、シミュレーション領域内部 !! を回る3重do loop。境界上の格子点で値は境界条件で設定する。 zz = grid % pos % z ( k ) - force_center_z !! 力の中心からのz方向の距離 do j = 1 , NYPP yy = grid % pos % y ( j ) - force_center_y !! 力の中心からのy方向の距離 do i = 1 , NXPP xx = grid % pos % x ( i ) !! これは格子点のx座標そのもの if ( ( yy ** 2 + zz ** 2 ) < force_cylinder_radius_sq & . and . & ( xx > force_region_x_min ) & . and . & ( xx < force_region_x_max ) ) then !! ここで半径そのもので比較するとsqrtの計算が必要になるが !! このように2乗同士で比較すれば不要。 Drive_force % x ( i , j , k ) = THE_FORCE !! いまはx方向だけに力がかかる Drive_force % y ( i , j , k ) = 0.0_DR !! としている。斜め方向に力を Drive_force % z ( i , j , k ) = 0.0_DR !! かけるにはこの部分を変更。 else Drive_force % x ( i , j , k ) = 0.0_DR Drive_force % y ( i , j , k ) = 0.0_DR Drive_force % z ( i , j , k ) = 0.0_DR end if end do end do end do call field__boundary_condition ( Drive_force ) !! 1. プロセス間通信を行い、分割領域の境界値を設定する !! 2. シミュレーション領域全体の境界条件を設定する。 end subroutine set_drive_force_field subroutine subfield_vel ( fluid , vel ) !! fluidの基本変数から二次的な場vel（流れの速度ベクトル場） !! をもとめる。 type ( fluid_t ) , intent ( in ) :: fluid !! 流体基本場 type ( field__vector_t ), intent ( out ) :: vel !! 流れの速度ベクトル vel = fluid % flux / fluid % density !! 割り算演算子はfield_mで定義している。 end subroutine subfield_vel subroutine subfield_vel_tm ( fluid , vel , tm ) !! fluidの基本変数から二次的な場（速度ベクトル場velと温度場tm） !! をもとめる。 type ( fluid_t ) , intent ( in ) :: fluid !! 流体基本場 type ( field__vector_t ), intent ( out ) :: vel !! 流れ場 real ( DR ), dimension ( 0 : NXPP1 , 0 : NYPP1 , 0 : NZPP1 ), intent ( out ) :: tm !! 温度場 vel = fluid % flux / fluid % density tm = fluid % pressure / ( GASS_CONST_FOR_AIR * fluid % density ) !! fluid構造体の割り算演算子はfluid_mで定義している。 end subroutine subfield_vel_tm subroutine subfield_vel_tm_divv ( fluid , vel , tm , divv ) !! fluidの基本変数から二次的な場（速度ベクトル場velと !! 温度場tmと速度の発散divv）をもとめる。 type ( fluid_t ) , intent ( in ) :: fluid !! 流体基本場 type ( field__vector_t ), intent ( out ) :: vel !! 流れ場 real ( DR ), dimension ( 0 : NXPP1 , 0 : NYPP1 , 0 : NZPP1 ), intent ( out ) :: tm !! 温度場 real ( DR ), dimension ( 0 : NXPP1 , 0 : NYPP1 , 0 : NZPP1 ), intent ( out ) :: divv !! 流れの発散 vel = fluid % flux / fluid % density ! operator defined in field.f90. tm = fluid % pressure / fluid % density divv = . div . vel end subroutine subfield_vel_tm_divv function the_equation ( t , dt , vx , vy , vz , tm , divv , fx , fy , fz , ps ) !! ナビエ・ストークス方程式の右辺（時間変化量）dtを掛けたものを計算 !! !! @note !!    粘性による加熱の効果は小さいので無視している。 !!    この項を入れる場合は圧力の方程式 !!    the_equation.pressure に追加すればよい。 real ( DR ), intent ( in ) :: t , dt !! 時刻と時間刻み幅 real ( DR ), dimension ( 0 : NXPP1 , 0 : NYPP1 , 0 : NZPP1 ), intent ( in ) :: vx , vy , vz !! 速度3成分 real ( DR ), dimension ( 0 : NXPP1 , 0 : NYPP1 , 0 : NZPP1 ), intent ( in ) :: tm , divv !! 温度と速度の発散 real ( DR ), dimension ( 0 : NXPP1 , 0 : NYPP1 , 0 : NZPP1 ), intent ( in ) :: fx , fy , fz !! 質量フラックス real ( DR ), dimension ( 0 : NXPP1 , 0 : NYPP1 , 0 : NZPP1 ), intent ( in ) :: ps !! 圧力 type ( fluid_t ) :: the_equation !! 時間刻みdtでの流体データの微小変化量 integer :: i , j , k real ( DR ), parameter :: ONE_THIRD = 1.0_DR / 3.0_DR !! 演算回数節約のため real ( DR ) :: gradpx , gradpy , gradpz !! 圧力の勾配 (gradient p) real ( DR ) :: gdivvx , gdivvy , gdivvz !! 速度の発散の勾配 real ( DR ) :: divfvx , divfvy , divfvz !! 速度・密度フラックステンソルの発散 real ( DR ) :: lapvx , lapvy , lapvz , laptm !! 速度と温度のラプラシアン real ( DR ) :: divf !! 質量フラックスの発散 real ( DR ) :: factor !! 渦輪駆動力の係数（時間依存） call ut__assert ( Initialize_done , & \"solver_m(275): Forgot init?\" ) !! 初期化忘れしていないか確認 factor = drive_force_factor ( t ) !! 渦輪の駆動力はシミュレーション開始直後だけかける。 !! その後は何も力をかけない（渦輪が自然に発生し、リング上の !! 構造が移動していく。）つまりこのfactorはシミュレーション !! 開始直後だけ非ゼロで、残りの殆どの時間はゼロが入っている。 !! 以下のdo loopがこのシミュレーションで最も時間のかかる !! 部分である。したがってここでは.div.などのユーザ定義 !! 演算子は（コンパイラがその使用を許したとしても）あえて !! 使わず、泥臭く書いている。これは将来、 !! 速度向上のためにコードの最適化をしたり、 !! OpenMP化することを見越してのことである。 do k = 1 , NZPP do j = 1 , NYPP do i = 1 , NXPP !! 以下のコメントでは !! P 圧力 !! V 速度場ベクトル !! F 質量フラックスベクトル !! T 温度 !! grad P gradpx = ( ps ( i + 1 , j , k ) - ps ( i - 1 , j , k ) ) * grid % d1 % x gradpy = ( ps ( i , j + 1 , k ) - ps ( i , j - 1 , k ) ) * grid % d1 % y gradpz = ( ps ( i , j , k + 1 ) - ps ( i , j , k - 1 ) ) * grid % d1 % z !! grad (div V) の3成分 gdivvx = ( divv ( i + 1 , j , k ) - divv ( i - 1 , j , k ) ) * grid % d1 % x gdivvy = ( divv ( i , j + 1 , k ) - divv ( i , j - 1 , k ) ) * grid % d1 % y gdivvz = ( divv ( i , j , k + 1 ) - divv ( i , j , k - 1 ) ) * grid % d1 % z !! VFテンソルの発散 div(VF) の3成分 divfvx = ( fx ( i + 1 , j , k ) * vx ( i + 1 , j , k ) & - fx ( i - 1 , j , k ) * vx ( i - 1 , j , k ) ) * grid % d1 % x & + ( fx ( i , j + 1 , k ) * vy ( i , j + 1 , k ) & - fx ( i , j - 1 , k ) * vy ( i , j - 1 , k ) ) * grid % d1 % y & + ( fx ( i , j , k + 1 ) * vz ( i , j , k + 1 ) & - fx ( i , j , k - 1 ) * vz ( i , j , k - 1 ) ) * grid % d1 % z divfvy = ( fy ( i + 1 , j , k ) * vx ( i + 1 , j , k ) & - fy ( i - 1 , j , k ) * vx ( i - 1 , j , k ) ) * grid % d1 % x & + ( fy ( i , j + 1 , k ) * vy ( i , j + 1 , k ) & - fy ( i , j - 1 , k ) * vy ( i , j - 1 , k ) ) * grid % d1 % y & + ( fy ( i , j , k + 1 ) * vz ( i , j , k + 1 ) & - fy ( i , j , k - 1 ) * vz ( i , j , k - 1 ) ) * grid % d1 % z divfvz = ( fz ( i + 1 , j , k ) * vx ( i + 1 , j , k ) & - fz ( i - 1 , j , k ) * vx ( i - 1 , j , k ) ) * grid % d1 % x & + ( fz ( i , j + 1 , k ) * vy ( i , j + 1 , k ) & - fz ( i , j - 1 , k ) * vy ( i , j - 1 , k ) ) * grid % d1 % y & + ( fz ( i , j , k + 1 ) * vz ( i , j , k + 1 ) & - fz ( i , j , k - 1 ) * vz ( i , j , k - 1 ) ) * grid % d1 % z !! Laplacin V の3成分 lapvx = ( vx ( i + 1 , j , k ) - 2 * vx ( i , j , k ) + vx ( i - 1 , j , k ) ) * grid % d2 % x & + ( vx ( i , j + 1 , k ) - 2 * vx ( i , j , k ) + vx ( i , j - 1 , k ) ) * grid % d2 % y & + ( vx ( i , j , k + 1 ) - 2 * vx ( i , j , k ) + vx ( i , j , k - 1 ) ) * grid % d2 % z lapvy = ( vy ( i + 1 , j , k ) - 2 * vy ( i , j , k ) + vy ( i - 1 , j , k ) ) * grid % d2 % x & + ( vy ( i , j + 1 , k ) - 2 * vy ( i , j , k ) + vy ( i , j - 1 , k ) ) * grid % d2 % y & + ( vy ( i , j , k + 1 ) - 2 * vy ( i , j , k ) + vy ( i , j , k - 1 ) ) * grid % d2 % z lapvz = ( vz ( i + 1 , j , k ) - 2 * vz ( i , j , k ) + vz ( i - 1 , j , k ) ) * grid % d2 % x & + ( vz ( i , j + 1 , k ) - 2 * vz ( i , j , k ) + vz ( i , j - 1 , k ) ) * grid % d2 % y & + ( vz ( i , j , k + 1 ) - 2 * vz ( i , j , k ) + vz ( i , j , k - 1 ) ) * grid % d2 % z !! Laplacin T laptm = ( tm ( i + 1 , j , k ) - 2 * tm ( i , j , k ) + tm ( i - 1 , j , k ) ) * grid % d2 % x & + ( tm ( i , j + 1 , k ) - 2 * tm ( i , j , k ) + tm ( i , j - 1 , k ) ) * grid % d2 % y & + ( tm ( i , j , k + 1 ) - 2 * tm ( i , j , k ) + tm ( i , j , k - 1 ) ) * grid % d2 % z !! div F divf = ( fx ( i + 1 , j , k ) - fx ( i - 1 , j , k ) ) * grid % d1 % x & + ( fy ( i , j + 1 , k ) - fy ( i , j - 1 , k ) ) * grid % d1 % y & + ( fz ( i , j , k + 1 ) - fz ( i , j , k - 1 ) ) * grid % d1 % z !! 以下がナビエ・ストークス方程式 !!  密度の時間発展 the_equation % density ( i , j , k ) = - divf * dt !!  質量フラックスの時間発展（3成分） the_equation % flux % x ( i , j , k ) = & ( - divfvx & - gradpx & + Drive_force % x ( i , j , k ) * factor & + Viscosity * ( lapvx + ONE_THIRD * gdivvx ) & ) * dt the_equation % flux % y ( i , j , k ) = & ( - divfvy & - gradpy & + Drive_force % y ( i , j , k ) * factor & + Viscosity * ( lapvy + ONE_THIRD * gdivvy ) & ) * dt the_equation % flux % z ( i , j , k ) = & ( - divfvz & - gradpz & + Drive_force % z ( i , j , k ) * factor & + Viscosity * ( lapvz + ONE_THIRD * gdivvz ) & ) * dt !!  圧力の時間発展 the_equation % pressure ( i , j , k ) = & ( - ( vx ( i , j , k ) * gradpx & + vy ( i , j , k ) * gradpy & + vz ( i , j , k ) * gradpz & ) & + Gamma1_kappa * laptm & - GAMMA * ps ( i , j , k ) * divv ( i , j , k ) & ) * dt end do end do end do call the_equation % set_boundary_condition !! 境界条件の設定（周期境界条件） !! 上のdo loopは境界面上の格子点を除いた格子点（シミュレーション !! 領域の内部の格子点）上での値を計算するものであった。 !! ここで境界面上の格子点の値の（更新されたばかりの）内部の !! 格子点上のデータをコピーすることで設定する。 end function the_equation !!> !  Private  これより上が非公開の関数・ルーチン ! - - - - - - - - - - - - - - - - - - - - - - - - !  Public   これより下が公開する関数・ルーチン !!< subroutine solver__advance ( t , dt , fluid ) !! 4段4次ルンゲ・クッタ積分法による時間積分の実行 !! !! @note !!   ここでは教科書に書かれている古典的な4段4次の !!   ルンゲ・クッタ積分法をそのまま実装している。 !!   作業用の構造体を5つ使用している（dfluid01からdfluid04とgluid） !!   これらの作業変数の数を減らし、メモリを節約にするためには !!   Runge-Kutta-Gill法などの方法がある。 !! !! @note !!   速度（vel）、温度（tm）, 速度の発散（divv）などの配列などは !!   このスキームでは基本変数から毎回計算すべき一種の作業配列である。 !!   したがって、このモジュール内の他の場所（サブルーチン・関数）でも !!   これらの変数（3次元の大きな配列）を宣言・使用している。 !!   使用メモリを節約するためにはこれらの作業配列は共通のものを !!   一つづつ用意するというのも可能である。しかし、そうするとコードが !!   読みにくくなるであろう。 real ( DR ), intent ( inout ) :: t !! 時刻 real ( DR ), intent ( in ) :: dt !! 時間刻み幅 type ( fluid_t ), intent ( inout ) :: fluid !! 流体データ real ( DR ), parameter :: ONE_SIXTH = 1.0_DR / 6.0_DR !! 演算数節約の real ( DR ), parameter :: ONE_THIRD = 1.0_DR / 3.0_DR !! ために定義 type ( field__vector_t ) :: vel !! 速度場 real ( DR ), dimension ( 0 : NXPP1 , 0 : NYPP1 , 0 : NZPP1 ) :: tm !! 温度場 real ( DR ), dimension ( 0 : NXPP1 , 0 : NYPP1 , 0 : NZPP1 ) :: divv !! 速度場の発散 type ( fluid_t ) :: dfluid01 , dfluid02 , dfluid03 , dfluid04 !! 古典的な4段4次ルンゲ・クッタ積分法に必要な4つの作業配列 !! サイズが大きいことに注意。 type ( fluid_t ) :: gluid !! work variable !! さらにもう一つの作業配列 !! サイズが大きいことに注意。 !!---ルンゲ・クッタの第1段--- call subfield_vel_tm_divv ( fluid , vel , tm , divv ) !! 基本変数から副次的変数である速度、温度、速度の発散を求める dfluid01 = the_equation ( t , dt , & vel % x , vel % y , vel % z , tm , divv , & fluid % flux % x , fluid % flux % y , fluid % flux % z , & fluid % pressure ) t = t + dt / 2 !! 渦輪を駆動する力は時刻（t）の関数として設定しているので、 !! いま解いているナビエ・ストークス方程式は時間に陽に依存する。 !!---ルンゲ・クッタの第2段--- gluid = fluid + dfluid01 * 0.5_DR !! Fortranコンパイラが自己定義演算子をきちんと処理できる !! 場合は上の簡潔な記述の方が（読みやすいので）好ましい。 call subfield_vel_tm_divv ( gluid , vel , tm , divv ) dfluid02 = the_equation ( t , dt , & vel % x , vel % y , vel % z , tm , divv , & gluid % flux % x , gluid % flux % y , gluid % flux % z , & gluid % pressure ) !!---ルンゲ・クッタの第3段--- gluid = fluid + dfluid02 * 0.5_DR !! Fortranコンパイラが自己定義演算子をきちんと処理できる !! 場合は上の簡潔な記述の方が（読みやすいので）好ましい。 call subfield_vel_tm_divv ( gluid , vel , tm , divv ) dfluid03 = the_equation ( t , dt , & vel % x , vel % y , vel % z , tm , divv , & gluid % flux % x , gluid % flux % y , gluid % flux % z , & gluid % pressure ) t = t + dt / 2 !! 繰り返すが、渦輪を駆動する力は時刻（t）の関数として設定しているので、 !! いま解いているナビエ・ストークス方程式は時間に陽に依存する。 !!---ルンゲ・クッタの第4段--- gluid = fluid + dfluid03 !! Fortranコンパイラが自己定義演算子をきちんと処理できる !! 場合は上の簡潔な記述の方が（読みやすいので）好ましい。 call subfield_vel_tm_divv ( gluid , vel , tm , divv ) dfluid04 = the_equation ( t , dt , & vel % x , vel % y , vel % z , tm , divv , & gluid % flux % x , gluid % flux % y , gluid % flux % z , & gluid % pressure ) !!--- 最終結果 --- fluid = fluid + ONE_SIXTH * ( dfluid01 + 2 * dfluid02 + 2 * dfluid03 + dfluid04 ) !! Fortranコンパイラが自己定義演算子をきちんと処理できる !! 場合は一番上の簡潔な記述の方が（読みやすいので）好ましい。 end subroutine solver__advance subroutine solver__diagnosis ( nloop , time , fluid ) !! 流体の「健康状態」を診断する integer , intent ( in ) :: nloop !! ループカウンタ real ( DR ), intent ( in ) :: time !! シミュレーション時刻 type ( fluid_t ), intent ( in ) :: fluid !! 流体データ integer , parameter :: SKIP = 100 !! このルーチンは結構計算負荷が高いので、 !! 毎ステップではなく、SKIPステップごとに診断を実行する real ( DR ), parameter :: ANOMALOUSLY_LARGE = 1.e20_DR !! これよりも物理量が大きくなったら異常が生じたと判断する type ( field__vector_t ) :: vel !! 流れの速度場 if ( mod ( nloop , SKIP ) /= 0 ) return !! このルーチンは結構計算負荷が高いので、 !! 毎ステップではなく、SKIPステップごとに診断を実行する if ( Job % karte /= \"fine\" ) return !! Already in error state. !! ジョブの健康状態がfine（つまり健康）以外の値に !! 設定する可能性があるのはここ以外にもある（例えばmain.f90の !! メインループでシミュレーションのループカウンタが最大値が達するなど） !! そのような場合、どうせこの後、ジョブの停止処理に入るので、 !! これ以上計算を進めなくてもよい。 if ( maxval ( abs ( fluid % flux % x )) > ANOMALOUSLY_LARGE ) then !! 質量フラックスのx成分が異常に大きい。 call ut__message ( \"solver_m(528): Massflux_x overflow.\" ) Job % karte = \"overflow\" return !! これ以上計算しても無駄（すぐに終了処理に入るべし） end if if ( maxval ( abs ( fluid % flux % y )) > ANOMALOUSLY_LARGE ) then call ut__message ( \"solver_m(535): Massflux_y overflow.\" ) Job % karte = \"overflow\" return !! これ以上計算しても無駄（すぐに終了処理に入るべし） end if if ( maxval ( abs ( fluid % flux % z )) > ANOMALOUSLY_LARGE ) then !! 質量フラックスのz成分が異常に大きい。 call ut__message ( \"solver_m(543): Massflux_z overflow.\" ) Job % karte = \"overflow\" return !! これ以上計算しても無駄（すぐに終了処理に入るべし） end if if ( maxval ( fluid % density ) > ANOMALOUSLY_LARGE ) then !! 質量が異常に大きい call ut__message ( \"solver_m(551): Density overflow.\" ) Job % karte = \"overflow\" return !! これ以上計算しても無駄（すぐに終了処理に入るべし） end if if ( maxval ( fluid % pressure ) > ANOMALOUSLY_LARGE ) then !! 圧力が異常に大きい call ut__message ( \"solver_m(559): Pressure overflow.\" ) Job % karte = \"overflow\" return !! これ以上計算しても無駄（すぐに終了処理に入るべし） end if if ( minval ( fluid % pressure ) < 0.0_DR ) then !! 圧力が負になってしまっている call ut__message ( \" solver_m(567): Negative pressure.\" ) Job % karte = \"negative anormaly\" return !! これ以上計算しても無駄（すぐに終了処理に入るべし） end if if ( minval ( fluid % density ) < 0.0_DR ) then !! 密度が負になってしまっている call ut__message ( \" solver_m(575): Negative density.\" ) Job % karte = \"negative anormaly\" return !! これ以上計算しても無駄（すぐに終了処理に入るべし） end if call subfield_vel ( fluid , vel ) !! 基本流れデータから副次的な速度場データを求める call mpiut__message ( Parallel % comm , & '#max vel:' , & nloop , & time , & sqrt ( maxval ( vel % x ** 2 + vel % y ** 2 + vel % z ** 2 )) ) !! 速度の最大値（ベクトルの長さ）を計算し標準出力に書き出す !! わずか1行で書いているが、実際にはここにかなりの計算が !! 含まれている。vel.x**2という配列演算は実際には3重do loop !! であり、maxval関数はその引数の3次元配列をとっている。 !! つまり全要素中の最大値をとっている。そして最後に !! sqrtをとって振幅（ベクトルの長さ）を計算している。 call mpiut__message ( Parallel % comm , & '#flow energy: ' , & nloop , & time , & . energyintegral . fluid ) !! ここでもこの1行の実行にはかなりの演算（速度ベクトル場 !! のx,y,z3成分の2乗和に質量密度を掛けたもの体積積分）が !! されていることに注意。 call mpiut__message ( Parallel % comm , & '#total mass: ' , & nloop , & time , & . scalarintegral . ( fluid % density ) ) !! 上と同様。こちらのほうは単なる密度場の体積積分なので !! 演算量は少ないが、シミュレーション領域全体に渡る体積積分 !! なので計算量は大きいことにかわりない。 end subroutine solver__diagnosis subroutine solver__initialize ( fluid ) !! モジュールの初期化 type ( fluid_t ), intent ( out ) :: fluid !! 流体データ real ( DR ) :: kappa !! 空気の熱拡散率 !! 物理パラメータの設定 Viscosity = params % get_double ( 'Viscosity' ) !! 空気の粘性率 kappa = params % get_double ( 'Kappa' ) !! 空気の熱拡散率 !! Viscosityと違ってkappaの頭文字が大文字になっていない、つまり !! このモジュールのグローバルスコープを持つ変数としていない !! のはナビエ・ストークス方程式には下で定義するGamma1_kappa !! という量のみを通じてkappaが出てくるからである。 Gamma1_kappa = ( Gamma - 1 ) * kappa !! gammaは比熱比、つまり定積比熱と定圧比熱の比である。 !! 統計力学で習うように、この値は流体（気体）を構成する !! 分子の構造（自由度）で決まる。 !! 流体の初期条件の設定 fluid % pressure = 1.013e5_DR !! 1013 hPa (一気圧) fluid % density = 1.293_DR !! kg/m&#94;3 (空気の密度) fluid % flux = 0.0_DR !! ベクトル3成分。（静止状態） !! 渦輪を駆動するための力の場の設定 call set_drive_force_field Initialize_done = . true . !! モジュール初期化終了フラグ end subroutine solver__initialize function solver__set_time_step ( nloop , fluid ) !! CFL条件に基づいて時間刻み幅dtを設定する integer , intent ( in ) :: nloop !! ループカウンタ type ( fluid_t ), intent ( in ) :: fluid !! 流体データ real ( DR ) :: solver__set_time_step !! 時間刻み幅 dt type ( field__vector_t ) :: vel !! 速度場 real ( DR ), dimension ( 0 : NXPP1 , 0 : NYPP1 , 0 : NZPP1 ) :: tm !! 温度場 real ( DR ) :: vmax , sound_v !! 流れ速度の最大値と音速 real ( DR ) :: dt_vel , dt_sound , dt_viscous , dt_kappa !! 流れ速度、音波、粘性拡散、熱拡散、それぞれで決まる時間刻み幅 !! 実際のdtはこれらのなかで最も厳しい（小さい）値できまる。 real ( DR ), parameter :: ALMOST_ZERO = 1.e-20_DR !! ゼロ割り演算回避のために使う小さい値 real ( DR ), parameter :: ANOMALOUS_VALUE = - 99 9.999_DR !! dtとしてありそうにない値（すぐ下で使う） real ( DR ) :: dt_local !! 各MPIプロセスで計算した時間刻み幅 real ( DR ), save :: dt_global = ANOMALOUS_VALUE !! 時間刻み幅。全プロセスの最小値。 !! 初期設定でなんらかの失敗した場合を検出するため !! 最初はありそうない値を設定しておくが、 !! CFL条件に基づいて正しい値を一度設定したらその後は !! この宣言文にはsave属性がついているので、 !! この関数を抜けたあともその値を覚えている。 integer , parameter :: SKIP = 20 !! dtを毎ステップ計算するのは大変（かなりの時間がかかる） !! のでこのSKIPステップに一度だけ計算する。毎ステップ計算する !! してもdtは1ステップでそれほど大きく変化しないからである。 !! ただし、計算が破綻（発散）するような場合は例外である。 call ut__assert ( Initialize_done , & \"solver_m(682): Forgot init?\" ) !! 初期化忘れ確認 if ( mod ( nloop , SKIP ) == 0 ) then ! ほとんどの場合は、前回計算したdtを使う。 call subfield_vel_tm ( fluid , vel , tm ) !! 基本流体データから速度場と温度場を計算 vmax = maxval ( sqrt ( vel % x ** 2 + vel % y ** 2 + vel % z ** 2 )) !! 速度の最大値（ベクトルの長さの最大値）をもとめる !! ここでは配列演算を駆使して1行で書いているが !! 実際にはかなりの演算をしていることに注意。 !! これはバグではないが、maxvalとsqrtは交換すべき !! だろう。このままだと3次元配列の全要素にsqrt !! を掛けてからそのmaxvalをとっているが、これを !! 逆にした方が速いかもしれない。 vmax = max ( vmax , ALMOST_ZERO ) !! 初期条件では速度場がゼロなのでvmax=0となるが、あとで !! vmaxの割り算が出てくるので問題となる。それを回避するため !! ALMOST_ZEROが十分小さければよい。 sound_v = GAMMA * maxval ( sqrt ( GASS_CONST_FOR_AIR * tm )) !! 音速の最大値 !! これも上と同じ理屈で、maxvalとsqrtは交換すべき !! だろう。このままだと3次元配列の全要素にsqrt !! を掛けてからそのmaxvalをとっているが、これを !! 逆にした方が速いかもしれない。 call ut__assert ( sound_v > ALMOST_ZERO , & \"solver_m(711): sound_v=0?\" ) !! 音速（の最大値）がほとんどゼロになるのは !! 何かがおかしいのですぐに停止 !! 以下では、流れの速さ、音波、粘性拡散、熱拡散の4種類の !! CFL条件で決まる時間刻み幅をそれぞれこの順番に求めている。 dt_vel = 0.8_DR * grid % delta_min / vmax dt_sound = 0.8_DR * grid % delta_min / sound_v dt_viscous = 0.2_DR * ( grid % delta_min ** 2 ) / Viscosity dt_kappa = 0.2_DR * ( grid % delta_min ** 2 ) / Gamma1_kappa !! CFL factor はここでは0.8と0.2にしているが、 !! これは精密な議論に基づいて決めたものではなく、 !! 半経験的に決めた値である。 !! 最後の2つ、粘性拡散と熱拡散によるCFL条件のための !! CFL factor の値 (0.2) というのは少々安全側に設定 !! しすぎているかもしれない。つまりもう少し大きくしても !! 問題ないかもしれない。 dt_local = min ( dt_vel , dt_sound , dt_viscous , dt_kappa ) !! 最終的な時間刻み幅は上記の4種類のdtの最小値できまる。 call mpiut__minval ( Parallel % comm , dt_local , dt_global ) !! すべてのプロセスでの最小値をとる if ( mod ( nloop , SKIP * 100 ) == 0 ) then !! 出力が長くなるが、流体の状態を推測するのに便利なデータ。 !! SKIPをさらに10倍しているのは、それほど頻繁に出力する !! 必要は通常ないからである。 associate ( comm => Parallel % comm ) call mpiut__message_leader ( comm , '     nloop' , nloop ) call mpiut__message_leader ( comm , '      vmax' , vmax ) call mpiut__message_leader ( comm , '    dt_vel' , dt_vel ) call mpiut__message_leader ( comm , '  dt_sound' , dt_sound ) call mpiut__message_leader ( comm , '  dt_kappa' , dt_kappa ) call mpiut__message_leader ( comm , 'dt_viscous' , dt_viscous ) call mpiut__message_leader ( comm , '    --> dt' , dt_global ) end associate end if end if call ut__assert ( dt_global /= ANOMALOUS_VALUE , & \"solver_m(752): dt init failed?\" ) !! SKIPに一度dtを計算し直すが、それ以外は下の行を見れば分かる通り !! 前回のdtの値を流用する。その際、一度もdtを計算したことがなかったら !! まずいのでその検出をANOMALOUS_VALUEを使って検出している。 solver__set_time_step = dt_global !! dt of the prev calc is saved. !! 新たに更新（または前回計算した）dtを返す。 end function solver__set_time_step end module solver_m","tags":"","loc":"sourcefile/solver.f90.html"},{"title":"field.F90 – Smoke Ring","text":"< This file depends on sourcefile~~field.f90~~EfferentGraph sourcefile~field.f90 field.F90 sourcefile~constants.f90 constants.F90 sourcefile~field.f90->sourcefile~constants.f90 sourcefile~grid.f90 grid.F90 sourcefile~field.f90->sourcefile~grid.f90 sourcefile~parallel.f90 parallel.F90 sourcefile~field.f90->sourcefile~parallel.f90 sourcefile~grid.f90->sourcefile~constants.f90 sourcefile~grid.f90->sourcefile~parallel.f90 sourcefile~parallel.f90->sourcefile~constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~field.f90~~AfferentGraph sourcefile~field.f90 field.F90 sourcefile~fluid.f90 fluid.F90 sourcefile~fluid.f90->sourcefile~field.f90 sourcefile~main.f90 main.F90 sourcefile~main.f90->sourcefile~field.f90 sourcefile~main.f90->sourcefile~fluid.f90 sourcefile~solver.f90 solver.F90 sourcefile~main.f90->sourcefile~solver.f90 sourcefile~vis2d.f90 vis2d.F90 sourcefile~main.f90->sourcefile~vis2d.f90 sourcefile~solver.f90->sourcefile~field.f90 sourcefile~solver.f90->sourcefile~fluid.f90 sourcefile~vis2d.f90->sourcefile~field.f90 sourcefile~vis2d.f90->sourcefile~fluid.f90 sourcefile~vis2d.f90->sourcefile~solver.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Modules field_m Source Code field.F90 Source Code !!> !   author: Akira Kageyama !   date: 2023.05.05 ! !   流体場データ構造体 ! !   @note 配列演算を多用している。つまり一行で書かれている部分も !         実際は3重do loopで書かれような大量の演算をしているところが !         多い。このコードをOpenMP化する時には、そのような部分を !         3重do loopに展開して書き直す必要がある。 !!< module field_m use constants_m ! 定数定義 use grid_m ! 格子点 use mpiut_m ! MPI通信ユーティリティ use parallel_m ! 並列化 implicit none ! 暗黙の型宣言無効化。必須 private public :: operator ( . curl . ), & operator ( . div . ), & operator ( . scalarintegral . ), & operator ( . laplacian . ), & operator ( . x . ), & operator ( . dot . ), & operator ( + ), & operator ( * ), & operator ( / ) public :: assignment ( = ) public :: field__boundary_condition interface field__boundary_condition !! 境界条件呼び出しルーチンの多重定義 !! 境界条件を設定する変数の種類によって !! 実際に使用するルーチンが違うが、 !! 呼び出し側では統一した名前でcallする。 !! コンパイラは引数の型で使用するルーチンを !! 判断する。 module procedure boundary_condition_scalar , & boundary_condition_vector end interface !!> !  type field__scalar_t !     !この構造体は efpp_alias.list で以下のようにマクロ定義されている !     !=> \"real(DR), dimension(0:NXPP1,0:NYPP1,0:NZPP1)\" !  end type field__scalar_t !!< type , public :: field__vector_t !! 3次元ベクトル場構造体 !! ここではコンパイル時に配列のサイズが !! 既に決まっているとしているが、そうでない !! 場合、つまり実行時に配列サイズを確定 !! したい場合にはallocatableな配列を使えば良い。 !! !! コード全体にサイズ（行数）がそれほど !! 多くない今のような場合は、配列サイズ !! （=シミュレーションの格子点数）を !! 変更する度にコンパイルしてもたいした !! 時間はかからないのでこのように !! 決め打ちにしても問題ない。 real ( DR ), dimension ( 0 : NXPP1 , 0 : NYPP1 , 0 : NZPP1 ) :: x !! x成分 ! 倍精度浮動小数点数（double real, DR）の ! 3次元配列、という意味。念の為。 real ( DR ), dimension ( 0 : NXPP1 , 0 : NYPP1 , 0 : NZPP1 ) :: y !! y成分 real ( DR ), dimension ( 0 : NXPP1 , 0 : NYPP1 , 0 : NZPP1 ) :: z !! z成分 end type field__vector_t !--- << Operators >> ---! interface operator ( . curl . ) !! ベクトル解析のcurl演算子 module procedure operator_curl end interface interface operator ( . div . ) !! ベクトル解析のdivergence演算子 module procedure operator_div end interface interface operator ( . scalarintegral . ) !! 任意のスカラー場の体積積分をする演算子 module procedure operator_scalarintegral end interface interface operator ( . laplacian . ) !! ラプラシアン演算子 !! スカラー場とベクトル場用の2つの多重定義 module procedure operator_laplacian_scalar module procedure operator_laplacian_vector end interface interface operator ( . x . ) !! ベクトル解析の外積演算子 module procedure operator_cross_product end interface interface operator ( . dot . ) !! ベクトル解析の内積演算子 module procedure operator_dot_product end interface interface operator ( + ) !! 構造体全要素の足し算を+記号で書けるように定義 module procedure operator_vector_add end interface interface operator ( / ) !! ベクトル場の3成分をあるスカラー場で割り算する !! 操作は何度か出てくる（例えば質量フラックスfluxから !! 速度場velocity_vectorを求めるときに !! velocity_vector = flux / mass_density !! という割り算が必要である）この計算を !! スラッシュ記号一つで書けるように定義 module procedure operator_vector_divby_scalar end interface interface operator ( * ) !! 各種構造体に掛け算記号が使えるように定義 module procedure operator_real_times_vector module procedure operator_scalar_times_vector module procedure operator_vector_times_real module procedure operator_vector_times_scalar end interface interface assignment ( = ) !! 各種構造体に代入記号が使えるように定義 module procedure assignment_real_to_vector end interface contains subroutine assignment_real_to_vector ( vector , real ) !! ベクトル場に実数を代入。 !! 初期条件で0にセットするときに使う。 type ( field__vector_t ), intent ( out ) :: vector !! ベクトル場 real ( DR ), intent ( in ) :: real !! 代入する実数 vector % x (:,:,:) = real vector % y (:,:,:) = real vector % z (:,:,:) = real end subroutine assignment_real_to_vector subroutine boundary_condition_scalar ( scalar ) !! スカラー場の境界条件設定 real ( DR ), dimension ( 0 : NXPP1 , 0 : NYPP1 , 0 : NZPP1 ), intent ( inout ) :: scalar !! スカラー場 !! 周期境界条件の設定 call mpiut__exchange ( Parallel % comm , & Parallel % periodic_pair , & scalar ) call mpiut__barrier ( Parallel % comm ) !! プロセス間通信で領域境界データを交換 call mpiut__exchange ( Parallel % comm , & Parallel % rank % next , & scalar ) call mpiut__barrier ( Parallel % comm ) end subroutine boundary_condition_scalar subroutine boundary_condition_vector ( vector ) !! ベクトル場の境界条件設定 type ( field__vector_t ), intent ( inout ) :: vector !! ベクトル場 !! 周期境界条件設定 call mpiut__exchange ( Parallel % comm , & Parallel % periodic_pair , & vector % x , & vector % y , & vector % z ) call mpiut__barrier ( Parallel % comm ) !! プロセス間通信で領域境界データを交換 call mpiut__exchange ( Parallel % comm , & Parallel % rank % next , & vector % x , & vector % y , & vector % z ) call mpiut__barrier ( Parallel % comm ) end subroutine boundary_condition_vector function operator_cross_product ( a , b ) !! ベクトル場の外積 type ( field__vector_t ), intent ( in ) :: a , b !! 掛けるベクトル場 type ( field__vector_t ) :: operator_cross_product !! 外積 operator_cross_product % x = ( a % y ) * ( b % z ) - ( a % z ) * ( b % y ) operator_cross_product % y = ( a % z ) * ( b % x ) - ( a % x ) * ( b % z ) operator_cross_product % z = ( a % x ) * ( b % y ) - ( a % y ) * ( b % x ) end function operator_cross_product function operator_curl ( a ) !! ベクトル場のcurl type ( field__vector_t ), intent ( in ) :: a !! これのcurlをとる type ( field__vector_t ) :: operator_curl !! curlした結果 integer :: i , j , k real ( DR ) :: dx1 , dy1 , dz1 dx1 = grid % d1 % x ! x方向の偏微分演算用定数 dy1 = grid % d1 % y ! y方向の偏微分演算用定数 dz1 = grid % d1 % z ! z方向の偏微分演算用定数 do k = 1 , NZPP ! 境界上の格子点を飛ばして、シミュレーション領域内部 ! の格子点上で差分法によりcurlを計算する do j = 1 , NYPP do i = 1 , NXPP operator_curl % x ( i , j , k ) = dy1 * ( a % z ( i , j + 1 , k ) - a % z ( i , j - 1 , k )) & - dz1 * ( a % y ( i , j , k + 1 ) - a % y ( i , j , k - 1 )) operator_curl % y ( i , j , k ) = dz1 * ( a % x ( i , j , k + 1 ) - a % x ( i , j , k - 1 )) & - dx1 * ( a % z ( i + 1 , j , k ) - a % z ( i - 1 , j , k )) operator_curl % z ( i , j , k ) = dx1 * ( a % y ( i + 1 , j , k ) - a % y ( i - 1 , j , k )) & - dy1 * ( a % x ( i , j + 1 , k ) - a % x ( i , j - 1 , k )) end do end do end do call field__boundary_condition ( operator_curl ) ! 境界の格子点は境界条件ルーチンで設定する end function operator_curl function operator_div ( a ) !! ベクトル場のdivergence type ( field__vector_t ), intent ( in ) :: a !! これのdivをとる real ( DR ), dimension ( 0 : NXPP1 , 0 : NYPP1 , 0 : NZPP1 ) :: operator_div !! 結果 integer :: i , j , k real ( DR ) :: dx1 , dy1 , dz1 dx1 = grid % d1 % x ! x方向の偏微分演算用定数 dy1 = grid % d1 % y ! y方向の偏微分演算用定数 dz1 = grid % d1 % z ! z方向の偏微分演算用定数 do k = 1 , NZPP ! 境界上の格子点を飛ばして、シミュレーション領域内部 ! の格子点上で差分法によりdivergenceを計算する do j = 1 , NYPP do i = 1 , NXPP operator_div ( i , j , k ) = dx1 * ( a % x ( i + 1 , j , k ) - a % x ( i - 1 , j , k )) & + dy1 * ( a % y ( i , j + 1 , k ) - a % y ( i , j - 1 , k )) & + dz1 * ( a % z ( i , j , k + 1 ) - a % z ( i , j , k - 1 )) end do end do end do call field__boundary_condition ( operator_div ) ! 境界の格子点は境界条件ルーチンで設定する end function operator_div function operator_dot_product ( a , b ) !! ベクトル場の内積 type ( field__vector_t ), intent ( in ) :: a , b !! 内積をとるベクトル場 real ( DR ), dimension ( 0 : NXPP1 , 0 : NYPP1 , 0 : NZPP1 ) :: operator_dot_product !! 計算結果 operator_dot_product = a % x * b % x + a % y * b % y + a % z * b % z ! 配列演算 ! ! 実際にはここで3重do_loopが回っている ! OpenMP化するときにはこの簡潔な ! 書き方をやめて3重do_loopに書き直す必要がある。 end function operator_dot_product function operator_laplacian_scalar ( a ) !! スカラー場のラプラシアン real ( DR ), dimension ( 0 : NXPP1 , 0 : NYPP1 , 0 : NZPP1 ), intent ( in ) :: a !! 入力スカラー場 real ( DR ), dimension ( 0 : NXPP1 , 0 : NYPP1 , 0 : NZPP1 ) :: operator_laplacian_scalar !! 計算結果 integer :: i , j , k real ( DR ) :: dx2 , dy2 , dz2 dx2 = grid % d2 % x ! x方向の2階偏微分演算用定数 dy2 = grid % d2 % y ! y方向の2階偏微分演算用定数 dz2 = grid % d2 % z ! z方向の2階偏微分演算用定数 do k = 1 , NZPP ! 境界上の格子点を飛ばして、シミュレーション領域内部 ! の格子点上で差分法により計算する do j = 1 , NYPP do i = 1 , NXPP operator_laplacian_scalar ( i , j , k ) & = dx2 * ( a ( i + 1 , j , k ) - 2 * a ( i , j , k ) + a ( i - 1 , j , k )) & + dy2 * ( a ( i , j + 1 , k ) - 2 * a ( i , j , k ) + a ( i , j - 1 , k )) & + dz2 * ( a ( i , j , k + 1 ) - 2 * a ( i , j , k ) + a ( i , j , k - 1 )) end do end do end do call field__boundary_condition ( operator_laplacian_scalar ) ! 境界の格子点は境界条件ルーチンで設定する end function operator_laplacian_scalar function operator_laplacian_vector ( a ) !! ベクトル場のラプラシアン type ( field__vector_t ), intent ( in ) :: a !! 入力ベクトル場 type ( field__vector_t ) :: operator_laplacian_vector !! 計算結果 integer :: i , j , k real ( DR ) :: dx2 , dy2 , dz2 dx2 = grid % d2 % x ! x方向の2階偏微分演算用定数 dy2 = grid % d2 % y ! y方向の2階偏微分演算用定数 dz2 = grid % d2 % z ! z方向の2階偏微分演算用定数 do k = 1 , NZPP ! 境界上の格子点を飛ばして、シミュレーション領域内部 ! の格子点上で差分法により計算する do j = 1 , NYPP do i = 1 , NXPP operator_laplacian_vector % x ( i , j , k ) & = dx2 * ( a % x ( i + 1 , j , k ) - 2 * a % x ( i , j , k ) + a % x ( i - 1 , j , k )) & + dy2 * ( a % x ( i , j + 1 , k ) - 2 * a % x ( i , j , k ) + a % x ( i , j - 1 , k )) & + dz2 * ( a % x ( i , j , k + 1 ) - 2 * a % x ( i , j , k ) + a % x ( i , j , k - 1 )) operator_laplacian_vector % y ( i , j , k ) & = dx2 * ( a % y ( i + 1 , j , k ) - 2 * a % y ( i , j , k ) + a % y ( i - 1 , j , k )) & + dy2 * ( a % y ( i , j + 1 , k ) - 2 * a % y ( i , j , k ) + a % y ( i , j - 1 , k )) & + dz2 * ( a % y ( i , j , k + 1 ) - 2 * a % y ( i , j , k ) + a % y ( i , j , k - 1 )) operator_laplacian_vector % z ( i , j , k ) & = dx2 * ( a % z ( i + 1 , j , k ) - 2 * a % z ( i , j , k ) + a % z ( i - 1 , j , k )) & + dy2 * ( a % z ( i , j + 1 , k ) - 2 * a % z ( i , j , k ) + a % z ( i , j - 1 , k )) & + dz2 * ( a % z ( i , j , k + 1 ) - 2 * a % z ( i , j , k ) + a % z ( i , j , k - 1 )) end do end do end do call field__boundary_condition ( operator_laplacian_vector ) ! 境界の格子点は境界条件ルーチンで設定する end function operator_laplacian_vector function operator_real_times_vector ( real , vec ) !! 実数にベクトル場を掛ける演算子 real ( DR ), intent ( in ) :: real !! 掛ける実数 type ( field__vector_t ), intent ( in ) :: vec !! 流体場 type ( field__vector_t ) :: operator_real_times_vector !! 計算結果 operator_real_times_vector % x = real * ( vec % x ) operator_real_times_vector % y = real * ( vec % y ) operator_real_times_vector % z = real * ( vec % z ) end function operator_real_times_vector function operator_scalar_times_vector ( scalar , vec ) !! スカラー場にベクトル場を掛ける演算子 real ( DR ), dimension ( 0 : NXPP1 , 0 : NYPP1 , 0 : NZPP1 ), intent ( in ) :: scalar !! スカラー場 type ( field__vector_t ), intent ( in ) :: vec !! ベクトル場 type ( field__vector_t ) :: operator_scalar_times_vector !! 計算結果 operator_scalar_times_vector % x = scalar * ( vec % x ) operator_scalar_times_vector % y = scalar * ( vec % y ) operator_scalar_times_vector % z = scalar * ( vec % z ) end function operator_scalar_times_vector function operator_scalarintegral ( a ) !! スカラー場の体積積分演算子 real ( DR ), dimension ( 0 : NXPP1 , 0 : NYPP1 , 0 : NZPP1 ), intent ( in ) :: a !! スカラー場 real ( DR ) :: operator_scalarintegral !! 体積積分結果 real ( DR ) :: dvol dvol = ( grid % delta % x ) * ( grid % delta % y ) * ( grid % delta % z ) ! 現在のシュミレーションでは格子間隔はx, y, z それぞれに ! 一様であることを仮定している。つまりdx, dy, dzは空間位置に ! 依存せず一定である。 operator_scalarintegral = sum ( a ( 1 : NXPP , & 1 : NYPP , & 1 : NZPP ) ) * dvol ! ここで配列演算の添字が0:NXPP1等ではなく1:NXPPなどに ! 限定されていることに注意。これは体積積分の範囲を計算領域の ! 内部に限定していること、つまり境界上の格子点を除いて ! 積分していることを意味する。境界上の格子点まで ! 入れると重複してカウントしてしまうからである end function operator_scalarintegral function operator_vector_add ( a , b ) !! ベクトル場の和の演算子 type ( field__vector_t ), intent ( in ) :: a , b !! 和をとるベクトル場 type ( field__vector_t ) :: operator_vector_add !! 計算結果 operator_vector_add % x = a % x + b % x operator_vector_add % y = a % y + b % y operator_vector_add % z = a % z + b % z end function operator_vector_add function operator_vector_divby_scalar ( vec , scalar ) !! ベクトル場の各成分をスカラー場で割る type ( field__vector_t ), intent ( in ) :: vec !! ベクトル場 real ( DR ), dimension ( 0 : NXPP1 , 0 : NYPP1 , 0 : NZPP1 ), intent ( in ) :: scalar !! スカラー場 type ( field__vector_t ) :: operator_vector_divby_scalar !! 計算結果 operator_vector_divby_scalar % x = ( vec % x ) / scalar operator_vector_divby_scalar % y = ( vec % y ) / scalar operator_vector_divby_scalar % z = ( vec % z ) / scalar end function operator_vector_divby_scalar function operator_vector_times_real ( vec , real ) !! ベクトル場の実数倍の演算子 type ( field__vector_t ), intent ( in ) :: vec !! ベクトル場 real ( DR ), intent ( in ) :: real !! 掛ける実数 type ( field__vector_t ) :: operator_vector_times_real !! 計算結果 operator_vector_times_real % x = real * ( vec % x ) operator_vector_times_real % y = real * ( vec % y ) operator_vector_times_real % z = real * ( vec % z ) end function operator_vector_times_real function operator_vector_times_scalar ( vec , scalar ) !! ベクトル場にスカラー場を掛ける type ( field__vector_t ), intent ( in ) :: vec !! ベクトル場 real ( DR ), dimension ( 0 : NXPP1 , 0 : NYPP1 , 0 : NZPP1 ), intent ( in ) :: scalar !! スカラー場 type ( field__vector_t ) :: operator_vector_times_scalar !! 計算結果 operator_vector_times_scalar % x = scalar * ( vec % x ) operator_vector_times_scalar % y = scalar * ( vec % y ) operator_vector_times_scalar % z = scalar * ( vec % z ) end function operator_vector_times_scalar end module field_m","tags":"","loc":"sourcefile/field.f90.html"},{"title":"grid.F90 – Smoke Ring","text":"< This file depends on sourcefile~~grid.f90~~EfferentGraph sourcefile~grid.f90 grid.F90 sourcefile~constants.f90 constants.F90 sourcefile~grid.f90->sourcefile~constants.f90 sourcefile~parallel.f90 parallel.F90 sourcefile~grid.f90->sourcefile~parallel.f90 sourcefile~parallel.f90->sourcefile~constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~grid.f90~~AfferentGraph sourcefile~grid.f90 grid.F90 sourcefile~field.f90 field.F90 sourcefile~field.f90->sourcefile~grid.f90 sourcefile~fluid.f90 fluid.F90 sourcefile~fluid.f90->sourcefile~grid.f90 sourcefile~fluid.f90->sourcefile~field.f90 sourcefile~main.f90 main.F90 sourcefile~main.f90->sourcefile~grid.f90 sourcefile~main.f90->sourcefile~field.f90 sourcefile~main.f90->sourcefile~fluid.f90 sourcefile~solver.f90 solver.F90 sourcefile~main.f90->sourcefile~solver.f90 sourcefile~vis2d.f90 vis2d.F90 sourcefile~main.f90->sourcefile~vis2d.f90 sourcefile~solver.f90->sourcefile~grid.f90 sourcefile~solver.f90->sourcefile~field.f90 sourcefile~solver.f90->sourcefile~fluid.f90 sourcefile~vis2d.f90->sourcefile~grid.f90 sourcefile~vis2d.f90->sourcefile~field.f90 sourcefile~vis2d.f90->sourcefile~fluid.f90 sourcefile~vis2d.f90->sourcefile~solver.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Modules grid_m Source Code grid.F90 Source Code !!> !   author: Akira Kageyama !   date: 2023.05.05 ! !   格子点関連情報 ! !   @note !      モジュール名と同じgridというpublicな変数（構造体）を !      定義し、その実体をこのモジュール内に保持している。 !!< module grid_m use constants_m ! 定数定義 use parallel_m ! 並列化モジュール use ut_m ! ユーティリティ implicit none ! 暗黙の型宣言無効化。必須 private ! このモジュール内の変数等はデフォルトでは非公開 type grid__pos_t !! 格子点位置を収める構造体 !! posはpositionの意味 real ( DR ), dimension ( 0 : NXPP1 ) :: x !! x座標（MPI領域分割した real ( DR ), dimension ( 0 : NYPP1 ) :: y !! y座標  各プロセスでの real ( DR ), dimension ( 0 : NZPP1 ) :: z !! z座標  局所的な番号） end type grid__pos_t type grid_pos_by_global_ijk_t real ( DR ), dimension ( NX_GLOBAL ) :: x !! シミュ領域全体にわたる real ( DR ), dimension ( NY_GLOBAL ) :: y !! 格子点番号 global な real ( DR ), dimension ( NZ_GLOBAL ) :: z !! 番号という意味でgi等とよぶ end type grid_pos_by_global_ijk_t type grid_global_ijk_t !! global (gi,gj,gk) from local (li,lj,lk) integer , dimension ( 0 : NXPP1 ) :: gi !! MPIで領域分割した各プロセス integer , dimension ( 0 : NYPP1 ) :: gj !! の局所的な格子点位置から integer , dimension ( 0 : NZPP1 ) :: gk !! シミュ領域全体の格子点位置をとる end type grid_global_ijk_t type grid_local_ijk_from_global_ijk_t !! The opposite of above. integer , dimension ( NX_GLOBAL ) :: li !! グローバルな格子点位置 integer , dimension ( NY_GLOBAL ) :: lj !! から局所的な格子点位置を integer , dimension ( NZ_GLOBAL ) :: lk !! 求める end type grid_local_ijk_from_global_ijk_t type grid__delta_t !! 格子間隔構造体 real ( DR ) :: x !! x方向の格子間隔 real ( DR ) :: y !! y方向の格子間隔 real ( DR ) :: z !! z方向の格子間隔 end type grid__delta_t type grid__derivative_operator_1st_t !! 1階微分（差分）をとる時の演算子（定数） !! 演算回数の節約のため real ( DR ) :: x !! x偏微分 real ( DR ) :: y !! y偏微分 real ( DR ) :: z !! z偏微分 end type grid__derivative_operator_1st_t type grid__derivative_operator_2nd_t !! 2階微分（差分）をとる時の演算子（定数） !! 演算回数の節約のため real ( DR ) :: x !! x偏微分 real ( DR ) :: y !! y偏微分 real ( DR ) :: z !! z偏微分 end type grid__derivative_operator_2nd_t type :: grid_t !! 格子点関係のデータを全て収める構造体 !! このモジュールの中心変数。これを介して外部と !! やり取りする。このグリッド変数の定義 (下記のgrid_t） !! と実体（このgrid）が同じ場所（このgrid_mモジュール内） !! にあるのは少々変則的かもしれないが、このように規模の !! 小さいシミュレーションプログラムではこの方が !! むしろわかりやすいかもしれない。 type ( grid__pos_t ) :: pos !! 格子点位置 type ( grid_pos_by_global_ijk_t ) :: pos_by_global_ijk type ( grid_global_ijk_t ) :: global_ijk type ( grid_local_ijk_from_global_ijk_t ) :: local_ijk_from_global_ijk type ( grid__delta_t ) :: delta !! 格子間隔 real ( DR ) :: delta_min !! 最小の格子間隔 type ( grid__derivative_operator_1st_t ) :: d1 !! 1階微分演算子定数 type ( grid__derivative_operator_2nd_t ) :: d2 !! 2階微分演算子定数 contains procedure :: initialize => grid__initialize !! 初期化関数 !! 初期化のためのメンバー関数 !! こうするとgrid%initializeという形でcallできる procedure :: i_have_gi => grid__i_have_gi !! global格子点giの位置をそのプロセスが含むかどうか。 procedure :: i_have_gj => grid__i_have_gj !! global格子点gjの位置を procedure :: i_have_gk => grid__i_have_gk !! global格子点gkの位置を procedure :: i_have_gijk => grid__i_have_gijk !! global格子点(gi,gj,gk)をそのプロセスが持っている !! かどうか。 end type grid_t type ( grid_t ), public :: Grid ! 実体 contains function initialize_global_ijk () result ( gijk ) type ( grid_global_ijk_t ) :: gijk integer :: i , j , k do i = 0 , NXPP1 gijk % gi ( i ) = NXPP * Parallel % pos % index % i + i + 1 end do do j = 0 , NYPP1 gijk % gj ( j ) = NYPP * Parallel % pos % index % j + j + 1 end do do k = 0 , NZPP1 gijk % gk ( k ) = NZPP * Parallel % pos % index % k + k + 1 end do end function initialize_global_ijk function initialize_local_ijk_from_global_ijk ( gijk ) result ( ans ) type ( grid_global_ijk_t ), intent ( in ) :: gijk type ( grid_local_ijk_from_global_ijk_t ) :: ans !!> !      When NXPP = 4 and NPROC_X = 2, NX_GLOBAL = 10 ! !              gi=> 1   2   3   4   5   6   7   8   9   10 !                   o---o---o---o---o---o---o---o---o---o !            gi-1=> 0   1   2   3   4   5   6   7   8   9 !                   |                   |               . !                   |      [rank 0]     |               . !                   |                   |               . !             li => 0   1   2   3   4   5               . !                   |   |   |   |   |   |               . !                   0   1   2   3   4   5 <= gi-1-0*NXPP. !                   o---o---o---o---o---o---o---o---o---o !                                   |                   | !                                   |      [rank 1]     | !                                   |                   | !                            li =>  0   1   2   3   4   5 !                                   |   |   |   |   |   | !                     gi-1-1*NXPP=> 0   1   2   3   4   5 !!< integer :: gi , gj , gk do gi = 1 , NX_GLOBAL if ( gi < gijk % gi ( 0 ) . or . gi > gijk % gi ( NXPP1 ) ) then ans % li ( gi ) = NIL ! out of scope of this process else ans % li ( gi ) = gi - 1 - NXPP * Parallel % pos % index % i end if end do do gj = 1 , NY_GLOBAL if ( gj < gijk % gj ( 0 ) . or . gj > gijk % gj ( NYPP1 ) ) then ans % lj ( gj ) = NIL ! out of scope of this process else ans % lj ( gj ) = gj - 1 - NYPP * Parallel % pos % index % j end if end do do gk = 1 , NZ_GLOBAL if ( gk < gijk % gk ( 0 ) . or . gk > gijk % gk ( NZPP1 ) ) then ans % lk ( gk ) = NIL ! out of scope of this process else ans % lk ( gk ) = gk - 1 - NZPP * Parallel % pos % index % k end if end do end function initialize_local_ijk_from_global_ijk function initialize_pos_by_global_ijk ( dx , dy , dz ) result ( pos_gijk ) real ( DR ), intent ( in ) :: dx , dy , dz type ( grid_pos_by_global_ijk_t ) :: pos_gijk integer :: gi , gj , gk do gi = 1 , NX_GLOBAL pos_gijk % x ( gi ) = XMIN + dx * ( gi - 1 ) end do do gj = 1 , NY_GLOBAL pos_gijk % y ( gj ) = YMIN + dy * ( gj - 1 ) end do do gk = 1 , NZ_GLOBAL pos_gijk % z ( gk ) = ZMIN + dz * ( gk - 1 ) end do end function initialize_pos_by_global_ijk function initialize_pos ( gijk , pos_by_gijk ) result ( pos ) type ( grid_global_ijk_t ), intent ( in ) :: gijk type ( grid_pos_by_global_ijk_t ), intent ( in ) :: pos_by_gijk type ( grid__pos_t ) :: pos integer :: i , j , k do i = 0 , NXPP1 pos % x ( i ) = pos_by_gijk % x ( gijk % gi ( i ) ) end do do j = 0 , NYPP1 pos % y ( j ) = pos_by_gijk % y ( gijk % gj ( j ) ) end do do k = 0 , NZPP1 pos % z ( k ) = pos_by_gijk % z ( gijk % gk ( k ) ) end do end function initialize_pos ! ! Private  これより上が非公開の関数・ルーチン !=================================================== ! Public   これより下が公開する関数・ルーチン ! function grid__i_have_gi ( grid , gi ) result ( ans ) class ( grid_t ), intent ( in ) :: grid integer , intent ( in ) :: gi logical :: ans ans = gi >= grid % global_ijk % gi ( 1 ) . and . & gi <= grid % global_ijk % gi ( NXPP ) end function grid__i_have_gi function grid__i_have_gj ( grid , gj ) result ( ans ) class ( grid_t ), intent ( in ) :: grid integer , intent ( in ) :: gj logical :: ans ans = gj >= grid % global_ijk % gj ( 1 ) . and . & gj <= grid % global_ijk % gj ( NYPP ) end function grid__i_have_gj function grid__i_have_gk ( grid , gk ) result ( ans ) class ( grid_t ), intent ( in ) :: grid integer , intent ( in ) :: gk logical :: ans ans = gk >= grid % global_ijk % gk ( 1 ) . and . & gk <= grid % global_ijk % gk ( NZPP ) end function grid__i_have_gk function grid__i_have_gijk ( grid , gi , gj , gk ) result ( ans ) class ( grid_t ), intent ( in ) :: grid integer , intent ( in ) :: gi , gj , gk logical :: ans ans = grid % i_have_gi ( gi ) . and . & grid % i_have_gj ( gj ) . and . & grid % i_have_gk ( gk ) end function grid__i_have_gijk subroutine grid__initialize ( grid ) !! gridの初期化 !! !! ここでは周期境界条件を仮定している。 !! !! 構造体のメンバー関数としてcallするときその !! 構造体変数そのものがgridとして自動的に引数にはいる。 !! たとえば、 !!     call sampl_grid%initialize !! は !!     call grid__initialize(sample_grid) !! と解釈される。gridという名前でなくても構わない。 class ( grid_t ), intent ( out ) :: grid !! 格子構造体 real ( DR ) :: dx , dy , dz ! 格子間隔 !!> !       周期境界条件 ! !          --+-----+-----|                             |-----+-----+--- !            6     7     8                             1     2     3 !                  |-----+-----+-----+-----+-----+-----+-----| !                  1     2     3     4     5     6     7     8 !                     |===================================| !                    XMIN                                XMAX !!< dx = ( XMAX - XMIN ) / ( NX_GLOBAL - 2 ) ! from (1.5) to (NX-0.5), see above figure. dy = ( YMAX - YMIN ) / ( NY_GLOBAL - 2 ) ! ここではxminがi=1とi=2の2つの格子点の dz = ( ZMAX - ZMIN ) / ( NZ_GLOBAL - 2 ) ! ちょうど中間に位置すると仮定している。 grid % delta % x = dx ! x方向の格子間隔 grid % delta % y = dy ! y方向の格子間隔 grid % delta % z = dz ! z方向の格子間隔 grid % delta_min = min ( grid % delta % x , grid % delta % y , grid % delta % z ) ! 3つの格子間隔の最小値。 ! CFL条件はこの最小値で決まる。 grid % d1 % x = 1.0_DR / ( 2 * dx ) ! 1階差分演算用定数 grid % d1 % y = 1.0_DR / ( 2 * dy ) ! dはderivativeを表す grid % d1 % z = 1.0_DR / ( 2 * dz ) ! d1は1階差分の意味 grid % d2 % x = 1.0_DR / ( dx ** 2 ) ! 2階差分演算用定数 grid % d2 % y = 1.0_DR / ( dy ** 2 ) ! dはderivativeを表す grid % d2 % z = 1.0_DR / ( dz ** 2 ) ! d2は2階差分の意味 grid % global_ijk = initialize_global_ijk () grid % local_ijk_from_global_ijk & = initialize_local_ijk_from_global_ijk ( grid % global_ijk ) grid % pos_by_global_ijk = initialize_pos_by_global_ijk ( dx , dy , dz ) grid % pos = initialize_pos ( grid % global_ijk , grid % pos_by_global_ijk ) end subroutine grid__initialize end module grid_m","tags":"","loc":"sourcefile/grid.f90.html"}]}